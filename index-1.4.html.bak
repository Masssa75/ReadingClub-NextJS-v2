<!--
    ReadingClub v1.4.0

    Version 1.4 Changes:
    - Removed localStorage fallback for calibration data (Supabase-only)
    - Removed localStorage audio storage (Supabase Storage-only)
    - Audio playback now uses Supabase public URLs
    - Fresh start: no migration from old localStorage data
    - Added Google OAuth + Magic Link authentication
    - Anonymous profiles created on first visit (zero friction)
    - Optional signup after 3 letters calibrated
    - Guest profiles automatically linked to auth account on signup

    Data Storage:
    ‚úÖ Supabase Database: calibration patterns + metadata + user accounts
    ‚úÖ Supabase Storage: audio recordings (WebM)
    ‚úÖ Supabase Auth: Google OAuth + Magic Link email
    ‚úÖ localStorage: guest profile ID + attempt history only

    User Flow:
    1. First visit ‚Üí Anonymous Supabase profile created automatically
    2. Start calibrating immediately (zero friction)
    3. After 3 letters ‚Üí Optional signup prompt (dismissible)
    4. On signup ‚Üí Guest profile linked to authenticated account
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ReadingClub - Learn Phonics with Your Voice</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
            color: white;
        }
        h1 {
            font-size: 48px;
            margin: 20px 0;
            text-shadow: 0 0 20px rgba(124, 179, 66, 0.8);
        }
        .subtitle {
            font-size: 16px;
            color: #ddd;
            margin-bottom: 20px;
        }
        .container {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 30px;
            padding: 40px;
            width: 900px;
            max-width: 95vw;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }
        .tab {
            padding: 15px 30px;
            background: transparent;
            border: none;
            color: #aaa;
            font-size: 18px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        .tab.active {
            color: #FDD835;
            border-bottom-color: #FDD835;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        /* Calibration */
        .calibration-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .phoneme-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
        }
        .phoneme-card:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        .phoneme-card.recording {
            border-color: #F44336;
            background: rgba(244, 67, 54, 0.2);
            animation: pulse 1s infinite;
        }
        .phoneme-card.calibrated {
            border-color: #7CB342;
            background: rgba(124, 179, 66, 0.2);
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }
        .phoneme-letter {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .phoneme-hint {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 5px;
        }
        .phoneme-status {
            font-size: 12px;
            margin-top: 10px;
        }
        .calibration-group-header {
            grid-column: 1 / -1;
            padding: 15px 0 10px 0;
            font-size: 16px;
            font-weight: bold;
            color: #FDD835;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid rgba(253, 216, 53, 0.3);
            margin-bottom: 5px;
        }
        .calibration-group-header:first-child {
            padding-top: 0;
        }

        /* Snapshot thumbnails */
        .snapshots-container {
            display: flex;
            gap: 4px;
            margin-top: 10px;
            justify-content: center;
            min-height: 40px;
        }
        .snapshot-thumb {
            width: 50px;
            height: 40px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            border: 1px solid rgba(124, 179, 66, 0.3);
        }
        .snapshot-thumb.captured {
            border-color: #7CB342;
        }

        /* Pattern visualization */
        .pattern-preview {
            width: 100%;
            height: 60px;
            margin-top: 10px;
            border-radius: 5px;
            overflow: hidden;
        }

        /* Tuner */
        #detectedLetter {
            text-align: center;
            font-size: 180px;
            font-weight: bold;
            color: #7CB342;
            margin: 30px 0;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 10px 30px rgba(124, 179, 66, 0.5);
            transition: all 0.15s;
        }
        #detectedLetter.active {
            transform: scale(1.1);
            color: #FDD835;
            text-shadow: 0 0 50px rgba(253, 216, 53, 0.8);
        }
        .confidence-bar {
            width: 100%;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }
        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #7CB342, #FDD835);
            width: 0%;
            transition: width 0.1s;
        }
        #spectrumCanvas, #spectrumCanvasGame, #spectrumCanvasGame2 {
            width: 100%;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 20px 0;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            font-size: 14px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #FDD835;
        }
        .btn {
            padding: 12px 30px;
            background: #7CB342;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn:hover {
            background: #689F38;
        }
        .actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        .info-box {
            background: rgba(124, 179, 66, 0.1);
            border-left: 4px solid #7CB342;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            font-size: 14px;
            line-height: 1.6;
        }
        #status {
            text-align: center;
            font-size: 14px;
            color: #999;
            margin: 15px 0;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        .level1-letter {
            text-align: center;
            font-size: 180px;
            font-weight: bold;
            color: #FDD835;
            margin: 30px 0;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 10px 30px rgba(253, 216, 53, 0.5);
        }
        .level1-instruction {
            text-align: center;
            font-size: 24px;
            color: #ddd;
            margin: 20px 0;
            min-height: 40px;
        }

        /* Calibration Modal */
        .calibration-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        .calibration-modal.active {
            display: flex;
        }
        .modal-content {
            background: rgba(30, 30, 30, 0.98);
            border-radius: 30px;
            padding: 40px;
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            border: 3px solid #7CB342;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            position: relative;
        }
        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            font-size: 24px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
        }
        .modal-close:hover {
            background: rgba(255, 67, 54, 0.3);
            transform: rotate(90deg);
        }
        .modal-instructions {
            text-align: center;
            color: #ddd;
            font-size: 16px;
            margin-bottom: 20px;
        }
        .modal-letter-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        .modal-letter {
            font-size: 180px;
            font-weight: bold;
            color: #FDD835;
            cursor: pointer;
            display: inline-block;
            text-shadow: 0 10px 30px rgba(253, 216, 53, 0.5);
            transition: all 0.15s;
            text-align: center;
        }
        .modal-letter:hover {
            transform: scale(1.1);
        }
        .modal-listen-icon {
            width: 60px;
            height: 60px;
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.2s;
            filter: drop-shadow(0 2px 8px rgba(253, 216, 53, 0.4));
        }
        .modal-listen-icon:hover {
            opacity: 1;
            transform: scale(1.15);
        }
        .modal-listen-icon svg {
            width: 100%;
            height: 100%;
            fill: #FDD835;
        }
        .modal-captures {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 30px;
        }
        .modal-capture-box {
            width: 100px;
            height: 80px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(124, 179, 66, 0.3);
            border-radius: 10px;
            transition: all 0.3s;
            position: relative;
        }
        .modal-capture-box.ready {
            border-color: #FDD835;
            box-shadow: 0 0 15px rgba(253, 216, 53, 0.5);
            animation: pulse 1.5s infinite;
        }
        .modal-capture-box.recording {
            border-color: #F44336;
            background: rgba(244, 67, 54, 0.2);
            animation: pulse 0.8s infinite;
        }
        .modal-capture-box.captured {
            border-color: #7CB342;
            background: rgba(124, 179, 66, 0.1);
        }
        .modal-capture-box canvas {
            width: 100%;
            height: 100%;
        }
        .mic-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .modal-capture-box.ready .mic-icon {
            opacity: 0.7;
        }
        .mic-icon svg {
            width: 100%;
            height: 100%;
            fill: #FDD835;
            filter: drop-shadow(0 0 5px rgba(253, 216, 53, 0.5));
        }
        .click-arrow {
            position: absolute;
            bottom: 90px;
            left: 50px;
            display: none;
            animation: arrowHover 2s ease-in-out infinite, arrowPulse 1.5s ease-in-out infinite;
        }
        .click-arrow.active {
            display: block;
        }
        .click-arrow svg {
            width: 50px;
            height: 50px;
            filter: drop-shadow(0 2px 10px rgba(124, 179, 66, 0.8));
        }
        @keyframes arrowHover {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        @keyframes arrowPulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        .modal-status {
            text-align: center;
            color: #ddd;
            font-size: 18px;
            margin-top: 20px;
        }
        .modal-next-button {
            display: none;
            margin: 30px auto 0;
            width: 80px;
            height: 80px;
            background: #7CB342;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(124, 179, 66, 0.5);
            animation: nextButtonPulse 1.5s ease-in-out infinite;
        }
        .modal-next-button.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-next-button:hover {
            transform: scale(1.1);
            background: #8BC34A;
            box-shadow: 0 6px 20px rgba(124, 179, 66, 0.7);
        }
        .modal-next-button svg {
            width: 40px;
            height: 40px;
            fill: white;
        }
        @keyframes nextButtonPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Progressive Learning Game */
        .progress-letter-badge {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: #999;
        }
        .auto-cal-dot.ready {
            border-color: #FDD835;
            box-shadow: 0 0 15px rgba(253, 216, 53, 0.5);
            animation: pulse 1.5s infinite;
        }
        .auto-cal-dot.recording {
            border-color: #F44336;
            background: rgba(244, 67, 54, 0.2);
            animation: pulse 0.8s infinite;
        }
        .auto-cal-dot.captured {
            border-color: #7CB342;
            background: rgba(124, 179, 66, 0.3);
        }
        .progress-letter-badge.level1 {
            background: rgba(124, 179, 66, 0.3);
            border-color: #7CB342;
            color: #7CB342;
        }
        .progress-letter-badge.level2 {
            background: rgba(253, 216, 53, 0.3);
            border-color: #FDD835;
            color: #FDD835;
        }
        .progress-letter-badge.level3 {
            background: rgba(244, 67, 54, 0.3);
            border-color: #F44336;
            color: #F44336;
        }
        @keyframes letterPop {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        @keyframes explosionBurst {
            0% { transform: scale(0.5) rotate(0deg); opacity: 1; }
            100% { transform: scale(3) rotate(720deg); opacity: 0; }
        }

        /* Letter Smash Game */
        .smash-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            overflow: hidden;
        }
        .smash-letter {
            position: absolute;
            font-size: 120px;
            font-weight: bold;
            color: #FDD835;
            text-shadow: 0 0 30px rgba(253, 216, 53, 0.8);
            animation: smashPop 0.3s ease-out;
            cursor: pointer;
            user-select: none;
        }
        @keyframes smashPop {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .smash-explosion {
            position: absolute;
            font-size: 80px;
            animation: explode 0.6s ease-out forwards;
            pointer-events: none;
        }
        @keyframes explode {
            0% { transform: scale(1) rotate(0deg); opacity: 1; }
            100% { transform: scale(3) rotate(360deg); opacity: 0; }
        }
        .combo-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 48px;
            font-weight: bold;
            color: #F44336;
            text-shadow: 0 0 20px rgba(244, 67, 54, 0.8);
            animation: comboScale 0.3s ease-out;
        }
        @keyframes comboScale {
            0% { transform: scale(0.5); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* Treasure Hunt Game */
        .treasure-map {
            width: 100%;
            height: 600px;
            background: linear-gradient(135deg, #3a3a2a 0%, #2a2a1a 100%);
            border-radius: 20px;
            position: relative;
            overflow-y: auto;
            padding: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 15px;
            align-content: start;
        }
        .treasure-chest {
            width: 80px;
            height: 80px;
            background: rgba(139, 69, 19, 0.4);
            border: 3px solid rgba(139, 69, 19, 0.6);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        .treasure-chest:hover {
            transform: scale(1.1);
        }
        .treasure-chest.locked {
            border-color: rgba(139, 69, 19, 0.8);
            animation: chestWiggle 2s ease-in-out infinite;
        }
        .treasure-chest.unlocked {
            background: rgba(253, 216, 53, 0.3);
            border-color: #FDD835;
            box-shadow: 0 0 20px rgba(253, 216, 53, 0.5);
        }
        .treasure-chest.current {
            border-color: #F44336;
            box-shadow: 0 0 30px rgba(244, 67, 54, 0.8);
            animation: chestPulse 1s ease-in-out infinite;
        }
        @keyframes chestWiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-2deg); }
            75% { transform: rotate(2deg); }
        }
        @keyframes chestPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }
        .chest-letter {
            font-size: 32px;
            font-weight: bold;
            color: #FDD835;
        }
        .chest-icon {
            font-size: 24px;
            position: absolute;
            bottom: 5px;
        }
        .coin-shower {
            position: absolute;
            font-size: 24px;
            animation: coinFall 1s ease-out forwards;
            pointer-events: none;
        }
        @keyframes coinFall {
            0% { transform: translateY(-50px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100px) rotate(720deg); opacity: 0; }
        }

        /* Beat the Clock Game */
        .clock-container {
            text-align: center;
        }
        .clock-timer {
            font-size: 72px;
            font-weight: bold;
            color: #FDD835;
            text-shadow: 0 0 30px rgba(253, 216, 53, 0.8);
            margin: 30px 0;
        }
        .clock-timer.warning {
            color: #F44336;
            animation: timerPulse 0.5s ease-in-out infinite;
        }
        @keyframes timerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .clock-letter {
            font-size: 180px;
            font-weight: bold;
            color: #FDD835;
            text-shadow: 0 10px 30px rgba(253, 216, 53, 0.5);
            margin: 40px 0;
            transition: all 0.2s;
        }
        .clock-letter.success {
            color: #7CB342;
            transform: scale(1.2);
        }
        .clock-progress {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 30px 0;
        }
        .clock-progress-dot {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #999;
        }
        .clock-progress-dot.completed {
            background: rgba(124, 179, 66, 0.3);
            border-color: #7CB342;
            color: #7CB342;
        }
        .clock-progress-dot.current {
            background: rgba(253, 216, 53, 0.3);
            border-color: #FDD835;
            color: #FDD835;
            animation: dotPulse 1s ease-in-out infinite;
        }
        @keyframes dotPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        /* Instruction Modal Styles */
        .instruction-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 20000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease-out;
        }
        .instruction-modal.active {
            display: flex;
        }
        .instruction-modal-content {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.95) 0%, rgba(118, 75, 162, 0.95) 100%);
            border-radius: 40px;
            padding: 60px;
            max-width: 700px;
            width: 90%;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.9);
            border: 4px solid #FDD835;
            position: relative;
            animation: popIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        .instruction-modal-content.celebration {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.95) 0%, rgba(124, 179, 66, 0.95) 100%);
            border: 5px solid #FDD835;
        }
        .instruction-start-btn {
            background: linear-gradient(135deg, #FDD835 0%, #F9A825 100%);
            color: #333;
            border: none;
            padding: 20px 50px;
            border-radius: 50px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            display: block;
            margin: 0 auto;
            box-shadow: 0 10px 30px rgba(253, 216, 53, 0.4);
        }
        .instruction-start-btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 40px rgba(253, 216, 53, 0.6);
        }
        .instruction-start-btn:active {
            transform: translateY(-2px) scale(1.02);
        }
        .instruction-start-btn.celebration {
            background: linear-gradient(135deg, #FF6B6B 0%, #FF5722 100%);
            color: white;
            font-size: 32px;
            animation: pulse 1.5s ease-in-out infinite;
        }
        .confetti-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes popIn {
            0% {
                transform: scale(0.3);
                opacity: 0;
            }
            70% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 15px 40px rgba(255, 87, 34, 0.6);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 20px 50px rgba(255, 87, 34, 0.8);
            }
        }
        @keyframes confettiFall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* Demo Container Styles */
        .demo-container {
            background: #000;
            width: 300px;
            height: 250px;
            margin: 0 auto 30px auto;
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        .demo-letter {
            position: absolute;
            font-size: 80px;
            font-weight: bold;
            color: #4CAF50;
            left: 50%;
            transform: translateX(-50%);
            top: 0;
            animation: demoFall 3s ease-in-out infinite;
        }
        @keyframes demoFall {
            0% {
                top: -80px;
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            50% {
                top: 85px;
            }
            55% {
                opacity: 1;
                transform: translateX(-50%) scale(1);
            }
            60% {
                opacity: 0;
                transform: translateX(-50%) scale(2);
            }
            100% {
                top: 85px;
                opacity: 0;
                transform: translateX(-50%) scale(2);
            }
        }
    </style>

    <!-- Supabase Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // Initialize Supabase client
        const SUPABASE_URL = 'https://eyrcioeihiaisjwnalkz.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImV5cmNpb2VpaGlhaXNqd25hbGt6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI3NDg0MDUsImV4cCI6MjA3ODMyNDQwNX0.Tj1_XyrC5XsnKtekYop_dWuCdng1hXHHVWqzjr3vJJQ';
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        console.log('‚úÖ Supabase client initialized');

        // ======================
        // Authentication Functions
        // ======================

        let currentUser = null;
        let guestProfileId = null; // Store guest profile ID in localStorage

        async function sendMagicLink() {
            const emailInput = document.getElementById('emailInput');
            const email = emailInput.value.trim();

            if (!email || !email.includes('@')) {
                alert('Please enter a valid email address');
                return;
            }

            try {
                const { error } = await supabase.auth.signInWithOtp({
                    email: email,
                    options: {
                        emailRedirectTo: window.location.origin
                    }
                });

                if (error) throw error;

                closeAuthModal();
                alert(`‚úÖ Magic link sent to ${email}!\n\nCheck your inbox and click the link to sign in.`);
                emailInput.value = '';
            } catch (error) {
                console.error('‚ùå Magic link error:', error);
                alert('Failed to send magic link. Please try again.');
            }
        }

        async function signOut() {
            try {
                const { error } = await supabase.auth.signOut();
                if (error) throw error;

                currentUser = null;
                location.reload(); // Refresh to reset to guest mode
            } catch (error) {
                console.error('‚ùå Sign out error:', error);
            }
        }

        function openAuthModal() {
            document.getElementById('authModal').style.display = 'flex';
        }

        function closeAuthModal() {
            document.getElementById('authModal').style.display = 'none';
        }

        async function linkGuestToAuthUser(userId) {
            // Link the current guest profile to the authenticated user
            if (!guestProfileId) {
                console.log('No guest profile to link');
                return;
            }

            try {
                const { error } = await supabase
                    .from('profiles')
                    .update({ user_id: userId })
                    .eq('id', guestProfileId);

                if (error) throw error;

                console.log('‚úÖ Guest profile linked to authenticated user');
                guestProfileId = null; // Clear guest ID
                localStorage.removeItem('guestProfileId');
            } catch (error) {
                console.error('‚ùå Error linking guest profile:', error);
            }
        }

        async function handleAuthStateChange() {
            // Listen for auth state changes
            supabase.auth.onAuthStateChange(async (event, session) => {
                console.log('Auth state changed:', event, session?.user?.email);

                if (session?.user) {
                    currentUser = session.user;

                    // Show user info
                    document.getElementById('userEmail').textContent = `‚úÖ ${session.user.email}`;
                    document.getElementById('userInfo').style.display = 'block';
                    document.getElementById('saveProgressBtn').style.display = 'none';

                    // Link guest profile if exists
                    await linkGuestToAuthUser(session.user.id);

                    // Load user's profiles
                    await loadUserProfiles(session.user.id);
                } else {
                    currentUser = null;
                    document.getElementById('userInfo').style.display = 'none';
                    document.getElementById('saveProgressBtn').style.display = 'inline-block';
                }
            });

            // Check current session
            const { data: { session } } = await supabase.auth.getSession();
            if (session?.user) {
                currentUser = session.user;
                document.getElementById('userEmail').textContent = `‚úÖ ${session.user.email}`;
                document.getElementById('userInfo').style.display = 'block';
                document.getElementById('saveProgressBtn').style.display = 'none';
            } else {
                document.getElementById('saveProgressBtn').style.display = 'inline-block';
            }
        }

        async function loadUserProfiles(userId) {
            try {
                const { data: profiles, error } = await supabase
                    .from('profiles')
                    .select('*')
                    .eq('user_id', userId);

                if (error) throw error;

                console.log(`‚úÖ Loaded ${profiles.length} profiles for user`);

                // Update UI with user's profiles
                // This will be integrated with existing profile management
            } catch (error) {
                console.error('‚ùå Error loading user profiles:', error);
            }
        }
    </script>
</head>
<body>
    <h1>üìö ReadingClub</h1>
    <div class="subtitle">Learn phonics with your voice - real-time sound recognition</div>

    <!-- Authentication Modal -->
    <div id="authModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; align-items: center; justify-content: center;">
        <div style="background: #2c3e50; padding: 30px; border-radius: 10px; max-width: 400px; text-align: center;">
            <div style="margin-bottom: 20px; color: #ddd; font-size: 20px;">
                üíæ Save your progress
            </div>
            <div style="margin-bottom: 20px; color: #aaa; font-size: 14px;">
                Get a magic link via email to save your calibrations across devices
            </div>
            <input
                id="emailInput"
                type="email"
                placeholder="your@email.com"
                style="
                    width: 100%;
                    padding: 12px 20px;
                    font-size: 16px;
                    border-radius: 5px;
                    background: rgba(255,255,255,0.1);
                    color: white;
                    border: 1px solid #555;
                    margin-bottom: 15px;
                    box-sizing: border-box;
                "
            />
            <button onclick="sendMagicLink()" style="
                width: 100%;
                padding: 12px 30px;
                background: #7CB342;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
                margin-bottom: 10px;
            ">
                Send Magic Link
            </button>
            <button onclick="closeAuthModal()" style="
                width: 100%;
                padding: 8px 20px;
                background: transparent;
                color: #999;
                border: 1px solid #555;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
            ">
                Cancel
            </button>
        </div>
    </div>

    <!-- User Info (when signed in) -->
    <div id="userInfo" style="text-align: center; margin: 20px 0; padding: 15px; background: rgba(124, 179, 66, 0.2); border-radius: 10px; display: none;">
        <span id="userEmail" style="color: #7CB342; margin-right: 15px;"></span>
        <button onclick="signOut()" style="
            padding: 8px 20px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        ">
            Sign Out
        </button>
    </div>

    <!-- Profile Selector -->
    <div style="text-align: center; margin: 20px 0; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 10px;">
        <label style="color: #aaa; margin-right: 10px;">üë§ Profile:</label>
        <select id="profileSelect" onchange="switchProfile()" style="padding: 8px 15px; font-size: 16px; border-radius: 5px; background: #2a2a2a; color: white; border: 1px solid #555;">
        </select>
        <button onclick="createNewProfile()" style="margin-left: 10px; padding: 8px 15px; background: #7CB342; color: white; border: none; border-radius: 5px; cursor: pointer;">‚ûï New Profile</button>
        <button id="saveProgressBtn" onclick="openAuthModal()" style="margin-left: 10px; padding: 8px 15px; background: #5A9; color: white; border: none; border-radius: 5px; cursor: pointer; display: none;">üíæ Save Progress</button>
    </div>

    <!-- Calibration Modal -->
    <div id="calibrationModal" class="calibration-modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeCalibrationModal()">‚úï</button>

            <!-- Instructions -->
            <div class="modal-instructions">
                Click the letter to hear its sound. Click each box below to record 5 sounds.
            </div>

            <!-- Big Letter Display -->
            <div class="modal-letter-container">
                <div id="modalLetter" class="modal-letter" onclick="playModalLetterSound()">A</div>
                <div class="modal-listen-icon" onclick="playModalLetterSound()" title="Click to hear sound">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                    </svg>
                </div>
            </div>

            <!-- 5 Capture Boxes -->
            <div class="modal-captures" style="position: relative;">
                <!-- Green arrow indicator -->
                <div class="click-arrow" id="clickArrow">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 4L12 20M12 20L5 13M12 20L19 13" stroke="#7CB342" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
                    </svg>
                </div>

                <div class="modal-capture-box" id="modalCaptureBox0">
                    <div class="mic-icon">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2C10.9 2 10 2.9 10 4V12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12V4C14 2.9 13.1 2 12 2Z"/>
                            <path d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"/>
                        </svg>
                    </div>
                    <canvas id="modalCaptureCanvas0" width="100" height="80"></canvas>
                </div>
                <div class="modal-capture-box" id="modalCaptureBox1">
                    <div class="mic-icon">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2C10.9 2 10 2.9 10 4V12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12V4C14 2.9 13.1 2 12 2Z"/>
                            <path d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"/>
                        </svg>
                    </div>
                    <canvas id="modalCaptureCanvas1" width="100" height="80"></canvas>
                </div>
                <div class="modal-capture-box" id="modalCaptureBox2">
                    <div class="mic-icon">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2C10.9 2 10 2.9 10 4V12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12V4C14 2.9 13.1 2 12 2Z"/>
                            <path d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"/>
                        </svg>
                    </div>
                    <canvas id="modalCaptureCanvas2" width="100" height="80"></canvas>
                </div>
                <div class="modal-capture-box" id="modalCaptureBox3">
                    <div class="mic-icon">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2C10.9 2 10 2.9 10 4V12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12V4C14 2.9 13.1 2 12 2Z"/>
                            <path d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"/>
                        </svg>
                    </div>
                    <canvas id="modalCaptureCanvas3" width="100" height="80"></canvas>
                </div>
                <div class="modal-capture-box" id="modalCaptureBox4">
                    <div class="mic-icon">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2C10.9 2 10 2.9 10 4V12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12V4C14 2.9 13.1 2 12 2Z"/>
                            <path d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"/>
                        </svg>
                    </div>
                    <canvas id="modalCaptureCanvas4" width="100" height="80"></canvas>
                </div>
            </div>

            <!-- Status Message -->
            <div id="modalStatus" class="modal-status">Click letter to hear sound, then start saying it!</div>

            <!-- Next Button (shown after calibration complete) -->
            <div id="modalNextButton" class="modal-next-button" onclick="goToNextLetter()">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"/>
                </svg>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="tabs">
            <button class="tab active" onclick="switchTab('calibrate')">üìä Calibrate</button>
            <button class="tab" onclick="switchTab('tuner')">üéØ Tuner</button>
            <button class="tab" onclick="switchTab('game')">üéÆ Game</button>
            <button class="tab" onclick="switchTab('game3')">üéÆ Game 3</button>
            <button class="tab" onclick="switchTab('game4')">üéÆ Game 4</button>
        </div>

        <!-- Calibration Tab -->
        <div id="calibrate" class="tab-content active">
            <div class="info-box">
                <strong>Pattern-Based Calibration</strong><br>
                Say each phoneme 3-4 times while recording. The system captures the actual waveform pattern (like a fingerprint).<br>
                This preserves the SHAPE of the sound, not just statistics.
            </div>

            <div class="calibration-grid" id="calibrationGrid"></div>

            <div class="actions">
                <button class="btn" onclick="resetCalibration()">üîÑ Reset All</button>
                <button class="btn" onclick="exportCalibration()">üíæ Export Calibration</button>
            </div>

            <div id="calibrationStats" style="margin-top: 20px; text-align: center; color: #aaa;"></div>
        </div>

        <!-- Tuner Tab (Elimination Game) -->
        <div id="tuner" class="tab-content">
            <div style="text-align: center; margin-bottom: 20px; color: #ddd; font-size: 18px;">
                Say this sound:
                <span onclick="playCalibrationRecording()" style="cursor: pointer; font-size: 24px; margin-left: 10px; display: inline-block; opacity: 0.7; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'" title="Play my recording">üîä</span>
            </div>

            <div style="text-align: center; margin-bottom: 15px;">
                <label style="color: #ddd; cursor: pointer;">
                    <input type="checkbox" id="alphabetMode" onchange="toggleAlphabetMode()" style="margin-right: 5px;">
                    Alphabet Test Mode (A‚ÜíZ loop)
                </label>
                <span id="alphabetProgress" style="margin-left: 15px; color: #FDD835; display: none;"></span>
            </div>

            <div id="targetLetter" style="text-align: center; font-size: 180px; font-weight: bold; color: #FDD835; margin: 20px 0; text-shadow: 0 10px 30px rgba(253, 216, 53, 0.5); transition: all 0.3s;">?</div>

            <div class="confidence-bar">
                <div class="confidence-fill" id="confidenceFill"></div>
            </div>

            <div class="stats">
                <div class="stat-item">
                    <div>Match Score</div>
                    <div class="stat-value" id="matchScore">0%</div>
                </div>
                <div class="stat-item">
                    <div>Volume</div>
                    <div class="stat-value" id="volume">0%</div>
                </div>
            </div>

            <canvas id="spectrumCanvas"></canvas>

            <div id="status" style="font-family: monospace; font-size: 11px; white-space: pre-wrap; line-height: 1.4;">Click Start to begin</div>

            <div class="actions">
                <button class="btn" id="tunerBtn" onclick="toggleTuner()">‚ñ∂ Start Game</button>
                <button class="btn" onclick="tryAgain()" style="background: #7CB342; display: none;" id="tryAgainBtn">üîÑ Try Again</button>
                <button class="btn" onclick="skipLetter()" style="background: #999;">Skip</button>
            </div>

            <div class="actions" style="margin-top: 15px;">
                <button class="btn" onclick="viewStats()" style="background: #5E35B1;">üìä View Stats (<span id="trialsCount">0</span> trials)</button>
                <button class="btn" onclick="exportResults()" style="background: #00897B;">üíæ Export Results</button>
            </div>
        </div>

        <!-- Game Tab (EXACT COPY OF TUNER) -->
        <div id="game" class="tab-content">
            <div class="actions" style="margin-bottom: 20px;">
                <button class="btn" id="tunerBtnGame" onclick="toggleTunerGame()">‚ñ∂ Start Game</button>
                <button class="btn" onclick="skipLetterGame()" style="background: #999;">Skip</button>
            </div>

            <div style="text-align: center; margin-bottom: 20px; color: #ddd; font-size: 18px;">
                Say this sound:
                <span onclick="playCalibrationRecording()" style="cursor: pointer; font-size: 24px; margin-left: 10px; display: inline-block; opacity: 0.7; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'" title="Play my recording">üîä</span>
            </div>

            <div style="text-align: center; margin-bottom: 15px;">
                <label style="color: #ddd; cursor: pointer;">
                    <input type="checkbox" id="alphabetModeGame" onchange="toggleAlphabetMode()" style="margin-right: 5px;">
                    Alphabet Test Mode (A‚ÜíZ loop)
                </label>
                <span id="alphabetProgressGame" style="margin-left: 15px; color: #FDD835; display: none;"></span>
            </div>

            <!-- Game Canvas/Screen -->
            <div style="position: relative; width: 600px; height: 400px; margin: 20px auto; background: rgba(0, 0, 0, 0.5); border-radius: 20px; border: 3px solid rgba(253, 216, 53, 0.3); overflow: hidden;">
                <!-- Level indicator -->
                <div id="gameLevelIndicator" style="position: absolute; top: 20px; left: 20px; font-size: 24px; font-weight: bold; color: #FDD835; text-shadow: 0 2px 10px rgba(253, 216, 53, 0.5); z-index: 10;">Level 1</div>

                <canvas id="gameCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></canvas>
                <div id="targetLetterGame" style="position: absolute; top: -50%; left: 50%; transform: translateX(-50%); font-size: 180px; font-weight: bold; color: #FDD835; text-shadow: 0 10px 30px rgba(253, 216, 53, 0.5);">?</div>
            </div>

            <div class="confidence-bar">
                <div class="confidence-fill" id="confidenceFillGame"></div>
            </div>

            <div class="stats">
                <div class="stat-item">
                    <div>Match Score</div>
                    <div class="stat-value" id="matchScoreGame">0%</div>
                </div>
                <div class="stat-item">
                    <div>Volume</div>
                    <div class="stat-value" id="volumeGame">0%</div>
                </div>
            </div>

            <canvas id="spectrumCanvasGame"></canvas>

            <div id="statusGame" style="font-family: monospace; font-size: 11px; white-space: pre-wrap; line-height: 1.4;">Click Start to begin</div>
        </div>

        <!-- Game 3 Tab (COPY OF GAME 2 FOR NEW FEATURES) -->
        <div id="game3" class="tab-content">
            <div class="actions" style="margin-bottom: 20px;">
                <button class="btn" id="tunerBtnGame3" onclick="toggleTunerGame3()">‚ñ∂ Start Game</button>
                <button class="btn" onclick="openGame3Settings()" style="background: #666;">‚öôÔ∏è Settings</button>
            </div>

            <div style="text-align: center; margin-bottom: 20px; color: #ddd; font-size: 18px;">
                Say this sound:
                <span onclick="playCalibrationRecording()" style="cursor: pointer; font-size: 24px; margin-left: 10px; display: inline-block; opacity: 0.7; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'" title="Play my recording">üîä</span>
            </div>

            <!-- Game Canvas/Screen -->
            <div style="position: relative; width: 600px; height: 600px; margin: 20px auto; background: rgba(0, 0, 0, 0.5); border-radius: 20px; border: 3px solid rgba(253, 216, 53, 0.3); overflow: hidden;">
                <!-- Level indicator -->
                <div id="gameLevelIndicator3" style="position: absolute; top: 20px; left: 20px; font-size: 24px; font-weight: bold; color: #FDD835; text-shadow: 0 2px 10px rgba(253, 216, 53, 0.5); z-index: 10;">Level 1</div>

                <!-- Success counter -->
                <div id="successCounter3" style="position: absolute; top: 60px; left: 20px; font-size: 48px; font-weight: bold; color: #4CAF50; text-shadow: 0 2px 10px rgba(76, 175, 80, 0.8); z-index: 10; display: none;">‚≠ê 0/10</div>

                <!-- Mic indicator -->
                <div id="micIndicator3" style="position: absolute; top: 20px; right: 20px; width: 60px; height: 60px; border-radius: 50%; background: #F44336; box-shadow: 0 0 20px rgba(244, 67, 54, 0.8); z-index: 10; display: flex; align-items: center; justify-content: center; font-size: 30px; transition: all 0.3s;">üé§</div>

                <canvas id="gameCanvas3" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></canvas>
                <div id="targetLetterGame3" style="position: absolute; top: -50%; left: 50%; transform: translateX(-50%); font-size: 180px; font-weight: bold; color: #FDD835; text-shadow: 0 10px 30px rgba(253, 216, 53, 0.5);">?</div>
            </div>

            <div class="confidence-bar">
                <div class="confidence-fill" id="confidenceFillGame3"></div>
            </div>

            <div class="stats">
                <div class="stat-item">
                    <div>Match Score</div>
                    <div class="stat-value" id="matchScoreGame3">0%</div>
                </div>
                <div class="stat-item">
                    <div>Volume</div>
                    <div class="stat-value" id="volumeGame3">0%</div>
                </div>
            </div>

            <canvas id="spectrumCanvasGame3"></canvas>

            <div id="statusGame3" style="font-family: monospace; font-size: 11px; white-space: pre-wrap; line-height: 1.4;">Click Start to begin</div>
        </div>

        <!-- Game 4 Tab (COPY OF GAME 3 FOR NEW FEATURES) -->
        <div id="game4" class="tab-content">
            <div class="actions" style="margin-bottom: 20px;">
                <button class="btn" id="tunerBtnGame4" onclick="toggleTunerGame4()">‚ñ∂ Start Game</button>
                <button class="btn" onclick="openGame4Settings()" style="background: #666;">‚öôÔ∏è Settings</button>
            </div>

            <div style="text-align: center; margin-bottom: 20px; color: #ddd; font-size: 18px;">
                Say this sound:
                <span onclick="playCalibrationRecording()" style="cursor: pointer; font-size: 24px; margin-left: 10px; display: inline-block; opacity: 0.7; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'" title="Play my recording">üîä</span>
            </div>

            <!-- Game Canvas/Screen -->
            <div style="position: relative; width: 600px; height: 600px; margin: 20px auto; background: rgba(0, 0, 0, 0.5); border-radius: 20px; border: 3px solid rgba(253, 216, 53, 0.3); overflow: hidden;">
                <!-- Level indicator -->
                <div id="gameLevelIndicator4" style="position: absolute; top: 20px; left: 20px; font-size: 24px; font-weight: bold; color: #FDD835; text-shadow: 0 2px 10px rgba(253, 216, 53, 0.5); z-index: 10;">Level 1</div>

                <!-- Success counter -->
                <div id="successCounter4" style="position: absolute; top: 60px; left: 20px; font-size: 48px; font-weight: bold; color: #4CAF50; text-shadow: 0 2px 10px rgba(76, 175, 80, 0.8); z-index: 10; display: none;">‚≠ê 0/10</div>

                <!-- Mic indicator -->
                <div id="micIndicator4" style="position: absolute; top: 20px; right: 20px; width: 60px; height: 60px; border-radius: 50%; background: #F44336; box-shadow: 0 0 20px rgba(244, 67, 54, 0.8); z-index: 10; display: flex; align-items: center; justify-content: center; font-size: 30px; transition: all 0.3s;">üé§</div>

                <canvas id="gameCanvas4" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></canvas>
                <div id="targetLetterGame4" style="position: absolute; top: -50%; left: 50%; transform: translateX(-50%); font-size: 180px; font-weight: bold; color: #FDD835; text-shadow: 0 10px 30px rgba(253, 216, 53, 0.5);">?</div>
            </div>

            <div class="confidence-bar">
                <div class="confidence-fill" id="confidenceFillGame4"></div>
            </div>

            <div class="stats">
                <div class="stat-item">
                    <div>Match Score</div>
                    <div class="stat-value" id="matchScoreGame4">0%</div>
                </div>
                <div class="stat-item">
                    <div>Volume</div>
                    <div class="stat-value" id="volumeGame4">0%</div>
                </div>
            </div>

            <canvas id="spectrumCanvasGame4"></canvas>

            <div id="statusGame4" style="font-family: monospace; font-size: 11px; white-space: pre-wrap; line-height: 1.4;">Click Start to begin</div>
        </div>
    </div>

    <!-- Game 3 Instruction Popup -->
    <div id="game3InstructionModal" class="instruction-modal">
        <div class="instruction-modal-content">
            <h2 style="color: #FDD835; font-size: 48px; margin-bottom: 20px; text-align: center;">üéÆ Level 1</h2>
            <p style="color: #ddd; font-size: 24px; text-align: center; line-height: 1.6; margin-bottom: 20px;">
                Listen to the letter sound, then speak the sound to pop the letter. Click the yellow button to start!
            </p>

            <!-- Demo Animation Container -->
            <div class="demo-container">
                <div id="demoLetter" class="demo-letter">A</div>
            </div>

            <button class="instruction-start-btn" onclick="startGame3FromInstructions()">
                üöÄ Start Game
            </button>
        </div>
    </div>

    <!-- Game 3 Level Complete Popup -->
    <div id="game3LevelCompleteModal" class="instruction-modal celebration">
        <div class="instruction-modal-content celebration">
            <div class="confetti-container" id="celebrationConfetti"></div>
            <h2 style="color: #FDD835; font-size: 64px; margin-bottom: 20px; text-align: center;">üåü AMAZING!! üåü</h2>
            <p style="color: #ddd; font-size: 32px; text-align: center; line-height: 1.6; margin-bottom: 20px; font-weight: bold;">
                You've learned your first letter!
            </p>
            <p style="color: #4CAF50; font-size: 36px; text-align: center; margin-bottom: 20px;">
                Now let's learn the next letter.
            </p>

            <!-- Demo Animation Container showing next letter -->
            <div class="demo-container">
                <div class="demo-letter">B</div>
            </div>

            <button class="instruction-start-btn celebration" onclick="closeLevel1Complete()">
                ‚ú® Continue
            </button>
        </div>
    </div>

    <!-- Game 4 Instruction Popup -->
    <div id="game4InstructionModal" class="instruction-modal">
        <div class="instruction-modal-content">
            <h2 style="color: #FDD835; font-size: 48px; margin-bottom: 20px; text-align: center;">üéÆ Level 1</h2>
            <p style="color: #ddd; font-size: 24px; text-align: center; line-height: 1.6; margin-bottom: 20px;">
                Listen to the letter sound, then speak the sound to pop the letter. Click the yellow button to start!
            </p>

            <!-- Demo Animation Container -->
            <div class="demo-container">
                <div id="demoLetter4" class="demo-letter">A</div>
            </div>

            <button class="instruction-start-btn" onclick="startGame4FromInstructions()">
                üöÄ Start Game
            </button>
        </div>
    </div>

    <!-- Game 4 Level Complete Popup -->
    <div id="game4LevelCompleteModal" class="instruction-modal celebration">
        <div class="instruction-modal-content celebration">
            <div class="confetti-container" id="celebrationConfetti4"></div>
            <h2 style="color: #FDD835; font-size: 64px; margin-bottom: 20px; text-align: center;">üåü AMAZING!! üåü</h2>
            <p style="color: #ddd; font-size: 32px; text-align: center; line-height: 1.6; margin-bottom: 20px; font-weight: bold;">
                You've learned your first letter!
            </p>
            <p style="color: #4CAF50; font-size: 36px; text-align: center; margin-bottom: 30px;">
                Now let's learn the next letter.
            </p>
            <button class="instruction-start-btn celebration" onclick="closeGame4LevelComplete()">
                ‚ú® Continue
            </button>
        </div>
    </div>

    <script>
        let audioContext;
        let analyser;
        let microphone;
        let mediaRecorder;
        let audioChunks = [];
        let dataArray;
        let isRunning = false;
        let isRecording = false;
        let recordingPhoneme = null;
        let recordedPatterns = [];
        let calibrationData = {};
        let audioRecordings = {};
        let letterSensitivity = {}; // Sensitivity multiplier for each letter (0.5 - 1.5)

        const canvas = document.getElementById('spectrumCanvas');
        const canvasCtx = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = 240;

        const PHONEMES = [
            // ===== VOWELS =====
            { letter: 'A', hint: 'Say: aaa (like "apple")', type: 'vowel', group: 'vowels', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-a.mp3' },
            { letter: 'E', hint: 'Say: eee (like "egg")', type: 'vowel', group: 'vowels', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-e.mp3' },
            { letter: 'I', hint: 'Say: iii (like "igloo")', type: 'vowel', group: 'vowels', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-i.mp3' },
            { letter: 'O', hint: 'Say: ooo (like "octopus")', type: 'vowel', group: 'vowels', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-o-sh.mp3' },
            { letter: 'U', hint: 'Say: uuu (like "umbrella")', type: 'vowel', group: 'vowels', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-u-sh.mp3' },

            // ===== EASY CONSONANTS =====
            { letter: 'M', hint: 'Say: mmm (hum)', type: 'nasal', group: 'easy', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-m.mp3' },
            { letter: 'S', hint: 'Say: sss (like "snake")', type: 'fricative', group: 'easy', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-z.mp3' },
            { letter: 'T', hint: 'Repeat: tuh, tuh', type: 'plosive', group: 'easy', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-t.mp3' },
            { letter: 'B', hint: 'Repeat: buh, buh', type: 'plosive', group: 'easy', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-b.mp3' },
            { letter: 'F', hint: 'Say: fff (like "fan")', type: 'fricative', group: 'easy', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-f.mp3' },
            { letter: 'N', hint: 'Say: nnn (like "no")', type: 'nasal', group: 'easy', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-n.mp3' },

            // ===== COMMON CONSONANTS =====
            { letter: 'P', hint: 'Repeat: puh, puh', type: 'plosive', group: 'common', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-p-2.mp3' },
            { letter: 'D', hint: 'Repeat: duh, duh (like "dog")', type: 'plosive', group: 'common', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-d.mp3' },
            { letter: 'L', hint: 'Say: lll (like "lion")', type: 'liquid', group: 'common', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-l.mp3' },
            { letter: 'R', hint: 'Say: rrr (like "run")', type: 'liquid', group: 'common', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-r.mp3' },
            { letter: 'C', hint: 'Repeat: cuh, cuh (like "cat")', type: 'plosive', group: 'common', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-c.mp3' },
            { letter: 'G', hint: 'Repeat: guh, guh (like "go")', type: 'plosive', group: 'common', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-g.mp3' },
            { letter: 'H', hint: 'Say: hhh (like "hat")', type: 'fricative', group: 'common', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-h.mp3' },

            // ===== ADVANCED =====
            { letter: 'W', hint: 'Say: www (like "water")', type: 'semivowel', group: 'advanced', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-w.mp3' },
            { letter: 'Y', hint: 'Say: yuh (like "yes")', type: 'semivowel', group: 'advanced', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/btalpha-i-long.mp3' },
            { letter: 'J', hint: 'Say: juh (like "jump")', type: 'affricate', group: 'advanced', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-j.mp3' },
            { letter: 'K', hint: 'Repeat: kuh, kuh', type: 'plosive', group: 'advanced', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-k.mp3' },
            { letter: 'V', hint: 'Say: vvv (like "van")', type: 'fricative', group: 'advanced', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-v.mp3' },
            { letter: 'Z', hint: 'Say: zzz (like "zoo")', type: 'fricative', group: 'advanced', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-z.mp3' },
            { letter: 'X', hint: 'Say: ks (like "fox")', type: 'affricate', group: 'advanced', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-x.mp3' },
            { letter: 'Q', hint: 'Say: kwuh (like "queen")', type: 'affricate', group: 'advanced', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-q.mp3' }
        ];

        // ======================
        // Supabase Helper Functions
        // ======================

        let currentProfileId = null; // Store the current profile's UUID

        async function getOrCreateProfile(profileName) {
            try {
                // Try to find existing profile by name (get the most recent one if multiple exist)
                const { data: existingProfiles, error: fetchError } = await supabase
                    .from('profiles')
                    .select('*')
                    .eq('name', profileName)
                    .is('user_id', null) // Only get anonymous profiles
                    .order('created_at', { ascending: false })
                    .limit(1);

                if (fetchError) throw fetchError;

                if (existingProfiles && existingProfiles.length > 0) {
                    console.log(`‚úÖ Found existing profile: ${profileName} (${existingProfiles[0].id.substring(0, 8)}...)`);
                    return existingProfiles[0];
                }

                // Create new profile if not found
                const { data: newProfile, error: createError } = await supabase
                    .from('profiles')
                    .insert([{ name: profileName }])
                    .select()
                    .single();

                if (createError) throw createError;

                console.log(`‚úÖ Created new profile: ${profileName} (${newProfile.id.substring(0, 8)}...)`);
                return newProfile;
            } catch (error) {
                console.error('‚ùå Error with profile:', error);
                return null;
            }
        }

        async function saveCalibrationToSupabase(letter, patternData, audioBlob) {
            if (!currentProfileId) {
                console.error('‚ùå No profile selected');
                return false;
            }

            try {
                const startTime = Date.now();
                let audioUrl = null;

                // Upload audio to Supabase Storage if provided
                if (audioBlob) {
                    const blobSizeKB = (audioBlob.size / 1024).toFixed(2);
                    console.log(`üì§ Uploading audio: ${blobSizeKB} KB`);

                    const audioFileName = `${currentProfileId}/${letter}_${Date.now()}.webm`;

                    const uploadStart = Date.now();
                    const { data: uploadData, error: uploadError } = await supabase.storage
                        .from('calibration-audio')
                        .upload(audioFileName, audioBlob, {
                            contentType: 'audio/webm'
                        });
                    const uploadTime = Date.now() - uploadStart;
                    console.log(`‚è±Ô∏è Upload took: ${uploadTime}ms`);

                    if (uploadError) {
                        console.error('‚ùå Audio upload error:', uploadError);
                        // Continue without audio if upload fails
                    } else {
                        // Get public URL
                        const { data: { publicUrl } } = supabase.storage
                            .from('calibration-audio')
                            .getPublicUrl(audioFileName);
                        audioUrl = publicUrl;
                        console.log('‚úÖ Audio uploaded:', audioUrl);
                    }
                }

                // Save calibration data to database
                console.log('üíæ Saving to database...');
                const dbStart = Date.now();
                const { data, error } = await supabase
                    .from('calibrations')
                    .upsert({
                        profile_id: currentProfileId,
                        letter: letter,
                        pattern_data: patternData,
                        audio_url: audioUrl,
                        updated_at: new Date().toISOString()
                    }, {
                        onConflict: 'profile_id,letter'
                    })
                    .select();
                const dbTime = Date.now() - dbStart;
                console.log(`‚è±Ô∏è Database save took: ${dbTime}ms`);

                if (error) throw error;

                const totalTime = Date.now() - startTime;
                console.log(`‚úÖ Saved calibration for letter ${letter} (total: ${totalTime}ms)`);
                return audioUrl; // Return the audio URL so it can be stored locally
            } catch (error) {
                console.error('‚ùå Error saving calibration:', error);
                alert(`Failed to save calibration: ${error.message}`);
                return null;
            }
        }

        async function loadCalibrationsFromSupabase() {
            if (!currentProfileId) {
                console.error('‚ùå No profile selected');
                return {};
            }

            try {
                const { data, error } = await supabase
                    .from('calibrations')
                    .select('*')
                    .eq('profile_id', currentProfileId);

                if (error) throw error;

                // Convert to the format expected by the app
                const calibrations = {};
                data.forEach(cal => {
                    calibrations[cal.letter] = {
                        pattern: cal.pattern_data.pattern || [cal.pattern_data],
                        timestamp: new Date(cal.created_at).getTime(),
                        audioUrl: cal.audio_url
                    };
                });

                console.log(`‚úÖ Loaded ${Object.keys(calibrations).length} calibrations from Supabase`);
                return calibrations;
            } catch (error) {
                console.error('‚ùå Error loading calibrations:', error);
                return {};
            }
        }

        const PLOSIVES = ['B', 'C', 'D', 'G', 'K', 'P', 'T'];
        const NASALS = ['M', 'N'];

        function isPlosive(letter) {
            return PLOSIVES.includes(letter);
        }

        function isNasal(letter) {
            return NASALS.includes(letter);
        }

        // Pattern matching parameters
        const PATTERN_LENGTH = 30; // Number of frequency snapshots
        const PATTERN_BINS = 64;   // Number of frequency bins per snapshot

        // Profile management
        let currentProfile = 'Default';

        function loadProfiles() {
            const saved = localStorage.getItem('phonicsProfiles');
            const profiles = saved ? JSON.parse(saved) : ['Default'];

            const select = document.getElementById('profileSelect');
            select.innerHTML = '';

            profiles.forEach(profile => {
                const option = document.createElement('option');
                option.value = profile;
                option.textContent = profile;
                if (profile === currentProfile) {
                    option.selected = true;
                }
                select.appendChild(option);
            });

            return profiles;
        }

        function saveProfiles(profiles) {
            localStorage.setItem('phonicsProfiles', JSON.stringify(profiles));
        }

        async function switchProfile() {
            const select = document.getElementById('profileSelect');
            currentProfile = select.value;
            localStorage.setItem('currentProfile', currentProfile);

            // Clear guest profile ID since we're using a named profile
            localStorage.removeItem('guestProfileId');
            guestProfileId = null;

            // Get or create profile in Supabase by name
            const profile = await getOrCreateProfile(currentProfile);
            if (profile) {
                currentProfileId = profile.id;
                console.log(`‚úÖ Switched to profile: ${currentProfile} (${profile.id.substring(0, 8)}...)`);
            }

            // Load calibration for this profile
            await loadCalibration();
            createCalibrationGrid();
            updateCalibrationStats();
        }

        async function createNewProfile() {
            const name = prompt('Enter profile name (e.g., "Ophelia", "Rey", "Marc"):');
            if (!name || name.trim() === '') return;

            const profiles = loadProfiles();
            if (profiles.includes(name.trim())) {
                alert('Profile already exists!');
                return;
            }

            profiles.push(name.trim());
            saveProfiles(profiles);
            currentProfile = name.trim();
            localStorage.setItem('currentProfile', currentProfile);

            // Clear guest profile ID
            localStorage.removeItem('guestProfileId');
            guestProfileId = null;

            // Create profile in Supabase
            const profile = await getOrCreateProfile(currentProfile);
            if (profile) {
                currentProfileId = profile.id;
                console.log(`‚úÖ Created new profile: ${currentProfile} (${profile.id.substring(0, 8)}...)`);
            }

            // Clear calibration for new profile
            calibrationData = {};

            loadProfiles();
            await loadCalibration();
            createCalibrationGrid();
            updateCalibrationStats();
        }

        async function loadCalibration() {
            // Load ONLY from Supabase (no localStorage fallback)
            if (currentProfileId) {
                const supabaseData = await loadCalibrationsFromSupabase();
                calibrationData = supabaseData;
                updateCalibrationUI();

                // Also load level progress from Supabase
                await loadProgressFromSupabase();
            } else{
                calibrationData = {};
                console.warn('‚ö†Ô∏è No profile ID - waiting for Supabase profile initialization');
            }

            // Load letter sensitivity settings from localStorage
            const savedSensitivity = localStorage.getItem(`letterSensitivity_${currentProfile}`);
            if (savedSensitivity) {
                letterSensitivity = JSON.parse(savedSensitivity);
            } else {
                // Initialize default sensitivity (1.0 = 100%) for all letters
                letterSensitivity = {};
                PHONEMES.forEach(p => {
                    letterSensitivity[p.letter] = 1.0;
                });
            }
        }

        function createCalibrationGrid() {
            const grid = document.getElementById('calibrationGrid');
            grid.innerHTML = '';

            const groupLabels = {
                'vowels': 'Vowels',
                'easy': 'Easy Consonants',
                'common': 'Common Consonants',
                'advanced': 'Advanced'
            };

            let currentGroup = null;

            PHONEMES.forEach(phoneme => {
                if (phoneme.group !== currentGroup) {
                    currentGroup = phoneme.group;
                    const header = document.createElement('div');
                    header.className = 'calibration-group-header';
                    header.textContent = groupLabels[currentGroup];
                    grid.appendChild(header);
                }

                const card = document.createElement('div');
                card.className = 'phoneme-card';
                card.id = `card-${phoneme.letter}`;

                const isCalibrated = calibrationData[phoneme.letter];
                if (isCalibrated) {
                    card.classList.add('calibrated');
                }

                const sensitivity = letterSensitivity[phoneme.letter] || 1.0;
                // Invert for display: high sensitivity (1.5) = low slider (50) = "Easy"
                const sliderValue = Math.round(200 - (sensitivity * 100));
                const label = sliderValue <= 70 ? 'Easy' : sliderValue >= 130 ? 'Strict' : 'Normal';
                const sensitivityPercent = Math.round(sensitivity * 100);

                card.innerHTML = `
                    <div class="phoneme-letter">${phoneme.letter}</div>
                    <div class="phoneme-hint">${phoneme.hint}</div>
                    ${phoneme.audioUrl ? `<div style="font-size: 30px; cursor: pointer; margin: 5px 0;" onclick="event.stopPropagation(); playPhonemeSound('${phoneme.letter}')" title="Listen to sound">üîä</div>` : ''}
                    <div class="snapshots-container" id="snapshots-${phoneme.letter}"></div>
                    <div class="phoneme-status">${isCalibrated ? '‚úì Calibrated' : 'Click to record'}</div>
                    <div class="sensitivity-control" id="sensitivity-${phoneme.letter}" style="margin-top: 10px; display: none;">
                        <div style="color: #aaa; font-size: 11px; margin-bottom: 8px; display: flex; justify-content: space-between;">
                            <span style="color: #7CB342;">Easy</span>
                            <span id="sens-value-${phoneme.letter}" style="color: #FDD835; font-weight: bold;">${label} (${sensitivityPercent}%)</span>
                            <span style="color: #F44336;">Strict</span>
                        </div>
                        <input type="range" min="50" max="150" value="${sliderValue}"
                               style="width: 100%;"
                               oninput="updateSensitivity('${phoneme.letter}', this.value)"
                               onclick="event.stopPropagation()">
                    </div>
                    <button class="settings-btn" onclick="event.stopPropagation(); toggleSensitivitySlider('${phoneme.letter}')"
                            style="margin-top: 8px; background: #666; color: white; border: none; border-radius: 5px; padding: 5px 10px; cursor: pointer; font-size: 12px;">
                        ‚öôÔ∏è Settings
                    </button>
                `;

                card.onclick = () => openCalibrationModal(phoneme.letter);
                grid.appendChild(card);
            });
        }

        function toggleSensitivitySlider(letter) {
            const slider = document.getElementById(`sensitivity-${letter}`);
            if (slider) {
                slider.style.display = slider.style.display === 'none' ? 'block' : 'none';
            }
        }

        function updateSensitivity(letter, sliderValue) {
            // Invert: slider 50 = sensitivity 1.5 (Easy), slider 150 = sensitivity 0.5 (Strict)
            const sensitivity = (200 - parseInt(sliderValue)) / 100;
            letterSensitivity[letter] = sensitivity;

            // Update display label with percentage
            const valueDisplay = document.getElementById(`sens-value-${letter}`);
            if (valueDisplay) {
                const label = sliderValue <= 70 ? 'Easy' : sliderValue >= 130 ? 'Strict' : 'Normal';
                const sensitivityPercent = Math.round(sensitivity * 100);
                valueDisplay.textContent = `${label} (${sensitivityPercent}%)`;
            }

            // Save to localStorage
            localStorage.setItem(`letterSensitivity_${currentProfile}`, JSON.stringify(letterSensitivity));

            console.log(`‚úÖ Updated ${letter}: slider=${sliderValue}, sensitivity=${sensitivity.toFixed(2)}x (${Math.round(sensitivity * 100)}%), label=${sliderValue <= 70 ? 'Easy' : sliderValue >= 130 ? 'Strict' : 'Normal'}`);
        }

        let capturedSnapshots = [];
        let lastPeakTime = 0;
        const SNAPSHOTS_NEEDED = 5;
        const PEAK_COOLDOWN = 500; // ms between peaks

        async function startCalibrationRecording(letter) {
            if (isRecording) return;

            if (!audioContext) {
                await setupAudio();
            }

            isRecording = true;
            recordingPhoneme = letter;
            capturedSnapshots = [];
            audioChunks = [];
            lastPeakTime = 0;

            // DISABLED: Audio recording takes too much localStorage space
            // if (microphone && microphone.stream) {
            //     mediaRecorder = new MediaRecorder(microphone.stream);
            //     mediaRecorder.ondataavailable = (event) => {
            //         if (event.data.size > 0) {
            //             audioChunks.push(event.data);
            //         }
            //     };
            //     mediaRecorder.start();
            // }

            const card = document.getElementById(`card-${letter}`);
            card.classList.add('recording');
            card.querySelector('.phoneme-status').textContent = `Say "${letter}" - 0/${SNAPSHOTS_NEEDED} captured`;

            // Create snapshot thumbnail canvases
            const snapshotsContainer = document.getElementById(`snapshots-${letter}`);
            snapshotsContainer.innerHTML = '';
            for (let i = 0; i < SNAPSHOTS_NEEDED; i++) {
                const canvas = document.createElement('canvas');
                canvas.className = 'snapshot-thumb';
                canvas.width = 50;
                canvas.height = 40;
                canvas.id = `snapshot-${letter}-${i}`;
                snapshotsContainer.appendChild(canvas);
            }

            // Start listening for peaks
            listenForPeaks(letter);
        }

        function listenForPeaks(letter) {
            if (!isRecording || recordingPhoneme !== letter) {
                if (!isRecording) console.log('Stopped listening: isRecording = false');
                if (recordingPhoneme !== letter) console.log(`Stopped listening: letter mismatch (${recordingPhoneme} vs ${letter})`);
                return;
            }

            analyser.getByteFrequencyData(dataArray);

            // Calculate current volume
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volume = (sum / dataArray.length / 128) * 100;

            // SOLUTION 1: Dynamic volume threshold for nasals
            const volumeThreshold = isNasal(letter) ? 8 : 15;

            // Detect peak (loud moment after cooldown)
            const now = Date.now();
            if (volume > volumeThreshold && (now - lastPeakTime) > PEAK_COOLDOWN) {
                // SNAP! Capture this peak moment
                let snapshot = downsampleFrequencies(dataArray, PATTERN_BINS);

                // SOLUTION 5: Check energy concentration for nasals
                const peakEnergy = Math.max(...snapshot);
                const avgEnergy = snapshot.reduce((a, b) => a + b, 0) / snapshot.length;
                const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;
                const concentrationThreshold = isNasal(letter) ? 1.5 : 2.0;

                // Skip if energy too diffuse (likely background noise)
                if (energyConcentration < concentrationThreshold) {
                    requestAnimationFrame(() => listenForPeaks(letter));
                    return;
                }

                // SOLUTION 3: Pre-amplify nasal sounds before normalization
                if (isNasal(letter)) {
                    snapshot = snapshot.map(v => v * 2.0);
                }

                // Normalize to 0-1 range
                const maxVal = Math.max(...snapshot);
                const normalized = snapshot.map(v => v / maxVal);

                capturedSnapshots.push(normalized);
                const snapshotIndex = capturedSnapshots.length - 1;
                lastPeakTime = now;

                console.log(`Captured snapshot ${capturedSnapshots.length}/${SNAPSHOTS_NEEDED} for letter ${letter}`);

                const card = document.getElementById(`card-${letter}`);
                card.querySelector('.phoneme-status').textContent = `‚úì Captured ${capturedSnapshots.length}/${SNAPSHOTS_NEEDED}`;

                // Draw snapshot thumbnail
                drawSnapshotThumbnail(letter, snapshotIndex, normalized);

                // Visual feedback
                card.style.transform = 'scale(1.05)';
                setTimeout(() => card.style.transform = 'scale(1)', 200);

                // Check if done
                if (capturedSnapshots.length >= SNAPSHOTS_NEEDED) {
                    console.log(`All ${SNAPSHOTS_NEEDED} snapshots captured! Finishing calibration...`);
                    isRecording = false;
                    finishCalibration(letter);
                    return;
                }

                console.log(`Continuing to listen for more snapshots...`);
            }

            // Keep listening
            requestAnimationFrame(() => listenForPeaks(letter));
        }

        function drawSnapshotThumbnail(letter, index, snapshot) {
            const canvas = document.getElementById(`snapshot-${letter}-${index}`);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, width, height);

            // Draw spectrum bars
            const barWidth = width / snapshot.length;
            for (let i = 0; i < snapshot.length; i++) {
                const barHeight = snapshot[i] * height;
                const x = i * barWidth;
                const y = height - barHeight;

                // Green bars
                ctx.fillStyle = '#7CB342';
                ctx.fillRect(x, y, barWidth - 1, barHeight);
            }

            // Mark as captured
            canvas.classList.add('captured');
        }

        function downsampleFrequencies(fullData, targetBins) {
            // Reduce full frequency data to targetBins by averaging
            const pattern = [];
            const binSize = Math.floor(fullData.length / targetBins);

            for (let i = 0; i < targetBins; i++) {
                let sum = 0;
                const start = i * binSize;
                const end = Math.min(start + binSize, fullData.length);

                for (let j = start; j < end; j++) {
                    sum += fullData[j];
                }

                pattern.push(sum / binSize);
            }

            return pattern;
        }

        function finishCalibration(letter) {
            isRecording = false;

            // DISABLED: Audio recording takes too much localStorage space
            // if (mediaRecorder && mediaRecorder.state === 'recording') {
            //     mediaRecorder.stop();
            //     mediaRecorder.onstop = () => {
            //         const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            //         saveAudioRecording(letter, audioBlob);
            //     };
            // }

            if (capturedSnapshots.length < 3) {
                alert('Not enough snapshots captured. Try again.');
                const card = document.getElementById(`card-${letter}`);
                card.classList.remove('recording');
                card.querySelector('.phoneme-status').textContent = 'Click to record';
                recordingPhoneme = null;
                capturedSnapshots = [];
                audioChunks = [];
                return;
            }

            // CLUSTERING: Find the most similar snapshots
            const clusterResult = findBestCluster(capturedSnapshots);

            // AVERAGE the cluster to create baseline
            const baseline = averageSnapshots(clusterResult.cluster);

            // Store as "pattern" (but it's just 1 peak snapshot, wrapped in array for compatibility)
            calibrationData[letter] = {
                pattern: [baseline], // Wrap in array for compatibility with existing code
                timestamp: Date.now()
            };

            // NOTE: This old calibration path is legacy - modal calibration saves to Supabase
            // No localStorage saving here

            const card = document.getElementById(`card-${letter}`);
            card.classList.remove('recording');
            card.classList.add('calibrated');
            card.querySelector('.phoneme-status').textContent = '‚úì Calibrated';

            updateCalibrationStats();

            recordingPhoneme = null;
            capturedSnapshots = [];

            console.log(`Calibrated ${letter}: Used ${clusterResult.cluster.length}/${capturedSnapshots.length} snapshots`);
        }

        function findBestCluster(snapshots) {
            // Find the group of most similar snapshots (remove outliers)
            // Returns { cluster: [...snapshots], indices: [...indices] }
            if (snapshots.length <= 3) {
                return {
                    cluster: snapshots,
                    indices: snapshots.map((_, i) => i)
                };
            }

            // Calculate pairwise distances
            const distances = [];
            for (let i = 0; i < snapshots.length; i++) {
                for (let j = i + 1; j < snapshots.length; j++) {
                    const dist = calculateSnapshotDistance(snapshots[i], snapshots[j]);
                    distances.push({ i, j, dist });
                }
            }

            // Sort by distance (most similar first)
            distances.sort((a, b) => a.dist - b.dist);

            // Find the 3 snapshots that are most similar to each other
            // Strategy: Start with the most similar pair, add the closest 3rd
            const pair = distances[0]; // Most similar pair
            const candidates = [pair.i, pair.j];

            // Find closest snapshot to this pair
            let bestThird = null;
            let bestAvgDist = Infinity;

            for (let k = 0; k < snapshots.length; k++) {
                if (candidates.includes(k)) continue;

                const dist1 = calculateSnapshotDistance(snapshots[k], snapshots[candidates[0]]);
                const dist2 = calculateSnapshotDistance(snapshots[k], snapshots[candidates[1]]);
                const avgDist = (dist1 + dist2) / 2;

                if (avgDist < bestAvgDist) {
                    bestAvgDist = avgDist;
                    bestThird = k;
                }
            }

            candidates.push(bestThird);
            return {
                cluster: candidates.map(i => snapshots[i]),
                indices: candidates
            };
        }

        function calculateSnapshotDistance(snap1, snap2) {
            // Simple distance: sum of absolute differences
            let sum = 0;
            const len = Math.min(snap1.length, snap2.length);
            for (let i = 0; i < len; i++) {
                sum += Math.abs(snap1[i] - snap2[i]);
            }
            return sum / len;
        }

        function averageSnapshots(snapshots) {
            // Average all snapshots bin-by-bin
            const numBins = snapshots[0].length;
            const averaged = new Array(numBins).fill(0);

            for (const snapshot of snapshots) {
                for (let i = 0; i < numBins; i++) {
                    averaged[i] += snapshot[i];
                }
            }

            return averaged.map(v => v / snapshots.length);
        }

        function normalizePattern(pattern2D) {
            // Normalize each time slice to 0-1 range
            return pattern2D.map(slice => {
                const max = Math.max(...slice);
                if (max === 0) return slice;
                return slice.map(v => v / max);
            });
        }

        function updateCalibrationStats() {
            const calibrated = Object.keys(calibrationData).length;
            const total = PHONEMES.length;
            const statsEl = document.getElementById('calibrationStats');
            statsEl.textContent = `Calibrated: ${calibrated} / ${total} phonemes`;

            if (calibrated === total) {
                statsEl.innerHTML += '<br><strong style="color: #7CB342;">‚úì All phonemes calibrated! Switch to Tuner tab.</strong>';
            }
        }

        function updateCalibrationUI() {
            PHONEMES.forEach(phoneme => {
                if (calibrationData[phoneme.letter]) {
                    const card = document.getElementById(`card-${phoneme.letter}`);
                    if (card) {
                        card.classList.add('calibrated');
                        card.querySelector('.phoneme-status').textContent = '‚úì Calibrated';
                    }
                }
            });
            updateCalibrationStats();
        }

        function resetCalibration() {
            if (confirm(`Reset all calibration data for ${currentProfile}?`)) {
                calibrationData = {};
                const key = `phonicsPatterns_${currentProfile}`;
                localStorage.removeItem(key);
                createCalibrationGrid();
                updateCalibrationStats();
            }
        }

        function exportCalibration() {
            const dataStr = JSON.stringify(calibrationData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `phonics-patterns-${currentProfile}.json`;
            a.click();
        }

        // ========== CALIBRATION MODAL ==========

        let modalAnimationFrame = null;
        let modalWaveformCanvas = null;
        let modalWaveformCtx = null;
        let modalCurrentLetter = '';
        let modalCapturedSnapshots = [];
        let modalIsListening = false;
        let modalListeningForIndex = -1;
        let modalMediaRecorder = null;
        let modalAudioChunks = [];
        let modalAudioClips = []; // Individual audio clips per snapshot
        let modalCurrentRecordingIndex = -1;

        function openCalibrationModal(letter) {
            modalCurrentLetter = letter;
            modalCapturedSnapshots = [];
            modalAudioClips = []; // Reset audio clips array
            modalIsListening = false;
            modalListeningForIndex = -1;
            modalCurrentRecordingIndex = -1;

            // Set up modal UI
            document.getElementById('modalLetter').textContent = letter;
            document.getElementById('modalStatus').textContent = `Click box 1 to record first sound`;

            // Hide next button
            document.getElementById('modalNextButton').classList.remove('active');

            // Reset and setup capture boxes as CLICKABLE
            for (let i = 0; i < 5; i++) {
                const box = document.getElementById(`modalCaptureBox${i}`);
                box.classList.remove('captured', 'recording', 'ready');
                const canvas = document.getElementById(`modalCaptureCanvas${i}`);
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Make boxes clickable
                box.onclick = () => startCaptureForBox(i);

                // Mark first box as ready
                if (i === 0) {
                    box.classList.add('ready');
                    box.style.cursor = 'pointer';
                } else {
                    box.style.cursor = 'not-allowed';
                }
            }

            // Show the click arrow pointing at box 1
            document.getElementById('clickArrow').classList.add('active');

            // Setup audio if needed (no session-long recording, we'll record per snapshot)
            if (!audioContext) {
                setupAudio().then(() => {
                    document.getElementById('calibrationModal').classList.add('active');
                    startModalVisualization();
                });
            } else {
                document.getElementById('calibrationModal').classList.add('active');
                startModalVisualization();
            }
        }

        function closeCalibrationModal() {
            modalIsListening = false;
            if (modalAnimationFrame) {
                cancelAnimationFrame(modalAnimationFrame);
                modalAnimationFrame = null;
            }
            // Stop audio recording if still active
            if (modalMediaRecorder && modalMediaRecorder.state === 'recording') {
                modalMediaRecorder.stop();
            }
            document.getElementById('clickArrow').classList.remove('active');
            document.getElementById('modalNextButton').classList.remove('active');
            document.getElementById('calibrationModal').classList.remove('active');
        }

        function playModalLetterSound() {
            playPhonemeSound(modalCurrentLetter);
        }

        function startCaptureForBox(index) {
            // Only allow capturing the next uncaptured box
            if (index !== modalCapturedSnapshots.length) {
                return;
            }

            // Already listening
            if (modalIsListening) return;

            // Hide the arrow once user starts interacting
            document.getElementById('clickArrow').classList.remove('active');

            // DON'T start listening yet - wait for delay first!
            modalListeningForIndex = index;
            modalCurrentRecordingIndex = index;

            const box = document.getElementById(`modalCaptureBox${index}`);
            box.classList.remove('ready');
            box.classList.add('recording');
            box.style.cursor = 'wait';

            document.getElementById('modalStatus').textContent = `Recording ${index + 1}/5... Get ready...`;

            // Wait 400ms to avoid click sound, THEN start listening AND recording
            setTimeout(() => {
                modalIsListening = true; // NOW we start listening!
                document.getElementById('modalStatus').textContent = `Recording ${index + 1}/5... Say "${modalCurrentLetter}" NOW!`;

                // Start individual audio recording for this snapshot
                modalAudioChunks = [];
                if (microphone && microphone.stream) {
                    modalMediaRecorder = new MediaRecorder(microphone.stream);
                    modalMediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            modalAudioChunks.push(event.data);
                        }
                    };
                    modalMediaRecorder.start();
                    console.log(`üéôÔ∏è Started recording clip ${index + 1}/5`);
                }
            }, 400);
        }

        function startModalVisualization() {
            let lastPeakTime = 0;
            const PEAK_COOLDOWN = 500;

            function visualize() {
                if (!document.getElementById('calibrationModal').classList.contains('active')) {
                    return;
                }

                modalAnimationFrame = requestAnimationFrame(visualize);

                if (!analyser || !dataArray) return;

                analyser.getByteFrequencyData(dataArray);

                // Draw waveform in modal
                drawModalWaveform();

                // Listen for peak if actively recording
                if (modalIsListening && modalListeningForIndex >= 0) {
                    // Calculate current volume
                    let sum = 0;
                    for (let i = 0; i < dataArray.length; i++) {
                        sum += dataArray[i];
                    }
                    const volume = (sum / dataArray.length / 128) * 100;

                    const volumeThreshold = isNasal(modalCurrentLetter) ? 8 : 15;

                    // Detect peak (after 400ms delay)
                    const now = Date.now();
                    if (volume > volumeThreshold && (now - lastPeakTime) > PEAK_COOLDOWN) {
                        // Capture snapshot
                        let snapshot = downsampleFrequencies(dataArray, PATTERN_BINS);

                        // Check energy concentration
                        const peakEnergy = Math.max(...snapshot);
                        const avgEnergy = snapshot.reduce((a, b) => a + b, 0) / snapshot.length;
                        const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;
                        const concentrationThreshold = isNasal(modalCurrentLetter) ? 1.5 : 2.0;

                        if (energyConcentration < concentrationThreshold) {
                            return; // Skip weak peaks
                        }

                        // Pre-amplify nasals
                        if (isNasal(modalCurrentLetter)) {
                            snapshot = snapshot.map(v => v * 2.0);
                        }

                        // Normalize
                        const maxVal = Math.max(...snapshot);
                        const normalized = snapshot.map(v => v / maxVal);

                        // Capture!
                        modalCapturedSnapshots.push(normalized);
                        lastPeakTime = now;

                        console.log(`üì∏ Captured snapshot ${modalCapturedSnapshots.length}/5`);

                        // Draw in box
                        drawSnapshotInModalBox(modalListeningForIndex, normalized);

                        // Mark box as captured
                        const box = document.getElementById(`modalCaptureBox${modalListeningForIndex}`);
                        box.classList.remove('recording');
                        box.classList.add('captured');
                        box.style.cursor = 'default';

                        // Stop listening (but keep recording for full sound)
                        modalIsListening = false;
                        modalListeningForIndex = -1;

                        // Continue recording for 700ms after peak to capture the full sound
                        setTimeout(() => {
                            if (modalMediaRecorder && modalMediaRecorder.state === 'recording') {
                                modalMediaRecorder.stop();
                                modalMediaRecorder.addEventListener('stop', () => {
                                    const audioBlob = new Blob(modalAudioChunks, { type: 'audio/webm' });
                                    modalAudioClips.push(audioBlob);
                                    const sizeKB = (audioBlob.size / 1024).toFixed(2);
                                    console.log(`üéôÔ∏è Saved audio clip ${modalAudioClips.length}/5 (${sizeKB} KB)`);
                                }, { once: true });
                            }
                        }, 700); // Continue recording for 700ms after peak detected

                        // Update status and enable next box
                        if (modalCapturedSnapshots.length < 5) {
                            const nextBox = document.getElementById(`modalCaptureBox${modalCapturedSnapshots.length}`);
                            nextBox.classList.add('ready');
                            nextBox.style.cursor = 'pointer';
                            document.getElementById('modalStatus').textContent = `‚úì Captured ${modalCapturedSnapshots.length}/5. Click box ${modalCapturedSnapshots.length + 1}`;
                        } else {
                            // All done!
                            document.getElementById('modalStatus').textContent = `‚úì All 5 captured! Saving...`;
                            setTimeout(() => {
                                finishModalCalibration();
                            }, 500);
                        }
                    }
                }
            }
            visualize();
        }

        function drawModalWaveform() {
            if (!modalWaveformCtx || !dataArray) return;

            const width = modalWaveformCanvas.width;
            const height = modalWaveformCanvas.height;

            // Clear with fade
            modalWaveformCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            modalWaveformCtx.fillRect(0, 0, width, height);

            // Draw frequency bars
            const barWidth = width / dataArray.length * 2.5;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * height;
                const hue = (i / dataArray.length) * 120 + 100;
                modalWaveformCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                modalWaveformCtx.fillRect(x, height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        function drawSnapshotInModalBox(index, snapshot) {
            const canvas = document.getElementById(`modalCaptureCanvas${index}`);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const barWidth = canvas.width / snapshot.length;
            for (let j = 0; j < snapshot.length; j++) {
                const barHeight = snapshot[j] * canvas.height;
                const x = j * barWidth;
                const y = canvas.height - barHeight;

                ctx.fillStyle = '#7CB342';
                ctx.fillRect(x, y, barWidth - 1, barHeight);
            }
        }

        async function finishModalCalibration() {
            console.log('Finishing modal calibration...');

            // Use the SAME logic as the original finishCalibration
            const clusterResult = findBestCluster(modalCapturedSnapshots);
            const baseline = averageSnapshots(clusterResult.cluster);

            // Save in the correct format
            const patternData = {
                pattern: [baseline],
                timestamp: Date.now()
            };

            // Select the best audio clip from the cluster
            // Strategy: Use the FIRST clip from the cluster (usually the most representative)
            let bestAudioBlob = null;
            if (modalAudioClips.length > 0 && clusterResult.indices.length > 0) {
                const bestIndex = clusterResult.indices[0]; // First snapshot in best cluster
                if (bestIndex < modalAudioClips.length) {
                    bestAudioBlob = modalAudioClips[bestIndex];
                    const sizeKB = (bestAudioBlob.size / 1024).toFixed(2);
                    console.log(`üéØ Selected best audio clip: snapshot ${bestIndex + 1} (${sizeKB} KB)`);
                }
            }

            // Save to Supabase (with ONLY the best audio clip)
            const audioUrl = await saveCalibrationToSupabase(modalCurrentLetter, patternData, bestAudioBlob);

            // Update local calibrationData with audioUrl for immediate playback
            calibrationData[modalCurrentLetter] = {
                ...patternData,
                audioUrl: audioUrl
            };

            // Update UI
            updateCalibrationUI();

            console.log(`‚úÖ Calibrated ${modalCurrentLetter}: Used ${clusterResult.cluster.length}/${modalCapturedSnapshots.length} snapshots`);

            document.getElementById('modalStatus').innerHTML = '<strong style="color: #7CB342;">üéâ Calibrated!</strong>';

            // Show next button
            document.getElementById('modalNextButton').classList.add('active');
        }

        function goToNextLetter() {
            // Find current letter index in PHONEMES
            const currentIndex = PHONEMES.findIndex(p => p.letter === modalCurrentLetter);

            // Look for next uncalibrated letter
            for (let i = currentIndex + 1; i < PHONEMES.length; i++) {
                const nextLetter = PHONEMES[i].letter;
                if (!calibrationData[nextLetter]) {
                    // Found next uncalibrated letter
                    closeCalibrationModal();
                    setTimeout(() => {
                        openCalibrationModal(nextLetter);
                    }, 300);
                    return;
                }
            }

            // If no uncalibrated letters after current, check from beginning
            for (let i = 0; i < currentIndex; i++) {
                const nextLetter = PHONEMES[i].letter;
                if (!calibrationData[nextLetter]) {
                    closeCalibrationModal();
                    setTimeout(() => {
                        openCalibrationModal(nextLetter);
                    }, 300);
                    return;
                }
            }

            // All letters calibrated!
            closeCalibrationModal();
        }

        // Elimination game mode
        let patternBuffer = [];
        let currentTarget = null;
        let experimentResults = []; // Track all trials for analysis
        let alphabetModeEnabled = false;
        let currentAlphabetIndex = 0;

        function toggleAlphabetMode() {
            alphabetModeEnabled = document.getElementById('alphabetMode').checked;
            currentAlphabetIndex = 0;
            updateAlphabetProgress();
        }

        function updateAlphabetProgress() {
            const progressEl = document.getElementById('alphabetProgress');
            if (alphabetModeEnabled && currentTarget) {
                progressEl.style.display = 'inline';
                const letterIndex = PHONEMES.findIndex(p => p.letter === currentTarget) + 1;
                progressEl.textContent = `Letter ${letterIndex}/26: ${currentTarget}`;
            } else {
                progressEl.style.display = 'none';
            }
        }

        function pickRandomLetter() {
            // Only pick from letters that are BOTH calibrated AND in current PHONEMES list
            const allowedLetters = PHONEMES.map(p => p.letter);
            const calibratedLetters = Object.keys(calibrationData).filter(letter =>
                allowedLetters.includes(letter)
            );
            if (calibratedLetters.length === 0) return null;
            return calibratedLetters[Math.floor(Math.random() * calibratedLetters.length)];
        }

        function pickNextAlphabetLetter() {
            const allLetters = PHONEMES.map(p => p.letter);
            const calibratedLetters = Object.keys(calibrationData);

            // Start from current index and find next calibrated letter
            let attempts = 0;
            while (attempts < 26) {
                const letter = allLetters[currentAlphabetIndex];
                currentAlphabetIndex = (currentAlphabetIndex + 1) % 26;

                if (calibratedLetters.includes(letter)) {
                    return letter;
                }
                attempts++;
            }

            return null;
        }

        function skipLetter() {
            if (isRunning) {
                setNextTarget();
            }
        }

        function tryAgain() {
            // Reset and start listening again for same letter
            document.getElementById('tryAgainBtn').style.display = 'none';
            document.getElementById('tunerBtn').textContent = '‚è∏ Stop Game';
            patternBuffer = [];
            isRunning = true;
            analyzeTuner();
        }

        function setNextTarget() {
            currentTarget = alphabetModeEnabled ? pickNextAlphabetLetter() : pickRandomLetter();
            if (currentTarget) {
                document.getElementById('targetLetter').textContent = currentTarget;
                document.getElementById('status').textContent = `Say: ${currentTarget}`;
                document.getElementById('tryAgainBtn').style.display = 'none';
                patternBuffer = [];
                updateAlphabetProgress();
            }
        }

        async function toggleTuner() {
            const btn = document.getElementById('tunerBtn');

            // If button says "Next Letter", just advance to next
            if (btn.textContent === '‚ñ∂ Next Letter') {
                btn.textContent = '‚è∏ Stop Game';
                isRunning = true;
                setNextTarget();
                analyzeTuner();
                return;
            }

            if (isRunning) {
                isRunning = false;
                btn.textContent = '‚ñ∂ Start Game';
                document.getElementById('status').textContent = 'Stopped';
                document.getElementById('targetLetter').textContent = '?';
            } else {
                if (Object.keys(calibrationData).length === 0) {
                    alert('Please calibrate at least one phoneme first!');
                    return;
                }
                if (!audioContext) {
                    await setupAudio();
                }
                isRunning = true;
                btn.textContent = '‚è∏ Stop Game';
                setNextTarget();
                analyzeTuner();
            }
        }

        function analyzeTuner() {
            if (!isRunning) return;
            requestAnimationFrame(analyzeTuner);

            analyser.getByteFrequencyData(dataArray);

            // Draw spectrum
            drawSpectrum();

            // Calculate volume
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volume = (sum / dataArray.length / 128) * 100;
            document.getElementById('volume').textContent = Math.round(volume) + '%';

            // ALWAYS add current frame to buffer (sliding window)
            const pattern = downsampleFrequencies(dataArray, PATTERN_BINS);
            patternBuffer.push(pattern);

            // Keep buffer at PATTERN_LENGTH
            if (patternBuffer.length > PATTERN_LENGTH) {
                patternBuffer.shift();
            }

            // DEBUG: Show buffer status only when NOT ready
            if (currentTarget && patternBuffer.length < PATTERN_LENGTH) {
                document.getElementById('status').textContent = `Buffer: ${patternBuffer.length}/${PATTERN_LENGTH} frames (keep talking...)`;
            }

            // Check energy concentration (speech vs background noise)
            const peakEnergy = Math.max(...pattern);
            const avgEnergy = pattern.reduce((a, b) => a + b, 0) / pattern.length;
            const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;

            // Skip detection if playing back a recording
            if (isPlayingRecording) {
                return;
            }

            // Dynamic thresholds for nasals (same as game mode)
            const FRICATIVES = ['F', 'S', 'V', 'Z', 'H'];
            const LIQUIDS = ['L', 'R'];
            const isCurrentNasal = currentTarget && isNasal(currentTarget);
            const isFricative = currentTarget && FRICATIVES.includes(currentTarget);
            const isLiquid = currentTarget && LIQUIDS.includes(currentTarget);

            let volumeThreshold = 15;
            let concentrationThreshold = 2.0;

            if (isCurrentNasal || isLiquid) {
                volumeThreshold = 8;
                concentrationThreshold = 1.5;
            } else if (isFricative) {
                volumeThreshold = 10;
                concentrationThreshold = 1.8;
            }

            // Try to match against TARGET letter only
            if (patternBuffer.length === PATTERN_LENGTH && volume > volumeThreshold && energyConcentration > concentrationThreshold && currentTarget) {

                // S11-Snapshot detection for ALL letters
                const results = testAllPlosiveStrategies(patternBuffer, currentTarget);

                const result = results[0]; // Only S11-Snapshot now
                const score = Math.max(0, Math.min(100, result.score || 0));
                const targetScore = Math.max(0, Math.min(100, result.targetScore || 0));
                const prediction = result.predictedLetter || '?';
                const isCorrect = prediction === currentTarget;

                // Show simplified status
                const barCount = Math.max(0, Math.floor(score / 10));
                const bar = '‚ñà'.repeat(barCount);
                const statusText = `üéØ S11-Snapshot: ${isCorrect ? '‚úì' : '‚úó'} Predicted: ${prediction} | Score: ${Math.round(score)}% ${bar}\nTarget ${currentTarget}: ${Math.round(targetScore)}%`;

                document.getElementById('status').textContent = statusText;
                document.getElementById('matchScore').textContent = Math.round(score) + '%';
                document.getElementById('confidenceFill').style.width = score + '%';

                // Success if S11 predicts correctly AND score > 80%
                if (isCorrect && score > 80) {
                    celebrateMatch();

                    // Log this trial for analysis
                    experimentResults.push({
                        target: currentTarget,
                        timestamp: Date.now(),
                        strategies: results
                    });

                    // Prepend success message to experimental results
                    const trialsCount = experimentResults.length;
                    document.getElementById('trialsCount').textContent = trialsCount;
                    document.getElementById('status').textContent = `‚úì MATCH! ${Math.round(score)}% - Trial #${trialsCount} logged\n\n` + statusText;
                    // Stop analyzing so results stay visible
                    isRunning = false;
                    document.getElementById('tunerBtn').textContent = '‚ñ∂ Next Letter';
                    document.getElementById('tryAgainBtn').style.display = 'inline-block';
                }

                if (false) {
                    // REGULAR DETECTION: Use pattern matching for non-plosives
                    const score = matchTargetPattern(patternBuffer, currentTarget);

                    // Also check BEST match among all letters
                    const allScores = Object.keys(calibrationData).map(letter => {
                        const normalized = normalizePattern(patternBuffer);
                        const storedPattern = calibrationData[letter].pattern;
                        const similarity = calculatePatternSimilarity(normalized, storedPattern);
                        return { letter, score: similarity * 100 };
                    });

                    allScores.sort((a, b) => b.score - a.score);
                    const bestMatch = allScores[0];

                    document.getElementById('matchScore').textContent = Math.round(score) + '%';
                    document.getElementById('confidenceFill').style.width = score + '%';
                    document.getElementById('status').textContent = `Best match: ${bestMatch.letter} (${Math.round(bestMatch.score)}%)`;

                    // Success! Pattern matched AND it's the best match
                    if (score > 85 && bestMatch.letter === currentTarget) {
                        celebrateMatch();
                        document.getElementById('status').textContent = `‚úì PERFECT MATCH! (Try Again or Next Letter)\nBest match: ${bestMatch.letter} (${Math.round(bestMatch.score)}%)`;
                        // Stop analyzing so results stay visible
                        isRunning = false;
                        document.getElementById('tunerBtn').textContent = '‚ñ∂ Next Letter';
                        document.getElementById('tryAgainBtn').style.display = 'inline-block';
                    }
                }
            }
        }

        function matchTargetPattern(currentPattern, targetLetter) {
            if (!calibrationData[targetLetter]) return 0;

            // Normalize current pattern
            const normalized = normalizePattern(currentPattern);
            const storedPattern = calibrationData[targetLetter].pattern;

            // Calculate correlation
            const score = calculatePatternSimilarity(normalized, storedPattern);

            // Convert to percentage
            return Math.min(100, score * 100);
        }

        function celebrateMatch() {
            const targetEl = document.getElementById('targetLetter');

            // Play success sound
            if (audioContext) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.4);
            }

            // Exciting animation sequence
            targetEl.style.transition = 'all 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55)';

            // Bounce and color sequence
            targetEl.style.transform = 'scale(1.5) rotate(5deg)';
            targetEl.style.color = '#FDD835';

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.3) rotate(-5deg)';
                targetEl.style.color = '#7CB342';
            }, 150);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.6) rotate(0deg)';
                targetEl.style.color = '#00BCD4';
            }, 300);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.2)';
                targetEl.style.color = '#FF5722';
            }, 450);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.4)';
                targetEl.style.color = '#9C27B0';
            }, 600);

            setTimeout(() => {
                targetEl.style.transition = 'all 0.3s ease-out';
                targetEl.style.transform = 'scale(1)';
                targetEl.style.color = '#FDD835';
            }, 800);

            // Create confetti particles
            createConfetti(targetEl);
        }

        function createConfetti(centerEl) {
            const container = centerEl.parentElement;
            const rect = centerEl.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const colors = ['#FDD835', '#7CB342', '#00BCD4', '#FF5722', '#9C27B0'];

            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.style.position = 'fixed';
                particle.style.left = centerX + 'px';
                particle.style.top = centerY + 'px';
                particle.style.width = '10px';
                particle.style.height = '10px';
                particle.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                particle.style.pointerEvents = 'none';
                particle.style.zIndex = '9999';

                document.body.appendChild(particle);

                const angle = (Math.PI * 2 * i) / 20;
                const velocity = 100 + Math.random() * 100;
                const vx = Math.cos(angle) * velocity;
                const vy = Math.sin(angle) * velocity;

                let x = 0, y = 0, time = 0;
                const gravity = 500;

                const animate = () => {
                    time += 0.016; // ~60fps
                    x = vx * time;
                    y = vy * time + 0.5 * gravity * time * time;

                    particle.style.transform = `translate(${x}px, ${y}px) rotate(${time * 360}deg)`;
                    particle.style.opacity = Math.max(0, 1 - time * 1.5);

                    if (time < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        particle.remove();
                    }
                };

                requestAnimationFrame(animate);
            }
        }

        // ========== GAME TAB FUNCTIONS (COPY OF TUNER) ==========

        let isRunningGame = false;
        let currentTargetGame = null;
        let patternBufferGame = [];
        let gameAnimationFrame = null; // Track animation frame to prevent stacking
        let gameFrameCounter = 0; // Debug counter
        let activeOscillators = 0; // Track active audio oscillators
        let activeConfetti = 0; // Track active confetti animations
        const MAX_CONFETTI = 3; // Limit concurrent confetti
        let lastCelebratedLetter = null; // Track last celebrated letter to prevent multiple celebrations
        let gameLevel = 1; // Current game level
        let letterY = 0; // Letter vertical position (for falling animation)
        let letterSpeed = 1; // Letter falling speed

        function skipLetterGame() {
            if (isRunningGame) {
                setNextTargetGame();
            }
        }

        // tryAgainGame() removed - button no longer exists

        function setNextTargetGame() {
            currentTargetGame = alphabetModeEnabled ? pickNextAlphabetLetter() : pickRandomLetter();
            if (currentTargetGame) {
                const letterEl = document.getElementById('targetLetterGame');

                // Reset position instantly (no transition)
                letterY = -50; // Start above the visible area (negative %)
                letterEl.style.transition = 'none'; // Disable transitions
                letterEl.style.top = `${letterY}%`; // Set position immediately

                // Force reflow to apply the position change
                letterEl.offsetHeight;

                // Now update the letter content
                letterEl.textContent = currentTargetGame;
                document.getElementById('statusGame').textContent = `Say: ${currentTargetGame}`;
                patternBufferGame = [];
                lastCelebratedLetter = null; // Reset celebration flag for new letter

                updateAlphabetProgress();
            }
        }

        async function toggleTunerGame() {
            const btn = document.getElementById('tunerBtnGame');

            if (btn.textContent === '‚ñ∂ Next Letter') {
                btn.textContent = '‚è∏ Stop Game';
                isRunningGame = true;
                setNextTargetGame();
                analyzeTunerGame();
                return;
            }

            if (isRunningGame) {
                isRunningGame = false;
                btn.textContent = '‚ñ∂ Start Game';
                document.getElementById('statusGame').textContent = 'Stopped';
                document.getElementById('targetLetterGame').textContent = '?';

                // Clean up animation frame
                if (gameAnimationFrame) {
                    cancelAnimationFrame(gameAnimationFrame);
                    gameAnimationFrame = null;
                }
            } else {
                if (Object.keys(calibrationData).length === 0) {
                    alert('Please calibrate at least one phoneme first!');
                    return;
                }
                if (!audioContext) {
                    await setupAudio();
                }
                isRunningGame = true;
                btn.textContent = '‚è∏ Stop Game';
                setNextTargetGame();
                analyzeTunerGame();
            }
        }

        function analyzeTunerGame() {
            if (!isRunningGame) {
                // Cancel animation frame if stopped
                if (gameAnimationFrame) {
                    cancelAnimationFrame(gameAnimationFrame);
                    gameAnimationFrame = null;
                }
                console.log(`üõë Game stopped. Frames: ${gameFrameCounter}, Active oscillators: ${activeOscillators}`);
                gameFrameCounter = 0;
                return;
            }

            // Cancel previous frame before requesting new one (prevent stacking)
            if (gameAnimationFrame) {
                cancelAnimationFrame(gameAnimationFrame);
            }
            gameAnimationFrame = requestAnimationFrame(analyzeTunerGame);

            gameFrameCounter++;
            if (gameFrameCounter % 300 === 0) { // Log every 5 seconds (60fps * 5)
                console.log(`üìä Game stats: Frames: ${gameFrameCounter}, Active oscillators: ${activeOscillators}, Audio context state: ${audioContext?.state}`);
            }

            // Animate letter falling (Level 1+)
            if (gameLevel >= 1 && currentTargetGame) {
                letterY += letterSpeed; // Move down
                const letterEl = document.getElementById('targetLetterGame');
                // Update position: start from top (-50%), move to bottom (150%)
                letterEl.style.top = `${letterY}%`;

                // If letter goes off screen, spawn new letter
                if (letterY > 150) {
                    setNextTargetGame(); // New letter instead of looping
                }
            }

            analyser.getByteFrequencyData(dataArray);

            // Draw spectrum (only every 3 frames to reduce overhead)
            if (gameFrameCounter % 3 === 0) {
                const canvas = document.getElementById('spectrumCanvasGame');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    canvas.width = 800;
                    canvas.height = 240;

                    const width = canvas.width;
                    const height = canvas.height;

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(0, 0, width, height);

                    const barWidth = width / dataArray.length;
                    for (let i = 0; i < dataArray.length; i++) {
                        const barHeight = (dataArray[i] / 255) * height;
                        const x = i * barWidth;
                        const hue = (i / dataArray.length) * 360;
                        ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                        ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                    }
                }
            }

            // Calculate volume
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volume = (sum / dataArray.length / 128) * 100;
            document.getElementById('volumeGame').textContent = Math.round(volume) + '%';

            // ALWAYS add current frame to buffer
            const pattern = downsampleFrequencies(dataArray, PATTERN_BINS);
            patternBufferGame.push(pattern);

            if (patternBufferGame.length > PATTERN_LENGTH) {
                patternBufferGame.shift();
            }

            if (currentTargetGame && patternBufferGame.length < PATTERN_LENGTH) {
                document.getElementById('statusGame').textContent = `Buffer: ${patternBufferGame.length}/${PATTERN_LENGTH} frames (keep talking...)`;
            }

            const peakEnergy = Math.max(...pattern);
            const avgEnergy = pattern.reduce((a, b) => a + b, 0) / pattern.length;
            const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;

            if (isPlayingRecording) {
                return;
            }

            const FRICATIVES = ['F', 'S', 'V', 'Z', 'H'];
            const LIQUIDS = ['L', 'R'];
            const isCurrentNasal = currentTargetGame && isNasal(currentTargetGame);
            const isFricative = currentTargetGame && FRICATIVES.includes(currentTargetGame);
            const isLiquid = currentTargetGame && LIQUIDS.includes(currentTargetGame);

            let volumeThreshold = 15;
            let concentrationThreshold = 2.0;

            if (isCurrentNasal || isLiquid) {
                volumeThreshold = 8;
                concentrationThreshold = 1.5;
            } else if (isFricative) {
                volumeThreshold = 10;
                concentrationThreshold = 1.8;
            }

            if (patternBufferGame.length === PATTERN_LENGTH && volume > volumeThreshold && energyConcentration > concentrationThreshold && currentTargetGame) {
                const results = testAllPlosiveStrategies(patternBufferGame, currentTargetGame);

                const result = results[0];
                const score = Math.max(0, Math.min(100, result.score || 0));
                const targetScore = Math.max(0, Math.min(100, result.targetScore || 0));
                const prediction = result.predictedLetter || '?';
                const isCorrect = prediction === currentTargetGame;

                const barCount = Math.max(0, Math.floor(score / 10));
                const bar = '‚ñà'.repeat(barCount);
                const statusText = `üéØ S11-Snapshot: ${isCorrect ? '‚úì' : '‚úó'} Predicted: ${prediction} | Score: ${Math.round(score)}% ${bar}\nTarget ${currentTargetGame}: ${Math.round(targetScore)}%`;

                document.getElementById('statusGame').textContent = statusText;
                document.getElementById('matchScoreGame').textContent = Math.round(score) + '%';
                document.getElementById('confidenceFillGame').style.width = score + '%';

                if (isCorrect && score > 80) {
                    // Only celebrate if we haven't already celebrated this letter (prevent multiple celebrations per letter)
                    if (lastCelebratedLetter !== currentTargetGame) {
                        lastCelebratedLetter = currentTargetGame;
                        celebrateMatchGame();

                        document.getElementById('statusGame').textContent = `‚úì MATCH! ${Math.round(score)}%\n\n` + statusText;

                        // Auto-advance to next letter after short delay
                        setTimeout(() => {
                            setNextTargetGame();
                        }, 1000); // 1 second delay to see celebration
                    }

                    // DON'T stop the game - keep running
                    // isRunningGame stays true
                    // Button stays as "Pause"
                }
            }
        }

        function celebrateMatchGame() {
            const targetEl = document.getElementById('targetLetterGame');

            // LIMIT concurrent sounds to prevent crackling (max 2)
            if (audioContext && activeOscillators < 2) {
                activeOscillators++;
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2);

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);

                const startTime = audioContext.currentTime;
                oscillator.start(startTime);
                oscillator.stop(startTime + 0.4);

                // Clean up nodes after sound finishes
                oscillator.onended = () => {
                    try {
                        oscillator.disconnect();
                        gainNode.disconnect();
                        activeOscillators--;
                        console.log(`üîä Oscillator cleaned up. Active: ${activeOscillators}`);
                    } catch (e) {
                        console.warn('Oscillator cleanup error:', e);
                    }
                };
            }

            targetEl.style.transition = 'all 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
            targetEl.style.transform = 'scale(1.5) rotate(5deg)';
            targetEl.style.color = '#FDD835';

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.3) rotate(-5deg)';
                targetEl.style.color = '#7CB342';
            }, 150);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.6) rotate(0deg)';
                targetEl.style.color = '#00BCD4';
            }, 300);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.2)';
                targetEl.style.color = '#FF5722';
            }, 450);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.4)';
                targetEl.style.color = '#9C27B0';
            }, 600);

            setTimeout(() => {
                targetEl.style.transition = 'all 0.3s ease-out';
                targetEl.style.transform = 'scale(1)';
                targetEl.style.color = '#FDD835';
            }, 800);

            // Only create confetti if under limit
            if (activeConfetti < MAX_CONFETTI) {
                activeConfetti++;
                createConfetti(targetEl);
                // Decrease counter after confetti animation finishes (~1 second)
                setTimeout(() => {
                    activeConfetti--;
                }, 1000);
            }
        }

        // ========== GAME 3 TAB FUNCTIONS ==========

        let isRunningGame3 = false;
        let currentTargetGame3 = null;
        let patternBufferGame3 = [];
        let gameAnimationFrame3 = null;
        let gameFrameCounter3 = 0;
        let activeOscillators3 = 0;
        let activeConfetti3 = 0;
        const MAX_CONFETTI3 = 3;
        let lastCelebratedLetter3 = null;
        let gameLevel3 = 1;
        let letterY3 = 0;
        let letterSpeed3 = 0.5;
        let hasPlayedAudio3 = false;
        let currentLetterIndex3 = 0;
        let isListeningForStudent3 = false;
        let bottomPauseTimer3 = 0; // Track when letter reached bottom for pause
        let consecutiveSuccesses3 = 0; // Track consecutive successful matches for Level 1
        let letterWasMatched3 = false; // Track if current letter was successfully matched
        let instructionAudio = null; // Track instruction audio playback

        // ===== LEVEL PROGRESS TRACKING (localStorage + Supabase Hybrid) =====

        // Get letter progress from localStorage (instant)
        function getLetterProgress(letter) {
            const storageKey = `letterProgress_${currentProfile}`;
            const allProgress = JSON.parse(localStorage.getItem(storageKey) || '{}');
            return allProgress[letter] || {
                current_level: 1,
                level_1_completed: false,
                level_2_completed: false,
                level_3_completed: false,
                consecutive_successes: 0,
                last_practiced: new Date().toISOString()
            };
        }

        // Save letter progress to localStorage (instant) + sync to Supabase (background)
        async function saveLetterProgress(letter, updates) {
            const storageKey = `letterProgress_${currentProfile}`;
            const allProgress = JSON.parse(localStorage.getItem(storageKey) || '{}');

            // Merge updates
            allProgress[letter] = {
                ...allProgress[letter],
                ...updates,
                last_practiced: new Date().toISOString()
            };

            // Save to localStorage immediately (instant)
            localStorage.setItem(storageKey, JSON.stringify(allProgress));
            console.log(`üíæ Saved ${letter} progress to localStorage:`, allProgress[letter]);

            // Sync to Supabase in background (don't wait)
            syncProgressToSupabase(letter, allProgress[letter]).catch(err => {
                console.warn('‚ö†Ô∏è Failed to sync progress to Supabase:', err);
            });
        }

        // Sync progress to Supabase (background)
        async function syncProgressToSupabase(letter, progress) {
            if (!currentProfile) {
                console.log('‚è≠Ô∏è Skipping Supabase sync (no profile)');
                return;
            }

            try {
                const { data, error } = await supabase
                    .from('calibrations')
                    .update({
                        current_level: progress.current_level,
                        level_1_completed: progress.level_1_completed,
                        level_2_completed: progress.level_2_completed,
                        level_3_completed: progress.level_3_completed,
                        consecutive_successes: progress.consecutive_successes,
                        last_practiced: progress.last_practiced
                    })
                    .eq('profile_id', currentProfile)
                    .eq('letter', letter);

                if (error) throw error;
                console.log(`‚òÅÔ∏è Synced ${letter} progress to Supabase`);
            } catch (error) {
                console.error('‚ùå Supabase sync error:', error);
                throw error;
            }
        }

        // Load all progress from Supabase on startup (updates localStorage)
        async function loadProgressFromSupabase() {
            if (!currentProfile) return;

            try {
                const { data, error } = await supabase
                    .from('calibrations')
                    .select('letter, current_level, level_1_completed, level_2_completed, level_3_completed, consecutive_successes, last_practiced')
                    .eq('profile_id', currentProfile);

                if (error) throw error;

                if (data && data.length > 0) {
                    const storageKey = `letterProgress_${currentProfile}`;
                    const allProgress = {};

                    data.forEach(row => {
                        allProgress[row.letter] = {
                            current_level: row.current_level || 1,
                            level_1_completed: row.level_1_completed || false,
                            level_2_completed: row.level_2_completed || false,
                            level_3_completed: row.level_3_completed || false,
                            consecutive_successes: row.consecutive_successes || 0,
                            last_practiced: row.last_practiced
                        };
                    });

                    localStorage.setItem(storageKey, JSON.stringify(allProgress));
                    console.log(`üì• Loaded progress from Supabase for ${data.length} letters`);
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load progress from Supabase:', error);
            }
        }

        function skipLetterGame3() {
            if (isRunningGame3) {
                setNextTargetGame3();
            }
        }

        function openGame3Settings() {
            // TODO: Open settings modal with:
            // - Play calibration sound (speaker icon)
            // - Sensitivity slider
            // - Skip letter button
            // - Future settings...
            alert('Settings coming soon!\n\nWill include:\n- üîä Play sound\n- üìä Sensitivity\n- ‚è≠Ô∏è Skip letter');
        }

        function setNextTargetGame3() {
            // Level 1: Check if previous letter timed out without being matched
            if (gameLevel3 === 1 && !letterWasMatched3 && consecutiveSuccesses3 > 0) {
                console.log(`‚ùå Letter timed out! Resetting consecutive count from ${consecutiveSuccesses3} to 0`);
                consecutiveSuccesses3 = 0;

                // Update counter display
                const counterEl = document.getElementById('successCounter3');
                if (counterEl) {
                    counterEl.textContent = `‚≠ê 0/10`;
                }
            }

            // Level 1: Only letter A (for children who don't know letters yet)
            if (gameLevel3 === 1) {
                currentTargetGame3 = 'A';
            } else {
                // Other levels: random or alphabet mode
                currentTargetGame3 = alphabetModeEnabled ? pickNextAlphabetLetter() : pickRandomLetter();
            }

            if (currentTargetGame3) {
                const letterEl = document.getElementById('targetLetterGame3');

                letterY3 = -50;
                letterSpeed3 = 0.5; // Reset to normal speed
                hasPlayedAudio3 = false; // Reset audio flag for new letter
                isListeningForStudent3 = false; // Reset listening flag
                bottomPauseTimer3 = 0; // Reset pause timer
                letterWasMatched3 = false; // Reset match flag for new letter
                letterEl.style.transition = 'none';
                letterEl.style.top = `${letterY3}%`;

                letterEl.offsetHeight;

                letterEl.textContent = currentTargetGame3;
                if (gameLevel3 === 1) {
                    document.getElementById('statusGame3').textContent = `üéì Level 1: Listen and learn - ${currentTargetGame3}`;
                } else {
                    document.getElementById('statusGame3').textContent = `Say: ${currentTargetGame3}`;
                }
                patternBufferGame3 = [];
                lastCelebratedLetter3 = null;

                updateAlphabetProgress();
            }
        }

        async function toggleTunerGame3() {
            const btn = document.getElementById('tunerBtnGame3');

            if (btn.textContent === '‚ñ∂ Next Letter') {
                btn.textContent = '‚è∏ Stop Game';
                isRunningGame3 = true;
                setNextTargetGame3();
                analyzeTunerGame3();
                return;
            }

            if (isRunningGame3) {
                isRunningGame3 = false;
                btn.textContent = '‚ñ∂ Start Game';
                document.getElementById('statusGame3').textContent = 'Stopped';
                document.getElementById('targetLetterGame3').textContent = '?';

                // Hide success counter when stopping
                const counterEl = document.getElementById('successCounter3');
                if (counterEl) {
                    counterEl.style.display = 'none';
                }

                if (gameAnimationFrame3) {
                    cancelAnimationFrame(gameAnimationFrame3);
                    gameAnimationFrame3 = null;
                }
            } else {
                if (Object.keys(calibrationData).length === 0) {
                    alert('Please calibrate at least one phoneme first!');
                    return;
                }

                // Show instruction popup instead of starting immediately
                showGame3Instructions();
            }
        }

        function showGame3Instructions() {
            const modal = document.getElementById('game3InstructionModal');
            modal.classList.add('active');

            // Auto-play instruction audio (properly encoded)
            console.log('üîä Loading instruction audio...');
            const audioPath = 'voice-instructions/' + encodeURIComponent('game play 1_v2.mp3');
            console.log('üìÇ Audio path:', audioPath);
            instructionAudio = new Audio(audioPath);

            instructionAudio.onloadeddata = () => {
                console.log('‚úÖ Audio loaded successfully');
            };

            instructionAudio.oncanplaythrough = () => {
                console.log('‚úÖ Audio can play through');
            };

            instructionAudio.onerror = (e) => {
                console.error('‚ùå Audio loading error:', e);
                console.error('Attempted path:', audioPath);
                console.error('Error details:', instructionAudio.error);
            };

            const playPromise = instructionAudio.play();

            if (playPromise !== undefined) {
                playPromise
                    .then(() => {
                        console.log('‚úÖ Audio playing successfully');
                    })
                    .catch(err => {
                        console.error('‚ùå Audio autoplay blocked or failed:', err);
                    });
            }
        }

        async function startGame3FromInstructions() {
            // Stop instruction audio if playing
            if (instructionAudio) {
                instructionAudio.pause();
                instructionAudio.currentTime = 0;
                instructionAudio = null;
            }

            // Close modal
            const modal = document.getElementById('game3InstructionModal');
            modal.classList.remove('active');

            // Setup audio if needed
            if (!audioContext) {
                await setupAudio();
            }

            // Start the game
            const btn = document.getElementById('tunerBtnGame3');
            isRunningGame3 = true;
            btn.textContent = '‚è∏ Stop Game';

            // Reset to start from 'A' in Level 1
            if (gameLevel3 === 1) {
                currentLetterIndex3 = 0;
                // Show success counter for Level 1
                const counterEl = document.getElementById('successCounter3');
                if (counterEl) {
                    counterEl.style.display = 'block';
                    counterEl.textContent = `‚≠ê ${consecutiveSuccesses3}/10`;
                }
            }

            setNextTargetGame3();
            analyzeTunerGame3();
        }

        function showLevel1CompleteModal() {
            const modal = document.getElementById('game3LevelCompleteModal');
            modal.classList.add('active');

            // Auto-play celebration audio
            console.log('üéâ Loading celebration audio...');
            const audioPath = 'voice-instructions/' + encodeURIComponent('A success B start.mp3');
            const celebrationAudio = new Audio(audioPath);

            celebrationAudio.onloadeddata = () => {
                console.log('‚úÖ Celebration audio loaded');
            };

            celebrationAudio.play().catch(err => {
                console.error('‚ùå Celebration audio autoplay blocked:', err);
            });

            // Add confetti animation
            createCelebrationConfetti();
        }

        function closeLevel1Complete() {
            const modal = document.getElementById('game3LevelCompleteModal');
            modal.classList.remove('active');

            // Clear confetti
            const confettiContainer = document.getElementById('celebrationConfetti');
            if (confettiContainer) {
                confettiContainer.innerHTML = '';
            }
        }

        function createCelebrationConfetti() {
            const container = document.getElementById('celebrationConfetti');
            if (!container) return;

            // Clear existing confetti
            container.innerHTML = '';

            // Create 50 confetti pieces
            const colors = ['#FDD835', '#FF6B6B', '#4CAF50', '#2196F3', '#FF5722', '#9C27B0'];
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.style.position = 'absolute';
                confetti.style.width = '10px';
                confetti.style.height = '10px';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.top = -20 + 'px';
                confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                confetti.style.animation = `confettiFall ${2 + Math.random() * 3}s linear infinite`;
                confetti.style.animationDelay = Math.random() * 2 + 's';
                confetti.style.opacity = '0.8';
                container.appendChild(confetti);
            }
        }

        function analyzeTunerGame3() {
            if (!isRunningGame3) {
                if (gameAnimationFrame3) {
                    cancelAnimationFrame(gameAnimationFrame3);
                    gameAnimationFrame3 = null;
                }
                console.log(`üõë Game 3 stopped. Frames: ${gameFrameCounter3}, Active oscillators: ${activeOscillators3}`);
                gameFrameCounter3 = 0;
                return;
            }

            if (gameAnimationFrame3) {
                cancelAnimationFrame(gameAnimationFrame3);
            }
            gameAnimationFrame3 = requestAnimationFrame(analyzeTunerGame3);

            gameFrameCounter3++;
            if (gameFrameCounter3 % 300 === 0) {
                console.log(`üìä Game 3 stats: Frames: ${gameFrameCounter3}, Active oscillators: ${activeOscillators3}, Audio context state: ${audioContext?.state}`);
            }

            if (gameLevel3 >= 1 && currentTargetGame3) {
                letterY3 += letterSpeed3;
                const letterEl = document.getElementById('targetLetterGame3');
                letterEl.style.top = `${letterY3}%`;

                // Level 1: Auto-play calibration audio immediately when letter enters screen
                if (gameLevel3 === 1 && !hasPlayedAudio3 && letterY3 >= -20) {
                    hasPlayedAudio3 = true;
                    isListeningForStudent3 = false;

                    // Update mic indicator to red (not listening)
                    const micIndicator = document.getElementById('micIndicator3');
                    if (micIndicator) {
                        micIndicator.style.background = '#F44336';
                        micIndicator.style.boxShadow = '0 0 20px rgba(244, 67, 54, 0.8)';
                    }

                    // Play calibration audio
                    const calibration = calibrationData[currentTargetGame3];
                    if (calibration && calibration.audioUrl) {
                        const audio = new Audio(calibration.audioUrl);

                        // When audio finishes, start listening
                        audio.onended = () => {
                            isListeningForStudent3 = true;
                            console.log(`‚úÖ Audio finished, now listening for student to say: ${currentTargetGame3}`);

                            // Update mic indicator to green (listening)
                            if (micIndicator) {
                                micIndicator.style.background = '#4CAF50';
                                micIndicator.style.boxShadow = '0 0 20px rgba(76, 175, 80, 0.8)';
                            }
                        };

                        audio.play().catch(err => {
                            console.log('Audio play error:', err);
                            // If audio fails, still start listening
                            isListeningForStudent3 = true;
                            if (micIndicator) {
                                micIndicator.style.background = '#4CAF50';
                                micIndicator.style.boxShadow = '0 0 20px rgba(76, 175, 80, 0.8)';
                            }
                        });
                        console.log(`üîä Playing ${currentTargetGame3} sound from calibration`);
                    } else {
                        console.log(`‚ö†Ô∏è No calibration audio for ${currentTargetGame3}`);
                        // If no audio, start listening immediately
                        isListeningForStudent3 = true;
                        if (micIndicator) {
                            micIndicator.style.background = '#4CAF50';
                            micIndicator.style.boxShadow = '0 0 20px rgba(76, 175, 80, 0.8)';
                        }
                    }
                }

                // Level 1: Letter slows down, stops at bottom, pauses 3 seconds, then respawns
                if (gameLevel3 === 1) {
                    // Start slowing down at 55% (earlier for smoother deceleration)
                    if (letterY3 > 55 && letterY3 < 70 && letterSpeed3 > 0.15) {
                        letterSpeed3 = 0.15;
                    }

                    // Stop completely at bottom (70% - keeps letter comfortably visible)
                    if (letterY3 >= 70) {
                        letterY3 = 70;

                        // Start counting pause frames
                        bottomPauseTimer3++;

                        // After 3 seconds (180 frames at 60fps), spawn new letter
                        if (bottomPauseTimer3 >= 180) {
                            console.log('üîÑ Pause complete, spawning new letter...');
                            setNextTargetGame3();
                        }
                    }
                } else {
                    // Other levels: Letter respawns when it falls off screen
                    if (letterY3 > 150) {
                        setNextTargetGame3();
                    }
                }
            }

            analyser.getByteFrequencyData(dataArray);

            if (gameFrameCounter3 % 3 === 0) {
                const canvas = document.getElementById('spectrumCanvasGame3');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    canvas.width = 800;
                    canvas.height = 240;

                    const width = canvas.width;
                    const height = canvas.height;

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(0, 0, width, height);

                    const barWidth = width / dataArray.length;
                    for (let i = 0; i < dataArray.length; i++) {
                        const barHeight = (dataArray[i] / 255) * height;
                        const x = i * barWidth;
                        const hue = (i / dataArray.length) * 360;
                        ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                        ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                    }
                }
            }

            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volume = (sum / dataArray.length / 128) * 100;
            document.getElementById('volumeGame3').textContent = Math.round(volume) + '%';

            const pattern = downsampleFrequencies(dataArray, PATTERN_BINS);
            patternBufferGame3.push(pattern);

            if (patternBufferGame3.length > PATTERN_LENGTH) {
                patternBufferGame3.shift();
            }

            if (currentTargetGame3 && patternBufferGame3.length < PATTERN_LENGTH) {
                document.getElementById('statusGame3').textContent = `Buffer: ${patternBufferGame3.length}/${PATTERN_LENGTH} frames (keep talking...)`;
            }

            const peakEnergy = Math.max(...pattern);
            const avgEnergy = pattern.reduce((a, b) => a + b, 0) / pattern.length;
            const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;

            if (isPlayingRecording) {
                return;
            }

            // In Level 1, only do voice recognition if we're listening for student
            if (gameLevel3 === 1 && !isListeningForStudent3) {
                return;
            }

            const FRICATIVES = ['F', 'S', 'V', 'Z', 'H'];
            const LIQUIDS = ['L', 'R'];
            const isCurrentNasal = currentTargetGame3 && isNasal(currentTargetGame3);
            const isFricative = currentTargetGame3 && FRICATIVES.includes(currentTargetGame3);
            const isLiquid = currentTargetGame3 && LIQUIDS.includes(currentTargetGame3);

            let volumeThreshold = 15;
            let concentrationThreshold = 2.0;

            if (isCurrentNasal || isLiquid) {
                volumeThreshold = 8;
                concentrationThreshold = 1.5;
            } else if (isFricative) {
                volumeThreshold = 10;
                concentrationThreshold = 1.8;
            }

            if (patternBufferGame3.length === PATTERN_LENGTH && volume > volumeThreshold && energyConcentration > concentrationThreshold && currentTargetGame3) {
                const results = testAllPlosiveStrategies(patternBufferGame3, currentTargetGame3);

                const result = results[0];
                const score = Math.max(0, Math.min(100, result.score || 0));
                const targetScore = Math.max(0, Math.min(100, result.targetScore || 0));
                const prediction = result.predictedLetter || '?';
                const isCorrect = prediction === currentTargetGame3;

                const barCount = Math.max(0, Math.floor(score / 10));
                const bar = '‚ñà'.repeat(barCount);
                const statusText = `üéØ S11-Snapshot: ${isCorrect ? '‚úì' : '‚úó'} Predicted: ${prediction} | Score: ${Math.round(score)}% ${bar}\nTarget ${currentTargetGame3}: ${Math.round(targetScore)}%`;

                document.getElementById('statusGame3').textContent = statusText;
                document.getElementById('matchScoreGame3').textContent = Math.round(score) + '%';
                document.getElementById('confidenceFillGame3').style.width = score + '%';

                // Apply letter-specific sensitivity to score threshold
                const sensitivity = letterSensitivity[currentTargetGame3] || 1.0;
                // Lower sensitivity (0.5) = higher threshold (harder to match)
                // Higher sensitivity (1.5) = lower threshold (easier to match)
                const baseThreshold = 80;
                const adjustedScoreThreshold = baseThreshold / sensitivity;

                console.log(`üìä ${currentTargetGame3} sensitivity: ${sensitivity}x, threshold: ${adjustedScoreThreshold.toFixed(1)}%, score: ${score.toFixed(1)}%`);

                if (isCorrect && score > adjustedScoreThreshold) {
                    if (lastCelebratedLetter3 !== currentTargetGame3) {
                        lastCelebratedLetter3 = currentTargetGame3;
                        celebrateMatchGame3();

                        document.getElementById('statusGame3').textContent = `‚úì MATCH! ${Math.round(score)}%\n\n` + statusText;

                        // Level 1: Immediate pop and respawn
                        if (gameLevel3 === 1) {
                            console.log(`üéâ Student matched ${currentTargetGame3}! Popping letter...`);
                            isListeningForStudent3 = false;
                            letterWasMatched3 = true; // Mark this letter as matched

                            // Increment consecutive successes
                            consecutiveSuccesses3++;
                            console.log(`‚≠ê Consecutive successes: ${consecutiveSuccesses3}/10`);

                            // Update counter display
                            const counterEl = document.getElementById('successCounter3');
                            if (counterEl) {
                                counterEl.textContent = `‚≠ê ${consecutiveSuccesses3}/10`;
                                counterEl.style.display = 'block';
                            }

                            // Make letter explode/pop
                            const letterEl = document.getElementById('targetLetterGame3');
                            letterEl.style.transition = 'all 0.2s ease-out';
                            letterEl.style.transform = 'translateX(-50%) scale(2)';
                            letterEl.style.opacity = '0';

                            // Check if Level 1 is completed (10 consecutive successes)
                            if (consecutiveSuccesses3 >= 10) {
                                setTimeout(async () => {
                                    // Stop the game
                                    isRunningGame3 = false;
                                    const btn = document.getElementById('tunerBtnGame3');
                                    if (btn) btn.textContent = '‚ñ∂ Start Game';

                                    // Save progress: Level 1 completed!
                                    await saveLetterProgress(currentTargetGame3, {
                                        level_1_completed: true,
                                        current_level: 2,  // Advance to Level 2
                                        consecutive_successes: 0
                                    });

                                    // Show celebration modal
                                    showLevel1CompleteModal();
                                    consecutiveSuccesses3 = 0;
                                    if (counterEl) counterEl.textContent = `‚≠ê 0/10`;
                                }, 300);
                                return; // Don't spawn next letter
                            }

                            // Immediately spawn next letter (only if not completed)
                            setTimeout(() => {
                                letterEl.style.transition = 'none';
                                letterEl.style.transform = 'translateX(-50%) scale(1)';
                                letterEl.style.opacity = '1';
                                setNextTargetGame3();
                            }, 300);
                        } else {
                            // Other levels: delay before next letter
                            setTimeout(() => {
                                setNextTargetGame3();
                            }, 1000);
                        }
                    }
                }
            }
        }

        function celebrateMatchGame3() {
            const targetEl = document.getElementById('targetLetterGame3');

            if (audioContext && activeOscillators3 < 2) {
                activeOscillators3++;
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2);

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);

                const startTime = audioContext.currentTime;
                oscillator.start(startTime);
                oscillator.stop(startTime + 0.4);

                oscillator.onended = () => {
                    try {
                        oscillator.disconnect();
                        gainNode.disconnect();
                        activeOscillators3--;
                        console.log(`üîä Game 3 Oscillator cleaned up. Active: ${activeOscillators3}`);
                    } catch (e) {
                        console.warn('Game 3 Oscillator cleanup error:', e);
                    }
                };
            }

            targetEl.style.transition = 'all 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
            targetEl.style.transform = 'scale(1.5) rotate(5deg)';
            targetEl.style.color = '#FDD835';

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.3) rotate(-5deg)';
                targetEl.style.color = '#7CB342';
            }, 150);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.6) rotate(0deg)';
                targetEl.style.color = '#00BCD4';
            }, 300);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.2)';
                targetEl.style.color = '#FF5722';
            }, 450);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.4)';
                targetEl.style.color = '#9C27B0';
            }, 600);

            setTimeout(() => {
                targetEl.style.transition = 'all 0.3s ease-out';
                targetEl.style.transform = 'scale(1)';
                targetEl.style.color = '#FDD835';
            }, 800);

            if (activeConfetti3 < MAX_CONFETTI3) {
                activeConfetti3++;
                createConfetti(targetEl);
                setTimeout(() => {
                    activeConfetti3--;
                }, 1000);
            }
        }

        // ========== GAME 4 TAB FUNCTIONS ==========

        let isRunningGame4 = false;
        let currentTargetGame4 = null;
        let patternBufferGame4 = [];
        let gameAnimationFrame4 = null;
        let gameFrameCounter4 = 0;
        let activeOscillators4 = 0;
        let activeConfetti4 = 0;
        const MAX_CONFETTI4 = 3;
        let lastCelebratedLetter4 = null;
        let gameLevel4 = 1;
        let letterY4 = 0;
        let letterSpeed4 = 0.5;
        let hasPlayedAudio4 = false;
        let currentLetterIndex4 = 0;
        let isListeningForStudent4 = false;
        let bottomPauseTimer4 = 0; // Track when letter reached bottom for pause
        let consecutiveSuccesses4 = 0; // Track consecutive successful matches for Level 1
        let letterWasMatched4 = false; // Track if current letter was successfully matched
        let instructionAudio4 = null; // Track instruction audio playback

        function skipLetterGame4() {
            if (isRunningGame4) {
                setNextTargetGame4();
            }
        }

        function openGame4Settings() {
            // TODO: Open settings modal with:
            // - Play calibration sound (speaker icon)
            // - Sensitivity slider
            // - Skip letter button
            // - Future settings...
            alert('Settings coming soon!\n\nWill include:\n- üîä Play sound\n- üìä Sensitivity\n- ‚è≠Ô∏è Skip letter');
        }

        function setNextTargetGame4() {
            // Level 1: Check if previous letter timed out without being matched
            if (gameLevel4 === 1 && !letterWasMatched4 && consecutiveSuccesses4 > 0) {
                console.log(`‚ùå Letter timed out! Resetting consecutive count from ${consecutiveSuccesses4} to 0`);
                consecutiveSuccesses4 = 0;

                // Update counter display
                const counterEl = document.getElementById('successCounter4');
                if (counterEl) {
                    counterEl.textContent = `‚≠ê 0/10`;
                }
            }

            // Level 1: Only letter A (for children who don't know letters yet)
            if (gameLevel4 === 1) {
                currentTargetGame4 = 'A';
            } else {
                // Other levels: random or alphabet mode
                currentTargetGame4 = alphabetModeEnabled ? pickNextAlphabetLetter() : pickRandomLetter();
            }

            if (currentTargetGame4) {
                const letterEl = document.getElementById('targetLetterGame4');

                letterY4 = -50;
                letterSpeed4 = 0.5; // Reset to normal speed
                hasPlayedAudio4 = false; // Reset audio flag for new letter
                isListeningForStudent4 = false; // Reset listening flag
                bottomPauseTimer4 = 0; // Reset pause timer
                letterWasMatched4 = false; // Reset match flag for new letter
                letterEl.style.transition = 'none';
                letterEl.style.top = `${letterY4}%`;

                letterEl.offsetHeight;

                letterEl.textContent = currentTargetGame4;
                if (gameLevel4 === 1) {
                    document.getElementById('statusGame4').textContent = `üéì Level 1: Listen and learn - ${currentTargetGame4}`;
                } else {
                    document.getElementById('statusGame4').textContent = `Say: ${currentTargetGame4}`;
                }
                patternBufferGame4 = [];
                lastCelebratedLetter4 = null;

                updateAlphabetProgress();
            }
        }

        async function toggleTunerGame4() {
            const btn = document.getElementById('tunerBtnGame4');

            if (btn.textContent === '‚ñ∂ Next Letter') {
                btn.textContent = '‚è∏ Stop Game';
                isRunningGame4 = true;
                setNextTargetGame4();
                analyzeTunerGame4();
                return;
            }

            if (isRunningGame4) {
                isRunningGame4 = false;
                btn.textContent = '‚ñ∂ Start Game';
                document.getElementById('statusGame4').textContent = 'Stopped';
                document.getElementById('targetLetterGame4').textContent = '?';

                // Hide success counter when stopping
                const counterEl = document.getElementById('successCounter4');
                if (counterEl) {
                    counterEl.style.display = 'none';
                }

                if (gameAnimationFrame4) {
                    cancelAnimationFrame(gameAnimationFrame4);
                    gameAnimationFrame4 = null;
                }
            } else {
                if (Object.keys(calibrationData).length === 0) {
                    alert('Please calibrate at least one phoneme first!');
                    return;
                }

                // Show instruction popup instead of starting immediately
                showGame4Instructions();
            }
        }

        function showGame4Instructions() {
            const modal = document.getElementById('game4InstructionModal');
            modal.classList.add('active');

            // Auto-play instruction audio (properly encoded)
            console.log('üîä Loading instruction audio...');
            const audioPath = 'voice-instructions/' + encodeURIComponent('game play 1_v2.mp3');
            console.log('üìÇ Audio path:', audioPath);
            instructionAudio4 = new Audio(audioPath);

            instructionAudio4.onloadeddata = () => {
                console.log('‚úÖ Audio loaded successfully');
            };

            instructionAudio4.oncanplaythrough = () => {
                console.log('‚úÖ Audio can play through');
            };

            instructionAudio4.onerror = (e) => {
                console.error('‚ùå Audio loading error:', e);
                console.error('Attempted path:', audioPath);
                console.error('Error details:', instructionAudio4.error);
            };

            const playPromise = instructionAudio4.play();

            if (playPromise !== undefined) {
                playPromise
                    .then(() => {
                        console.log('‚úÖ Audio playing successfully');
                    })
                    .catch(err => {
                        console.error('‚ùå Audio autoplay blocked or failed:', err);
                    });
            }
        }

        async function startGame4FromInstructions() {
            // Stop instruction audio if playing
            if (instructionAudio4) {
                instructionAudio4.pause();
                instructionAudio4.currentTime = 0;
                instructionAudio4 = null;
            }

            // Close modal
            const modal = document.getElementById('game4InstructionModal');
            modal.classList.remove('active');

            // Setup audio if needed
            if (!audioContext) {
                await setupAudio();
            }

            // Start the game
            const btn = document.getElementById('tunerBtnGame4');
            isRunningGame4 = true;
            btn.textContent = '‚è∏ Stop Game';

            // Reset to start from 'A' in Level 1
            if (gameLevel4 === 1) {
                currentLetterIndex4 = 0;
                // Show success counter for Level 1
                const counterEl = document.getElementById('successCounter4');
                if (counterEl) {
                    counterEl.style.display = 'block';
                    counterEl.textContent = `‚≠ê ${consecutiveSuccesses4}/10`;
                }
            }

            setNextTargetGame4();
            analyzeTunerGame4();
        }

        function showGame4LevelComplete() {
            const modal = document.getElementById('game4LevelCompleteModal');
            modal.classList.add('active');

            // Auto-play celebration audio
            console.log('üéâ Loading celebration audio...');
            const audioPath = 'voice-instructions/' + encodeURIComponent('A success B start.mp3');
            const celebrationAudio = new Audio(audioPath);

            celebrationAudio.onloadeddata = () => {
                console.log('‚úÖ Celebration audio loaded');
            };

            celebrationAudio.play().catch(err => {
                console.error('‚ùå Celebration audio autoplay blocked:', err);
            });

            // Add confetti animation
            createCelebrationConfetti4();
        }

        function closeGame4LevelComplete() {
            const modal = document.getElementById('game4LevelCompleteModal');
            modal.classList.remove('active');

            // Clear confetti
            const confettiContainer = document.getElementById('celebrationConfetti4');
            if (confettiContainer) {
                confettiContainer.innerHTML = '';
            }
        }

        function createCelebrationConfetti4() {
            const container = document.getElementById('celebrationConfetti4');
            if (!container) return;

            // Clear existing confetti
            container.innerHTML = '';

            // Create 50 confetti pieces
            const colors = ['#FDD835', '#FF6B6B', '#4CAF50', '#2196F3', '#FF5722', '#9C27B0'];
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.style.position = 'absolute';
                confetti.style.width = '10px';
                confetti.style.height = '10px';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.top = -20 + 'px';
                confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                confetti.style.animation = `confettiFall ${2 + Math.random() * 3}s linear infinite`;
                confetti.style.animationDelay = Math.random() * 2 + 's';
                confetti.style.opacity = '0.8';
                container.appendChild(confetti);
            }
        }

        function analyzeTunerGame4() {
            if (!isRunningGame4) {
                if (gameAnimationFrame4) {
                    cancelAnimationFrame(gameAnimationFrame4);
                    gameAnimationFrame4 = null;
                }
                console.log(`üõë Game 4 stopped. Frames: ${gameFrameCounter4}, Active oscillators: ${activeOscillators4}`);
                gameFrameCounter4 = 0;
                return;
            }

            if (gameAnimationFrame4) {
                cancelAnimationFrame(gameAnimationFrame4);
            }
            gameAnimationFrame4 = requestAnimationFrame(analyzeTunerGame4);

            gameFrameCounter4++;
            if (gameFrameCounter4 % 300 === 0) {
                console.log(`üìä Game 4 stats: Frames: ${gameFrameCounter4}, Active oscillators: ${activeOscillators4}, Audio context state: ${audioContext?.state}`);
            }

            if (gameLevel4 >= 1 && currentTargetGame4) {
                letterY4 += letterSpeed4;
                const letterEl = document.getElementById('targetLetterGame4');
                letterEl.style.top = `${letterY4}%`;

                // Level 1: Auto-play calibration audio immediately when letter enters screen
                if (gameLevel4 === 1 && !hasPlayedAudio4 && letterY4 >= -20) {
                    hasPlayedAudio4 = true;
                    isListeningForStudent4 = false;

                    // Update mic indicator to red (not listening)
                    const micIndicator = document.getElementById('micIndicator4');
                    if (micIndicator) {
                        micIndicator.style.background = '#F44336';
                        micIndicator.style.boxShadow = '0 0 20px rgba(244, 67, 54, 0.8)';
                    }

                    // Play calibration audio
                    const calibration = calibrationData[currentTargetGame4];
                    if (calibration && calibration.audioUrl) {
                        const audio = new Audio(calibration.audioUrl);

                        // When audio finishes, start listening
                        audio.onended = () => {
                            isListeningForStudent4 = true;
                            console.log(`‚úÖ Audio finished, now listening for student to say: ${currentTargetGame4}`);

                            // Update mic indicator to green (listening)
                            if (micIndicator) {
                                micIndicator.style.background = '#4CAF50';
                                micIndicator.style.boxShadow = '0 0 20px rgba(76, 175, 80, 0.8)';
                            }
                        };

                        audio.play().catch(err => {
                            console.log('Audio play error:', err);
                            // If audio fails, still start listening
                            isListeningForStudent4 = true;
                            if (micIndicator) {
                                micIndicator.style.background = '#4CAF50';
                                micIndicator.style.boxShadow = '0 0 20px rgba(76, 175, 80, 0.8)';
                            }
                        });
                        console.log(`üîä Playing ${currentTargetGame4} sound from calibration`);
                    } else {
                        console.log(`‚ö†Ô∏è No calibration audio for ${currentTargetGame4}`);
                        // If no audio, start listening immediately
                        isListeningForStudent4 = true;
                        if (micIndicator) {
                            micIndicator.style.background = '#4CAF50';
                            micIndicator.style.boxShadow = '0 0 20px rgba(76, 175, 80, 0.8)';
                        }
                    }
                }

                // Level 1: Letter slows down, stops at bottom, pauses 3 seconds, then respawns
                if (gameLevel4 === 1) {
                    // Start slowing down at 55% (earlier for smoother deceleration)
                    if (letterY4 > 55 && letterY4 < 70 && letterSpeed4 > 0.15) {
                        letterSpeed4 = 0.15;
                    }

                    // Stop completely at bottom (70% - keeps letter comfortably visible)
                    if (letterY4 >= 70) {
                        letterY4 = 70;

                        // Start counting pause frames
                        bottomPauseTimer4++;

                        // After 3 seconds (180 frames at 60fps), spawn new letter
                        if (bottomPauseTimer4 >= 180) {
                            console.log('üîÑ Pause complete, spawning new letter...');
                            setNextTargetGame4();
                        }
                    }
                } else {
                    // Other levels: Letter respawns when it falls off screen
                    if (letterY4 > 150) {
                        setNextTargetGame4();
                    }
                }
            }

            analyser.getByteFrequencyData(dataArray);

            if (gameFrameCounter4 % 3 === 0) {
                const canvas = document.getElementById('spectrumCanvasGame4');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    canvas.width = 800;
                    canvas.height = 240;

                    const width = canvas.width;
                    const height = canvas.height;

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(0, 0, width, height);

                    const barWidth = width / dataArray.length;
                    for (let i = 0; i < dataArray.length; i++) {
                        const barHeight = (dataArray[i] / 255) * height;
                        const x = i * barWidth;
                        const hue = (i / dataArray.length) * 360;
                        ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                        ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                    }
                }
            }

            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volume = (sum / dataArray.length / 128) * 100;
            document.getElementById('volumeGame4').textContent = Math.round(volume) + '%';

            const pattern = downsampleFrequencies(dataArray, PATTERN_BINS);
            patternBufferGame4.push(pattern);

            if (patternBufferGame4.length > PATTERN_LENGTH) {
                patternBufferGame4.shift();
            }

            if (currentTargetGame4 && patternBufferGame4.length < PATTERN_LENGTH) {
                document.getElementById('statusGame4').textContent = `Buffer: ${patternBufferGame4.length}/${PATTERN_LENGTH} frames (keep talking...)`;
            }

            const peakEnergy = Math.max(...pattern);
            const avgEnergy = pattern.reduce((a, b) => a + b, 0) / pattern.length;
            const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;

            if (isPlayingRecording) {
                return;
            }

            // In Level 1, only do voice recognition if we're listening for student
            if (gameLevel4 === 1 && !isListeningForStudent4) {
                return;
            }

            const FRICATIVES = ['F', 'S', 'V', 'Z', 'H'];
            const LIQUIDS = ['L', 'R'];
            const isCurrentNasal = currentTargetGame4 && isNasal(currentTargetGame4);
            const isFricative = currentTargetGame4 && FRICATIVES.includes(currentTargetGame4);
            const isLiquid = currentTargetGame4 && LIQUIDS.includes(currentTargetGame4);

            let volumeThreshold = 15;
            let concentrationThreshold = 2.0;

            if (isCurrentNasal || isLiquid) {
                volumeThreshold = 8;
                concentrationThreshold = 1.5;
            } else if (isFricative) {
                volumeThreshold = 10;
                concentrationThreshold = 1.8;
            }

            if (patternBufferGame4.length === PATTERN_LENGTH && volume > volumeThreshold && energyConcentration > concentrationThreshold && currentTargetGame4) {
                const results = testAllPlosiveStrategies(patternBufferGame4, currentTargetGame4);

                const result = results[0];
                const score = Math.max(0, Math.min(100, result.score || 0));
                const targetScore = Math.max(0, Math.min(100, result.targetScore || 0));
                const prediction = result.predictedLetter || '?';
                const isCorrect = prediction === currentTargetGame4;

                const barCount = Math.max(0, Math.floor(score / 10));
                const bar = '‚ñà'.repeat(barCount);
                const statusText = `üéØ S11-Snapshot: ${isCorrect ? '‚úì' : '‚úó'} Predicted: ${prediction} | Score: ${Math.round(score)}% ${bar}\nTarget ${currentTargetGame4}: ${Math.round(targetScore)}%`;

                document.getElementById('statusGame4').textContent = statusText;
                document.getElementById('matchScoreGame4').textContent = Math.round(score) + '%';
                document.getElementById('confidenceFillGame4').style.width = score + '%';

                // Apply letter-specific sensitivity to score threshold
                const sensitivity = letterSensitivity[currentTargetGame4] || 1.0;
                // Lower sensitivity (0.5) = higher threshold (harder to match)
                // Higher sensitivity (1.5) = lower threshold (easier to match)
                const baseThreshold = 80;
                const adjustedScoreThreshold = baseThreshold / sensitivity;

                console.log(`üìä ${currentTargetGame4} sensitivity: ${sensitivity}x, threshold: ${adjustedScoreThreshold.toFixed(1)}%, score: ${score.toFixed(1)}%`);

                if (isCorrect && score > adjustedScoreThreshold) {
                    if (lastCelebratedLetter4 !== currentTargetGame4) {
                        lastCelebratedLetter4 = currentTargetGame4;
                        celebrateMatchGame4();

                        document.getElementById('statusGame4').textContent = `‚úì MATCH! ${Math.round(score)}%\n\n` + statusText;

                        // Level 1: Immediate pop and respawn
                        if (gameLevel4 === 1) {
                            console.log(`üéâ Student matched ${currentTargetGame4}! Popping letter...`);
                            isListeningForStudent4 = false;
                            letterWasMatched4 = true; // Mark this letter as matched

                            // Increment consecutive successes
                            consecutiveSuccesses4++;
                            console.log(`‚≠ê Consecutive successes: ${consecutiveSuccesses4}/10`);

                            // Update counter display
                            const counterEl = document.getElementById('successCounter4');
                            if (counterEl) {
                                counterEl.textContent = `‚≠ê ${consecutiveSuccesses4}/10`;
                                counterEl.style.display = 'block';
                            }

                            // Make letter explode/pop
                            const letterEl = document.getElementById('targetLetterGame4');
                            letterEl.style.transition = 'all 0.2s ease-out';
                            letterEl.style.transform = 'translateX(-50%) scale(2)';
                            letterEl.style.opacity = '0';

                            // Check if Level 1 is completed (10 consecutive successes)
                            if (consecutiveSuccesses4 >= 10) {
                                setTimeout(() => {
                                    // Show celebration modal
                                    showGame4LevelComplete();
                                    consecutiveSuccesses4 = 0;
                                    if (counterEl) counterEl.textContent = `‚≠ê 0/10`;
                                }, 300);
                            }

                            // Immediately spawn next letter
                            setTimeout(() => {
                                letterEl.style.transition = 'none';
                                letterEl.style.transform = 'translateX(-50%) scale(1)';
                                letterEl.style.opacity = '1';
                                setNextTargetGame4();
                            }, 300);
                        } else {
                            // Other levels: delay before next letter
                            setTimeout(() => {
                                setNextTargetGame4();
                            }, 1000);
                        }
                    }
                }
            }
        }

        function celebrateMatchGame4() {
            const targetEl = document.getElementById('targetLetterGame4');

            if (audioContext && activeOscillators4 < 2) {
                activeOscillators4++;
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2);

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);

                const startTime = audioContext.currentTime;
                oscillator.start(startTime);
                oscillator.stop(startTime + 0.4);

                oscillator.onended = () => {
                    try {
                        oscillator.disconnect();
                        gainNode.disconnect();
                        activeOscillators4--;
                        console.log(`üîä Game 4 Oscillator cleaned up. Active: ${activeOscillators4}`);
                    } catch (e) {
                        console.warn('Game 4 Oscillator cleanup error:', e);
                    }
                };
            }

            targetEl.style.transition = 'all 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
            targetEl.style.transform = 'scale(1.5) rotate(5deg)';
            targetEl.style.color = '#FDD835';

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.3) rotate(-5deg)';
                targetEl.style.color = '#7CB342';
            }, 150);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.6) rotate(0deg)';
                targetEl.style.color = '#00BCD4';
            }, 300);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.2)';
                targetEl.style.color = '#FF5722';
            }, 450);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.4)';
                targetEl.style.color = '#9C27B0';
            }, 600);

            setTimeout(() => {
                targetEl.style.transition = 'all 0.3s ease-out';
                targetEl.style.transform = 'scale(1)';
                targetEl.style.color = '#FDD835';
            }, 800);

            if (activeConfetti4 < MAX_CONFETTI4) {
                activeConfetti4++;
                createConfetti(targetEl);
                setTimeout(() => {
                    activeConfetti4--;
                }, 1000);
            }
        }

        // ========== EXPERIMENTAL PLOSIVE DETECTION STRATEGIES ==========

        function testAllPlosiveStrategies(patternBuffer, targetLetter) {
            if (!calibrationData[targetLetter]) return [{ strategy: 'none', score: 0, predictedLetter: '?' }];

            const results = [];
            const strategyFunctions = [
                { name: 'S11-Snapshot', fn: strategy11_simpleSnapshot }
            ];

            // For each strategy, test against ALL calibrated letters
            strategyFunctions.forEach(({ name, fn }) => {
                let bestLetter = null;
                let bestScore = 0;
                let targetScore = 0;

                // Test this strategy against all calibrated letters
                Object.keys(calibrationData).forEach(letter => {
                    const score = fn(patternBuffer, letter);
                    if (score > bestScore) {
                        bestScore = score;
                        bestLetter = letter;
                    }
                    if (letter === targetLetter) {
                        targetScore = score;
                    }
                });

                results.push({
                    strategy: name,
                    score: bestScore,
                    targetScore: targetScore,
                    predictedLetter: bestLetter || '?'
                });
            });

            // Sort by score (highest first)
            results.sort((a, b) => b.score - a.score);

            return results;
        }

        // Strategy 1: Focus on frames around peak energy
        function strategy1_burstWindow(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const peakIdx = energies.indexOf(Math.max(...energies));

            const burstWindow = buffer.slice(Math.max(0, peakIdx - 5), peakIdx + 5);
            return matchTargetPattern(burstWindow, target);
        }

        // Strategy 2: Use only first 10 frames
        function strategy2_shortWindow(buffer, target) {
            const shortBuffer = buffer.slice(0, 10);
            return matchTargetPattern(shortBuffer, target);
        }

        // Strategy 3: Compare peak frequency and amplitude
        function strategy3_peakEnergy(buffer, target) {
            const currentPeak = Math.max(...buffer.flat());
            const currentPeakFreq = buffer[0].indexOf(Math.max(...buffer[0]));

            const calibPattern = calibrationData[target].pattern;
            const calibPeak = Math.max(...calibPattern.flat());
            const calibPeakFreq = calibPattern[0].indexOf(Math.max(...calibPattern[0]));

            const peakSimilarity = 1 - Math.abs(currentPeak - calibPeak);
            const freqSimilarity = 1 - Math.abs(currentPeakFreq - calibPeakFreq) / PATTERN_BINS;

            return ((peakSimilarity + freqSimilarity) / 2) * 100;
        }

        // Strategy 4: Compare attack speed (volume rise rate)
        function strategy4_attackSpeed(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));

            let maxRise = 0;
            for (let i = 1; i < energies.length; i++) {
                const rise = energies[i] - energies[i - 1];
                if (rise > maxRise) maxRise = rise;
            }

            // Compare with calibration (would need to store this)
            // For now, just use pattern matching on energy envelope
            const normalized = normalizePattern(buffer);
            const stored = calibrationData[target].pattern;
            return calculatePatternSimilarity(normalized, stored) * 100;
        }

        // Strategy 5: Match derivatives (rate of change)
        function strategy5_derivative(buffer, target) {
            const derivatives = [];
            for (let i = 1; i < buffer.length; i++) {
                const diff = buffer[i].map((val, idx) => val - buffer[i - 1][idx]);
                derivatives.push(diff);
            }

            return matchTargetPattern(derivatives, target);
        }

        // Strategy 6: Simple burst detection + frequency check
        function strategy6_dualThreshold(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const maxEnergy = Math.max(...energies);
            const avgEnergy = energies.reduce((a, b) => a + b, 0) / energies.length;

            const isBurst = maxEnergy > avgEnergy * 2;

            if (!isBurst) return 0;

            return matchTargetPattern(buffer, target);
        }

        // Strategy 7: Average multiple high-energy frames
        function strategy7_multipleFrames(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const threshold = Math.max(...energies) * 0.7;

            const highEnergyFrames = buffer.filter((frame, idx) => energies[idx] > threshold);

            if (highEnergyFrames.length === 0) return 0;

            return matchTargetPattern(highEnergyFrames, target);
        }

        // Strategy 8: Measure quiet-to-loud ratio
        function strategy8_silenceRatio(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const avgEnergy = energies.reduce((a, b) => a + b, 0) / energies.length;

            const quietFrames = energies.filter(e => e < avgEnergy * 0.5).length;
            const silenceRatio = quietFrames / energies.length;

            // Plosives should have high silence ratio
            const expectedRatio = 0.6; // 60% quiet
            const ratioScore = 1 - Math.abs(silenceRatio - expectedRatio);

            const patternScore = matchTargetPattern(buffer, target) / 100;

            return ((ratioScore + patternScore) / 2) * 100;
        }

        // Strategy 10: Only match first 5 frames (immediate burst)
        function strategy10_firstFrames(buffer, target) {
            const firstFrames = buffer.slice(0, 5);
            return matchTargetPattern(firstFrames, target);
        }

        // Strategy 11: Simple Snapshot Comparison (peak moment bar heights)
        function strategy11_simpleSnapshot(buffer, target) {
            if (!calibrationData[target]) return 0;

            // Find peak moment in current buffer (highest energy frame)
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const currentPeakIdx = energies.indexOf(Math.max(...energies));
            let currentSnapshot = buffer[currentPeakIdx];

            // Normalize current snapshot to 0-1 range (same as calibration data)
            const maxCurrent = Math.max(...currentSnapshot);
            if (maxCurrent > 0) {
                currentSnapshot = currentSnapshot.map(v => v / maxCurrent);
            }

            // Get stored baseline snapshot (already averaged and normalized)
            const storedSnapshot = calibrationData[target].pattern[0]; // It's a single snapshot now

            // Calculate simple distance (sum of absolute differences)
            let totalDistance = 0;
            const minLength = Math.min(currentSnapshot.length, storedSnapshot.length);

            for (let i = 0; i < minLength; i++) {
                totalDistance += Math.abs(currentSnapshot[i] - storedSnapshot[i]);
            }

            // Convert distance to similarity score (0-100)
            // Max possible avgDistance is 1.0 (completely different patterns)
            const avgDistance = totalDistance / minLength;
            const similarity = Math.max(0, 100 - (avgDistance * 100));

            return similarity;
        }

        function calculatePatternSimilarity(pattern1, pattern2) {
            // Use correlation coefficient to measure similarity
            let sumProduct = 0;
            let sum1Sq = 0;
            let sum2Sq = 0;
            let count = 0;

            const minLength = Math.min(pattern1.length, pattern2.length);

            for (let t = 0; t < minLength; t++) {
                const slice1 = pattern1[t];
                const slice2 = pattern2[t];
                const minBins = Math.min(slice1.length, slice2.length);

                for (let f = 0; f < minBins; f++) {
                    sumProduct += slice1[f] * slice2[f];
                    sum1Sq += slice1[f] * slice1[f];
                    sum2Sq += slice2[f] * slice2[f];
                    count++;
                }
            }

            const denominator = Math.sqrt(sum1Sq * sum2Sq);
            if (denominator === 0) return 0;

            return sumProduct / denominator; // Correlation coefficient
        }

        function drawSpectrum() {
            const width = canvas.width;
            const height = canvas.height;

            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            canvasCtx.fillRect(0, 0, width, height);

            const barWidth = width / dataArray.length * 2.5;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * height;
                const hue = (i / dataArray.length) * 120 + 100;
                canvasCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                canvasCtx.fillRect(x, height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        // DEPRECATED: Audio is now stored in Supabase Storage
        // These functions are kept for backwards compatibility but are no longer used
        function saveAudioRecording(letter, audioBlob) {
            console.warn('‚ö†Ô∏è saveAudioRecording is deprecated - audio now saved to Supabase Storage');
        }

        function loadAudioRecordings() {
            console.warn('‚ö†Ô∏è loadAudioRecordings is deprecated - audio loaded from Supabase');
            audioRecordings = {}; // Keep empty for legacy code compatibility
        }

        let isPlayingRecording = false;
        let currentPhonemeAudio = null;

        function playPhonemeSound(letter) {
            const phoneme = PHONEMES.find(p => p.letter === letter);
            if (!phoneme || !phoneme.audioUrl) return;

            if (currentPhonemeAudio) {
                currentPhonemeAudio.pause();
                currentPhonemeAudio.currentTime = 0;
            }

            currentPhonemeAudio = new Audio(phoneme.audioUrl);
            currentPhonemeAudio.play().catch(err => {
                console.error('Audio playback failed:', err);
            });
        }

        function playCalibrationRecording() {
            if (!currentTarget) {
                alert('No letter selected. Start the tuner first!');
                return;
            }

            // Get audio URL from Supabase calibration data
            const calibration = calibrationData[currentTarget];
            if (!calibration || !calibration.audioUrl) {
                alert(`No recording found for ${currentTarget}. Please calibrate this letter first.`);
                return;
            }

            isPlayingRecording = true;
            const audio = new Audio(calibration.audioUrl);

            audio.onended = () => {
                isPlayingRecording = false;
            };

            audio.onerror = () => {
                isPlayingRecording = false;
                alert('Error playing audio from Supabase Storage');
            };

            audio.play();
        }

        async function setupAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.stream = stream;

                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.5;

                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);

                microphone.connect(analyser);

            } catch (err) {
                alert('Microphone access denied!');
                console.error('Audio setup error:', err);
            }
        }

        function switchTab(tabName) {
            console.log(`üîÑ switchTab called with: "${tabName}"`);

            // ===== STOP ALL RUNNING GAMES/ANIMATIONS BEFORE SWITCHING =====

            // Stop Tuner tab if running
            if (isRunning && gameAnimationFrame) {
                console.log('üõë Stopping Tuner...');
                isRunning = false;
                cancelAnimationFrame(gameAnimationFrame);
                gameAnimationFrame = null;
                const tunerBtn = document.getElementById('tunerBtn');
                if (tunerBtn) tunerBtn.textContent = '‚ñ∂ Start';
            }

            // Stop Game tab if running
            if (isRunningGame && gameAnimationFrameGame) {
                console.log('üõë Stopping Game...');
                isRunningGame = false;
                cancelAnimationFrame(gameAnimationFrameGame);
                gameAnimationFrameGame = null;
                const gameBtn = document.getElementById('tunerBtnGame');
                if (gameBtn) gameBtn.textContent = '‚ñ∂ Start Game';
            }

            // Stop Progressive Game (falling letters) if running
            if (progressGame && progressGame.running) {
                console.log('üõë Stopping Progressive Game...');
                progressGame.running = false;
                if (progressGame.animationFrame) {
                    cancelAnimationFrame(progressGame.animationFrame);
                    progressGame.animationFrame = null;
                }
                if (progressGame.audioAnalysisFrame) {
                    cancelAnimationFrame(progressGame.audioAnalysisFrame);
                    progressGame.audioAnalysisFrame = null;
                }
                const progressBtn = document.getElementById('progressGameBtn');
                if (progressBtn) progressBtn.textContent = '‚ñ∂ Start Game';
            }

            // Stop Game 3 tab if running
            if (isRunningGame3 && gameAnimationFrame3) {
                console.log('üõë Stopping Game 3...');
                isRunningGame3 = false;
                cancelAnimationFrame(gameAnimationFrame3);
                gameAnimationFrame3 = null;
                const game3Btn = document.getElementById('tunerBtnGame3');
                if (game3Btn) game3Btn.textContent = '‚ñ∂ Start Game';
            }

            console.log('‚úì All games stopped');

            // Remove active from all tabs and content
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            // Find and activate the clicked tab button
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                if (tab.onclick && tab.onclick.toString().includes(`'${tabName}'`)) {
                    tab.classList.add('active');
                    console.log(`‚úì Activated tab button for: ${tabName}`);
                }
            });

            // Show the tab content
            const tabContent = document.getElementById(tabName);
            console.log(`üìã Found tab content element:`, tabContent);

            if (tabContent) {
                tabContent.classList.add('active');
                console.log(`‚úì Added 'active' class to #${tabName}`);
                console.log(`üìä Element display after:`, window.getComputedStyle(tabContent).display);
            } else {
                console.error(`‚ùå Could not find element with id="${tabName}"`);
            }
        }

        // ========== STATISTICS & EXPORT ==========

        function viewStats() {
            if (experimentResults.length === 0) {
                alert('No trials recorded yet. Run some tests first!');
                return;
            }

            // Calculate accuracy per strategy
            const strategyStats = {};

            experimentResults.forEach(trial => {
                trial.strategies.forEach(result => {
                    if (!strategyStats[result.strategy]) {
                        strategyStats[result.strategy] = { correct: 0, total: 0 };
                    }
                    strategyStats[result.strategy].total++;
                    if (result.predictedLetter === trial.target) {
                        strategyStats[result.strategy].correct++;
                    }
                });
            });

            // Format stats display
            let statsText = `üìä EXPERIMENT STATISTICS (${experimentResults.length} trials):\n\n`;

            // Sort strategies by accuracy
            const sortedStrategies = Object.entries(strategyStats)
                .map(([name, stats]) => ({
                    name,
                    accuracy: (stats.correct / stats.total) * 100,
                    correct: stats.correct,
                    total: stats.total
                }))
                .sort((a, b) => b.accuracy - a.accuracy);

            sortedStrategies.forEach(s => {
                const bar = '‚ñà'.repeat(Math.floor(s.accuracy / 10));
                statsText += `${s.name.padEnd(12)} ${Math.round(s.accuracy).toString().padStart(3)}% ${bar} (${s.correct}/${s.total})\n`;
            });

            statsText += `\n\nTarget letter breakdown:\n`;
            const targetCounts = {};
            experimentResults.forEach(t => {
                targetCounts[t.target] = (targetCounts[t.target] || 0) + 1;
            });
            Object.entries(targetCounts).forEach(([letter, count]) => {
                statsText += `  ${letter}: ${count} trials\n`;
            });

            document.getElementById('status').textContent = statsText;
        }

        function exportResults() {
            if (experimentResults.length === 0) {
                alert('No trials recorded yet. Run some tests first!');
                return;
            }

            const dataStr = JSON.stringify(experimentResults, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `plosive-experiment-${Date.now()}.json`;
            a.click();

            alert(`Exported ${experimentResults.length} trials`);
        }

        // ========== GAME MODE ==========

        let gameCanvas;
        let gameCtx;
        let gameSpectrumCanvas;
        let gameSpectrumCtx;
        let gameRunning = false;
        let gameScore = 0;
        let gameLives = 3;
        let gameSpeed = 1;
        let fallingLetters = [];
        let gamePatternBuffer = [];
        let lastSpawnTime = 0;
        // gameAnimationFrame already declared above in Game tab functions

        class FallingLetter {
            constructor(letter, lane, speed) {
                this.letter = letter;
                this.lane = lane;
                this.y = 0;
                this.speed = speed;
                this.width = 100;
                this.height = 120;
            }

            update(deltaSpeed) {
                this.y += this.speed * deltaSpeed;
            }

            isAtBottom(canvasHeight) {
                return this.y + this.height >= canvasHeight;
            }

            getDistance(canvasHeight) {
                return canvasHeight - (this.y + this.height);
            }
        }

        function initGame() {
            gameCanvas = document.getElementById('gameCanvas');
            gameCtx = gameCanvas.getContext('2d');
            gameCanvas.width = 400;
            gameCanvas.height = 700;

            gameSpectrumCanvas = document.getElementById('gameSpectrumCanvas');
            gameSpectrumCtx = gameSpectrumCanvas.getContext('2d');
            gameSpectrumCanvas.width = 800;
            gameSpectrumCanvas.height = 100;
        }

        async function toggleGame() {
            const btn = document.getElementById('gameBtn');

            if (gameRunning) {
                stopGame();
            } else {
                if (Object.keys(calibrationData).length === 0) {
                    alert('Please calibrate at least one phoneme first!');
                    return;
                }
                if (!audioContext) {
                    await setupAudio();
                }
                startGame();
            }
        }

        function startGame() {
            gameRunning = true;
            gameScore = 0;
            gameLives = 3;
            gameSpeed = 1;
            fallingLetters = [];
            gamePatternBuffer = [];
            lastSpawnTime = 0;

            document.getElementById('gameBtn').textContent = '‚è∏ Pause';
            updateGameUI();

            if (!gameCanvas) initGame();

            gameLoop();
            analyzeGameAudio();
        }

        function stopGame() {
            gameRunning = false;
            document.getElementById('gameBtn').textContent = '‚ñ∂ Start Game';
            if (gameAnimationFrame) {
                cancelAnimationFrame(gameAnimationFrame);
            }
        }

        function restartGame() {
            stopGame();
            setTimeout(() => {
                if (audioContext) {
                    startGame();
                }
            }, 100);
        }

        function updateGameUI() {
            document.getElementById('gameScore').textContent = gameScore;
            document.getElementById('gameLives').textContent = gameLives;
            document.getElementById('gameSpeed').textContent = gameSpeed.toFixed(1) + 'x';
        }

        function spawnLetter() {
            const calibratedLetters = Object.keys(calibrationData);
            if (calibratedLetters.length === 0) return;

            if (fallingLetters.length >= 3) return;

            const usedLanes = fallingLetters.map(l => l.lane);
            const availableLanes = [0, 1, 2].filter(lane => !usedLanes.includes(lane));
            if (availableLanes.length === 0) return;

            const lane = availableLanes[Math.floor(Math.random() * availableLanes.length)];
            const letter = calibratedLetters[Math.floor(Math.random() * calibratedLetters.length)];
            const speed = 1 * gameSpeed;

            fallingLetters.push(new FallingLetter(letter, lane, speed));
        }

        function gameLoop() {
            if (!gameRunning) return;

            const now = Date.now();
            if (now - lastSpawnTime > 2000 && fallingLetters.length < 3) {
                spawnLetter();
                lastSpawnTime = now;
            }

            gameCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

            let closestLetter = null;
            let minDistance = Infinity;

            fallingLetters.forEach(letter => {
                letter.update(1);

                const distance = letter.getDistance(gameCanvas.height);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestLetter = letter;
                }
            });

            fallingLetters.forEach(letter => {
                const x = (letter.lane * (gameCanvas.width / 3)) + (gameCanvas.width / 6) - (letter.width / 2);
                const isClosest = letter === closestLetter;

                if (isClosest) {
                    gameCtx.fillStyle = '#F44336';
                    gameCtx.shadowBlur = 20;
                    gameCtx.shadowColor = '#F44336';
                } else {
                    gameCtx.fillStyle = '#FDD835';
                    gameCtx.shadowBlur = 0;
                }

                gameCtx.font = 'bold 80px Arial';
                gameCtx.textAlign = 'center';
                gameCtx.textBaseline = 'middle';
                gameCtx.fillText(letter.letter, x + letter.width / 2, letter.y + letter.height / 2);

                gameCtx.shadowBlur = 0;
            });

            const lettersThatHitBottom = fallingLetters.filter(l => l.isAtBottom(gameCanvas.height));
            if (lettersThatHitBottom.length > 0) {
                gameLives -= lettersThatHitBottom.length;
                fallingLetters = fallingLetters.filter(l => !l.isAtBottom(gameCanvas.height));
                updateGameUI();

                if (gameLives <= 0) {
                    endGame();
                    return;
                }
            }

            if (closestLetter) {
                document.getElementById('gameStatus').textContent = `Say: ${closestLetter.letter}`;
            } else {
                document.getElementById('gameStatus').textContent = 'Get ready...';
            }

            gameAnimationFrame = requestAnimationFrame(gameLoop);
        }

        function analyzeGameAudio() {
            if (!gameRunning) return;
            requestAnimationFrame(analyzeGameAudio);

            analyser.getByteFrequencyData(dataArray);

            const pattern = downsampleFrequencies(dataArray, PATTERN_BINS);
            gamePatternBuffer.push(pattern);

            if (gamePatternBuffer.length > PATTERN_LENGTH) {
                gamePatternBuffer.shift();
            }

            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volume = (sum / dataArray.length / 128) * 100;

            document.getElementById('gameVolume').textContent = Math.round(volume) + '%';
            document.getElementById('gameVolumeFill').style.width = volume + '%';

            drawGameSpectrum();

            const peakEnergy = Math.max(...pattern);
            const avgEnergy = pattern.reduce((a, b) => a + b, 0) / pattern.length;
            const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;

            // Skip detection if playing back a recording
            if (isPlayingRecording) {
                return;
            }

            if (gamePatternBuffer.length === PATTERN_LENGTH) {
                const closestLetter = getClosestLetter();
                if (!closestLetter) return;

                const NASALS = ['M', 'N'];
                const FRICATIVES = ['F', 'S', 'V', 'Z', 'H'];
                const LIQUIDS = ['L', 'R'];
                const isNasal = NASALS.includes(closestLetter.letter);
                const isFricative = FRICATIVES.includes(closestLetter.letter);
                const isLiquid = LIQUIDS.includes(closestLetter.letter);

                let volumeThreshold = 15;
                let concentrationThreshold = 2.0;

                if (isNasal || isLiquid) {
                    volumeThreshold = 8;
                    concentrationThreshold = 1.3;
                } else if (isFricative) {
                    volumeThreshold = 10;
                    concentrationThreshold = 1.8;
                }

                if (volume > volumeThreshold && energyConcentration > concentrationThreshold) {
                    const results = testAllPlosiveStrategies(gamePatternBuffer, closestLetter.letter);
                    const result = results[0];
                    const score = Math.max(0, Math.min(100, result.score || 0));
                    const prediction = result.predictedLetter || '?';
                    const isCorrect = prediction === closestLetter.letter;

                    if (isCorrect && score > 80) {
                        handleCorrectMatch(closestLetter);
                    }
                }
            }
        }

        function drawGameSpectrum() {
            if (!gameSpectrumCanvas) return;

            const width = gameSpectrumCanvas.width;
            const height = gameSpectrumCanvas.height;

            gameSpectrumCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            gameSpectrumCtx.fillRect(0, 0, width, height);

            const barWidth = width / dataArray.length * 2.5;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * height;
                const hue = (i / dataArray.length) * 120 + 100;
                gameSpectrumCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                gameSpectrumCtx.fillRect(x, height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        function getClosestLetter() {
            if (fallingLetters.length === 0) return null;

            let closest = fallingLetters[0];
            let minDistance = closest.getDistance(gameCanvas.height);

            fallingLetters.forEach(letter => {
                const distance = letter.getDistance(gameCanvas.height);
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = letter;
                }
            });

            return closest;
        }

        function handleCorrectMatch(letter) {
            fallingLetters = fallingLetters.filter(l => l !== letter);
            gameScore++;
            gamePatternBuffer = [];

            if (gameScore % 10 === 0) {
                gameSpeed += 0.2;
            }

            updateGameUI();
            document.getElementById('gameStatus').textContent = `‚úì Got ${letter.letter}! +1`;

            setTimeout(() => {
                const closest = getClosestLetter();
                if (closest) {
                    document.getElementById('gameStatus').textContent = `Say: ${closest.letter}`;
                }
            }, 500);
        }

        function endGame() {
            gameRunning = false;
            document.getElementById('gameBtn').textContent = '‚ñ∂ Start Game';
            document.getElementById('gameStatus').textContent = `GAME OVER! Final Score: ${gameScore}`;

            gameCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

            gameCtx.fillStyle = '#F44336';
            gameCtx.font = 'bold 60px Arial';
            gameCtx.textAlign = 'center';
            gameCtx.fillText('GAME OVER', gameCanvas.width / 2, gameCanvas.height / 2 - 40);

            gameCtx.fillStyle = '#FDD835';
            gameCtx.font = 'bold 40px Arial';
            gameCtx.fillText(`Score: ${gameScore}`, gameCanvas.width / 2, gameCanvas.height / 2 + 20);
        }

        // ========== LEVEL 1 LEARNING GAME ==========

        const VOWELS_LEARNING = ['A', 'E', 'I', 'O', 'U'];
        let level1Running = false;
        let level1State = {
            phase: 'intro',
            currentVowelIndex: 0,
            repetition: 0,
            mode: 'listen',
            mixedRound: 0,
            learnedVowels: [],
            demoPattern: [],
            demoIndex: 0
        };
        let level1PatternBuffer = [];
        let level1Canvas, level1CanvasCtx;

        async function toggleLevel1() {
            if (level1Running) {
                stopLevel1();
            } else {
                if (!audioContext) {
                    await setupAudio();
                }
                startLevel1();
            }
        }

        function startLevel1() {
            level1Running = true;
            level1State = {
                phase: 'teach',
                currentVowelIndex: 0,
                repetition: 0,
                mode: 'listen',
                mixedRound: 0,
                learnedVowels: [],
                demoPattern: [],
                demoIndex: 0
            };
            level1PatternBuffer = [];

            level1Canvas = document.getElementById('level1SpectrumCanvas');
            level1CanvasCtx = level1Canvas.getContext('2d');
            level1Canvas.width = 800;
            level1Canvas.height = 120;

            document.getElementById('level1Btn').textContent = '‚è∏ Stop';

            nextLevel1Step();
            analyzeLevel1Audio();
        }

        function stopLevel1() {
            level1Running = false;
            document.getElementById('level1Btn').textContent = '‚ñ∂ Start Level 1';
            document.getElementById('level1Letter').textContent = '?';
            document.getElementById('level1Instruction').textContent = 'Stopped';
        }

        function nextLevel1Step() {
            if (!level1Running) return;

            const state = level1State;
            const currentLetter = VOWELS_LEARNING[state.currentVowelIndex];

            if (state.phase === 'teach') {
                if (state.mode === 'listen') {
                    if (state.repetition < 5) {
                        showLevel1Letter(currentLetter);
                        document.getElementById('level1Instruction').textContent = `üëÇ Listen: ${currentLetter}`;
                        document.getElementById('level1Mode').textContent = 'Listen';
                        document.getElementById('level1Progress').textContent = `${state.repetition + 1}/5`;

                        setTimeout(() => {
                            playPhonemeSound(currentLetter);
                            state.repetition++;
                            setTimeout(() => nextLevel1Step(), 1500);
                        }, 500);
                    } else {
                        state.repetition = 0;
                        state.mode = 'practice';
                        nextLevel1Step();
                    }
                } else if (state.mode === 'practice') {
                    if (state.repetition < 5) {
                        showLevel1Letter(currentLetter);
                        document.getElementById('level1Instruction').textContent = `üé§ Your turn! Say: ${currentLetter}`;
                        document.getElementById('level1Mode').textContent = 'Practice';
                        document.getElementById('level1Progress').textContent = `${state.repetition + 1}/5`;
                    } else {
                        state.learnedVowels.push(currentLetter);

                        if (state.learnedVowels.length >= 2) {
                            state.phase = 'demo';
                            state.demoPattern = generateMixedPattern(state.learnedVowels);
                            state.demoIndex = 0;
                            state.repetition = 0;
                            nextLevel1Step();
                        } else {
                            state.currentVowelIndex++;
                            if (state.currentVowelIndex >= VOWELS_LEARNING.length) {
                                completeLevel1();
                            } else {
                                state.repetition = 0;
                                state.mode = 'listen';
                                nextLevel1Step();
                            }
                        }
                    }
                }
            } else if (state.phase === 'demo') {
                if (state.demoIndex === 0) {
                    document.getElementById('level1Instruction').textContent = `üëÄ Watch! I'll show you the pattern first...`;
                }

                if (state.demoIndex < state.demoPattern.length) {
                    const letter = state.demoPattern[state.demoIndex];
                    showLevel1Letter(letter);
                    document.getElementById('level1Mode').textContent = 'Demo';

                    setTimeout(() => {
                        playPhonemeSound(letter);
                        state.demoIndex++;
                        setTimeout(() => nextLevel1Step(), 1500);
                    }, 500);
                } else {
                    state.phase = 'mixed';
                    state.mixedRound = 0;
                    state.repetition = 0;
                    nextLevel1Step();
                }
            } else if (state.phase === 'mixed') {
                if (state.mixedRound < 5) {
                    const letter = state.learnedVowels[state.repetition % state.learnedVowels.length];
                    showLevel1Letter(letter);
                    document.getElementById('level1Instruction').textContent = `üé§ Say: ${letter}`;
                    document.getElementById('level1Mode').textContent = 'Mixed';
                    document.getElementById('level1Progress').textContent = `Round ${state.mixedRound + 1}/5`;
                } else {
                    state.currentVowelIndex++;
                    if (state.currentVowelIndex >= VOWELS_LEARNING.length) {
                        completeLevel1();
                    } else {
                        state.phase = 'teach';
                        state.mode = 'listen';
                        state.repetition = 0;
                        nextLevel1Step();
                    }
                }
            }
        }

        function generateMixedPattern(vowels) {
            const pattern = [];
            for (let i = 0; i < vowels.length; i++) {
                pattern.push(vowels[i]);
                if (i < vowels.length - 1) {
                    pattern.push(vowels[i + 1]);
                }
            }
            return pattern;
        }

        function showLevel1Letter(letter) {
            const letterEl = document.getElementById('level1Letter');
            letterEl.textContent = letter;
            letterEl.classList.remove('fade-in');
            void letterEl.offsetWidth;
            letterEl.classList.add('fade-in');
        }

        function analyzeLevel1Audio() {
            if (!level1Running) return;
            requestAnimationFrame(analyzeLevel1Audio);

            analyser.getByteFrequencyData(dataArray);

            drawLevel1Spectrum();

            const pattern = downsampleFrequencies(dataArray, PATTERN_BINS);
            level1PatternBuffer.push(pattern);

            if (level1PatternBuffer.length > PATTERN_LENGTH) {
                level1PatternBuffer.shift();
            }

            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volume = (sum / dataArray.length / 128) * 100;

            const peakEnergy = Math.max(...pattern);
            const avgEnergy = pattern.reduce((a, b) => a + b, 0) / pattern.length;
            const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;

            if (level1State.phase === 'teach' && level1State.mode === 'practice' && level1PatternBuffer.length === PATTERN_LENGTH) {
                const targetLetter = VOWELS_LEARNING[level1State.currentVowelIndex];

                if (volume > 15 && energyConcentration > 2.0) {
                    const results = testAllPlosiveStrategies(level1PatternBuffer, targetLetter);
                    const result = results[0];
                    const score = Math.max(0, Math.min(100, result.score || 0));
                    const prediction = result.predictedLetter || '?';
                    const isCorrect = prediction === targetLetter;

                    document.getElementById('level1Status').textContent = `Prediction: ${prediction} | Score: ${Math.round(score)}%`;
                    document.getElementById('level1ConfidenceFill').style.width = score + '%';

                    if (isCorrect && score > 80) {
                        celebrateLevel1Match();
                        level1State.repetition++;
                        level1PatternBuffer = [];
                        setTimeout(() => nextLevel1Step(), 1000);
                    }
                }
            } else if (level1State.phase === 'mixed' && level1PatternBuffer.length === PATTERN_LENGTH) {
                const targetLetter = level1State.learnedVowels[level1State.repetition % level1State.learnedVowels.length];

                if (volume > 15 && energyConcentration > 2.0) {
                    const results = testAllPlosiveStrategies(level1PatternBuffer, targetLetter);
                    const result = results[0];
                    const score = Math.max(0, Math.min(100, result.score || 0));
                    const prediction = result.predictedLetter || '?';
                    const isCorrect = prediction === targetLetter;

                    document.getElementById('level1Status').textContent = `Prediction: ${prediction} | Score: ${Math.round(score)}%`;
                    document.getElementById('level1ConfidenceFill').style.width = score + '%';

                    if (isCorrect && score > 80) {
                        celebrateLevel1Match();
                        level1State.repetition++;
                        level1PatternBuffer = [];

                        if (level1State.repetition >= level1State.learnedVowels.length * 2) {
                            level1State.mixedRound++;
                            level1State.repetition = 0;
                        }

                        setTimeout(() => nextLevel1Step(), 1000);
                    }
                }
            }
        }

        function drawLevel1Spectrum() {
            if (!level1Canvas) return;

            const width = level1Canvas.width;
            const height = level1Canvas.height;

            level1CanvasCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            level1CanvasCtx.fillRect(0, 0, width, height);

            const barWidth = width / dataArray.length * 2.5;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * height;
                const hue = (i / dataArray.length) * 120 + 100;
                level1CanvasCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                level1CanvasCtx.fillRect(x, height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        function celebrateLevel1Match() {
            const letterEl = document.getElementById('level1Letter');

            // Play success sound
            if (audioContext) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.4);
            }

            // Exciting animation sequence
            letterEl.style.transition = 'all 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55)';

            // Bounce and color sequence
            letterEl.style.transform = 'scale(1.5) rotate(5deg)';
            letterEl.style.color = '#FDD835';

            setTimeout(() => {
                letterEl.style.transform = 'scale(1.3) rotate(-5deg)';
                letterEl.style.color = '#7CB342';
            }, 150);

            setTimeout(() => {
                letterEl.style.transform = 'scale(1.6) rotate(0deg)';
                letterEl.style.color = '#00BCD4';
            }, 300);

            setTimeout(() => {
                letterEl.style.transform = 'scale(1.2)';
                letterEl.style.color = '#FF5722';
            }, 450);

            setTimeout(() => {
                letterEl.style.transform = 'scale(1.4)';
                letterEl.style.color = '#9C27B0';
            }, 600);

            setTimeout(() => {
                letterEl.style.transition = 'all 0.3s ease-out';
                letterEl.style.transform = 'scale(1)';
                letterEl.style.color = '#FDD835';
            }, 800);

            // Create confetti particles
            createLevel1Confetti(letterEl);
        }

        function createLevel1Confetti(centerEl) {
            const container = centerEl.parentElement;
            const rect = centerEl.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const colors = ['#FDD835', '#7CB342', '#00BCD4', '#FF5722', '#9C27B0'];

            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.style.position = 'fixed';
                particle.style.left = centerX + 'px';
                particle.style.top = centerY + 'px';
                particle.style.width = '10px';
                particle.style.height = '10px';
                particle.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                particle.style.pointerEvents = 'none';
                particle.style.zIndex = '9999';

                document.body.appendChild(particle);

                const angle = (Math.PI * 2 * i) / 20;
                const velocity = 100 + Math.random() * 100;
                const vx = Math.cos(angle) * velocity;
                const vy = Math.sin(angle) * velocity;

                let x = 0, y = 0, time = 0;
                const gravity = 500;

                const animate = () => {
                    time += 0.016; // ~60fps
                    x = vx * time;
                    y = vy * time + 0.5 * gravity * time * time;

                    particle.style.transform = `translate(${x}px, ${y}px) rotate(${time * 360}deg)`;
                    particle.style.opacity = Math.max(0, 1 - time * 1.5);

                    if (time < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        particle.remove();
                    }
                };

                requestAnimationFrame(animate);
            }
        }

        function completeLevel1() {
            level1Running = false;
            document.getElementById('level1Letter').textContent = 'üéâ';
            document.getElementById('level1Instruction').textContent = 'Amazing! You completed Level 1!';
            document.getElementById('level1Btn').textContent = 'üîÑ Play Again';
        }

        // Initialize
        (async () => {
            // Set up auth state listener
            handleAuthStateChange();

            // Check if user is authenticated
            const { data: { session } } = await supabase.auth.getSession();

            if (session?.user) {
                // Authenticated user - load their profiles
                console.log('‚úÖ Authenticated user:', session.user.email);
                await loadUserProfiles(session.user.id);
            } else {
                // Guest user - check for named profile first, then guest profile
                const savedProfileName = localStorage.getItem('currentProfile');

                if (savedProfileName && savedProfileName !== 'Default') {
                    // Has a saved named profile - load it
                    console.log('üìù Loading named profile:', savedProfileName);
                    currentProfile = savedProfileName;

                    const profile = await getOrCreateProfile(savedProfileName);
                    if (profile) {
                        currentProfileId = profile.id;
                        console.log(`‚úÖ Loaded profile: ${savedProfileName} (${profile.id.substring(0, 8)}...)`);
                    }
                } else {
                    // No named profile - use anonymous guest system
                    console.log('üìù Guest mode - creating anonymous profile');

                    // Check if we have a saved guest profile ID
                    const savedGuestId = localStorage.getItem('guestProfileId');

                    if (savedGuestId) {
                        // Try to load existing guest profile
                        console.log('üîç Attempting to load saved guest profile:', savedGuestId);
                        try {
                            const { data: existingProfile, error } = await supabase
                                .from('profiles')
                                .select('*')
                                .eq('id', savedGuestId)
                                .is('user_id', null)
                                .single();

                            if (error) {
                                console.error('‚ùå Error loading guest profile:', error);
                                throw error;
                            }

                            if (existingProfile) {
                                currentProfileId = existingProfile.id;
                                guestProfileId = existingProfile.id;
                                console.log('‚úÖ Loaded existing guest profile:', existingProfile.id);
                            } else {
                                console.log('‚ö†Ô∏è Profile not found, creating new');
                                await createAnonymousProfile();
                            }
                        } catch (error) {
                            console.error('‚ö†Ô∏è Failed to load guest profile, creating new:', error.message);
                            await createAnonymousProfile();
                        }
                    } else {
                        // No saved profile - create new anonymous profile
                        console.log('üÜï No saved profile, creating new');
                        await createAnonymousProfile();
                    }
                }
            }

            // Load calibration data
            await loadCalibration();

            // Load profile dropdown
            loadProfiles();

            // Create calibration grid
            createCalibrationGrid();
            updateCalibrationStats();
        })();

        async function createAnonymousProfile() {
            try {
                const { data: newProfile, error } = await supabase
                    .from('profiles')
                    .insert([{
                        name: `Guest_${Date.now()}`,
                        user_id: null  // Explicitly anonymous
                    }])
                    .select()
                    .single();

                if (error) throw error;

                currentProfileId = newProfile.id;
                guestProfileId = newProfile.id;

                // Save to localStorage
                localStorage.setItem('guestProfileId', newProfile.id);

                console.log('‚úÖ Created anonymous profile:', newProfile.id);
            } catch (error) {
                console.error('‚ùå Error creating anonymous profile:', error);
                alert('Failed to initialize app. Please refresh the page.');
            }
        }

        // ===================================
        // PARTICLE SYSTEM FOR GAME EFFECTS
        // ===================================

        class Particle {
            constructor(x, y, color, size = null, vx = null, vy = null) {
                this.x = x;
                this.y = y;
                this.vx = vx !== null ? vx : (Math.random() - 0.5) * 10;
                this.vy = vy !== null ? vy : (Math.random() - 0.5) * 10;
                this.life = 1.0;
                this.color = color;
                this.size = size !== null ? size : (Math.random() * 6 + 3);
                this.gravity = 0.4;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.vx *= 0.98; // Air resistance
                this.life -= 0.02;
                this.rotation += this.rotationSpeed;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                ctx.restore();
            }
        }

        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            explode(x, y, colors, count = 30, speedMultiplier = 1) {
                for (let i = 0; i < count; i++) {
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    const angle = (Math.PI * 2 * i) / count;
                    const speed = (3 + Math.random() * 4) * speedMultiplier;
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    this.particles.push(new Particle(x, y, color, null, vx, vy));
                }
            }

            confetti(x, y, count = 50) {
                const colors = ['#FF6B6B', '#FDD835', '#4CAF50', '#2196F3', '#9C27B0', '#FF9800'];
                for (let i = 0; i < count; i++) {
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    const vx = (Math.random() - 0.5) * 15;
                    const vy = -Math.random() * 12 - 5; // Shoot upward
                    this.particles.push(new Particle(x, y, color, Math.random() * 8 + 4, vx, vy));
                }
            }

            sparkle(x, y, color, count = 15) {
                for (let i = 0; i < count; i++) {
                    const vx = (Math.random() - 0.5) * 6;
                    const vy = (Math.random() - 0.5) * 6;
                    this.particles.push(new Particle(x, y, color, Math.random() * 4 + 2, vx, vy));
                }
            }

            update() {
                this.particles.forEach(p => p.update());
                this.particles = this.particles.filter(p => p.life > 0);
            }

            draw(ctx) {
                this.particles.forEach(p => p.draw(ctx));
                ctx.globalAlpha = 1.0; // Reset alpha
            }
        }

        // ===================================
        // GAME MODE CONFIGURATIONS
        // ===================================

        const GAME_MODES = {
            1: { // Chill Mode
                name: "üê¢ Chill Mode",
                description: "Slow & relaxing - perfect for learning",
                speed: 1,
                spawnDelay: 3500,
                particleCount: 20,
                particleColors: ['#A5D6A7', '#C5E1A5', '#E6EE9C', '#FFF9C4'],
                particleSpeed: 0.7,
                screenShake: false,
                confettiOnMastery: false
            },
            2: { // Classic Mode
                name: "‚≠ê Classic Mode",
                description: "Default speed & effects",
                speed: 2,
                spawnDelay: 2500,
                particleCount: 30,
                particleColors: ['#7CB342', '#FDD835', '#FFEB3B', '#CDDC39'],
                particleSpeed: 1,
                screenShake: false,
                confettiOnMastery: false
            },
            3: { // Arcade Mode
                name: "üöÄ Arcade Mode",
                description: "Fast & exciting!",
                speed: 3.5,
                spawnDelay: 1800,
                particleCount: 50,
                particleColors: ['#FF6B6B', '#FDD835', '#4CAF50', '#2196F3'],
                particleSpeed: 1.4,
                screenShake: true,
                confettiOnMastery: true
            },
            4: { // Chaos Mode
                name: "üí• Chaos Mode",
                description: "SUPER FAST - for speed demons!",
                speed: 5,
                spawnDelay: 1200,
                particleCount: 80,
                particleColors: ['#F44336', '#E91E63', '#9C27B0', '#FF5722', '#FFEB3B'],
                particleSpeed: 2,
                screenShake: true,
                confettiOnMastery: true
            },
            5: { // Rainbow Mode
                name: "üåà Rainbow Mode",
                description: "Maximum visual satisfaction!",
                speed: 2.5,
                spawnDelay: 2200,
                particleCount: 60,
                particleColors: ['#FF6B6B', '#FF9800', '#FDD835', '#4CAF50', '#2196F3', '#9C27B0'],
                particleSpeed: 1.2,
                screenShake: false,
                confettiOnMastery: true
            }
        };

        let currentGameMode = 2; // Default to Classic

        function setGameMode(modeNumber) {
            currentGameMode = modeNumber;
            const mode = GAME_MODES[modeNumber];
            document.getElementById('currentModeDesc').textContent = `Current: ${mode.name} - ${mode.description}`;

            // If game is running, apply new settings immediately
            if (progressGame.running) {
                progressGame.spawnDelay = mode.spawnDelay;
            }

            console.log(`üéÆ Switched to ${mode.name}`);
        }

        // ===================================
        // PROGRESSIVE LEARNING GAME
        // ===================================

        // Particle system instance
        const particleSystem = new ParticleSystem();

        // Game state
        let progressGame = {
            running: false,
            currentLevel: 1,  // 1 = Listen+Hit, 2 = Listen+Choose, 3 = Say+Hit
            currentBatch: 0,  // Which batch of letters (0 = vowels, 1-4 = consonant groups)
            currentLetterIndex: 0,
            batches: [
                ['A', 'E', 'I', 'O', 'U'],  // Batch 0: Vowels
                ['B', 'C', 'D', 'F', 'G'],  // Batch 1: Consonants 1
                ['H', 'J', 'K', 'L', 'M'],  // Batch 2: Consonants 2
                ['N', 'P', 'Q', 'R', 'S'],  // Batch 3: Consonants 3
                ['T', 'V', 'W', 'X', 'Y', 'Z']  // Batch 4: Consonants 4
            ],
            letterProgress: {},  // {A: {level1: 5, level2: 3, level3: 0}, ...}
            hitsNeeded: 8,  // Number of successful hits to master a letter at current level
            score: 0,
            fallingLetters: [],
            canvas: null,
            ctx: null,
            animationFrame: null,
            lastSpawnTime: 0,
            spawnDelay: 2000,  // ms between spawns
            audioAnalysisFrame: null,
            patternBuffer: [],
            shakeIntensity: 0,  // Screen shake effect intensity
            // Auto-calibration state
            calibrationMode: false,
            calibrationRecordings: [],
            calibrationAudioClips: [],
            calibrationCount: 0,
            calibrationTarget: 5,
            currentRecorder: null
        };

        // Helper to get current batch letters
        function getCurrentBatchLetters() {
            return progressGame.batches[progressGame.currentBatch];
        }

        // Helper to get all alphabet letters
        function getAllLetters() {
            return progressGame.batches.flat();
        }

        // Initialize progress from localStorage
        function loadProgressGameData() {
            const saved = localStorage.getItem('progressGameData');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    progressGame.currentLevel = data.currentLevel || 1;
                    progressGame.currentBatch = data.currentBatch || 0;
                    progressGame.currentLetterIndex = data.currentLetterIndex || 0;
                    progressGame.letterProgress = data.letterProgress || {};
                    progressGame.score = data.score || 0;
                } catch (e) {
                    console.error('Error loading progress:', e);
                    initializeLetterProgress();
                }
            } else {
                initializeLetterProgress();
            }
            updateProgressUI();
        }

        function initializeLetterProgress() {
            progressGame.letterProgress = {};
            getAllLetters().forEach(letter => {
                progressGame.letterProgress[letter] = { level1: 0, level2: 0, level3: 0 };
            });
        }

        function saveProgressGameData() {
            const data = {
                currentLevel: progressGame.currentLevel,
                currentBatch: progressGame.currentBatch,
                currentLetterIndex: progressGame.currentLetterIndex,
                letterProgress: progressGame.letterProgress,
                score: progressGame.score
            };
            localStorage.setItem('progressGameData', JSON.stringify(data));
        }

        function toggleProgressGame() {
            if (progressGame.running) {
                stopProgressGame();
            } else {
                startProgressGame();
            }
        }

        async function startProgressGame() {
            if (!audioContext) {
                console.log('üé§ Setting up audio for the first time...');
                await setupAudio();
            }

            // Verify audio is working
            if (!analyser || !microphone) {
                console.error('‚ùå Audio not set up properly!');
                alert('Microphone not ready. Please allow microphone access and try again.');
                return;
            }

            console.log('‚úÖ Audio context ready:', audioContext.state);
            console.log('‚úÖ Analyser:', analyser);
            console.log('‚úÖ Microphone:', microphone);

            progressGame.running = true;
            progressGame.canvas = document.getElementById('progressGameCanvas');
            progressGame.ctx = progressGame.canvas.getContext('2d');
            progressGame.canvas.width = 500;
            progressGame.canvas.height = 600;

            document.getElementById('progressGameBtn').textContent = '‚è∏ Pause';
            updateProgressInstructions();
            updateProgressUI();

            // Check if current letter needs calibration
            const currentBatchLetters = getCurrentBatchLetters();
            const currentLetter = currentBatchLetters[progressGame.currentLetterIndex];
            const isCalibrated = calibrationData[currentLetter] !== undefined;

            if (!isCalibrated) {
                // Enter auto-calibration mode (voice-triggered)
                progressGame.calibrationMode = true;
                progressGame.calibrationRecordings = [];
                progressGame.calibrationAudioClips = [];
                progressGame.calibrationCount = 0;
                progressGame.currentRecorder = null;

                document.getElementById('progressStatus').textContent =
                    `üé§ Say "${currentLetter}" when you see it! (${progressGame.calibrationCount}/${progressGame.calibrationTarget})`;

                // Show skip button
                document.getElementById('skipCalibrationBtn').style.display = 'inline-block';
            } else {
                progressGame.calibrationMode = false;
                // Hide skip button
                document.getElementById('skipCalibrationBtn').style.display = 'none';
            }

            // Always start normal game mode (no overlay)
            progressGame.canvas.addEventListener('click', handleCanvasClick);
            gameLoop();

            // Start audio analysis for Level 3 OR for auto-calibration
            if (progressGame.currentLevel === 3 || progressGame.calibrationMode) {
                analyzeProgressAudio();
                // Show volume meter
                document.getElementById('volumeMeter').style.display = 'block';
            } else {
                // Hide volume meter
                document.getElementById('volumeMeter').style.display = 'none';
            }
        }

        function stopProgressGame() {
            progressGame.running = false;
            document.getElementById('progressGameBtn').textContent = '‚ñ∂ Start Game';

            if (progressGame.animationFrame) {
                cancelAnimationFrame(progressGame.animationFrame);
            }
            if (progressGame.audioAnalysisFrame) {
                cancelAnimationFrame(progressGame.audioAnalysisFrame);
            }

            // Stop any active recording
            if (progressGame.currentRecorder && progressGame.currentRecorder.state === 'recording') {
                progressGame.currentRecorder.stop();
                progressGame.currentRecorder = null;
            }

            progressGame.canvas.removeEventListener('click', handleCanvasClick);
            progressGame.fallingLetters = [];

            // Hide volume meter and skip button
            document.getElementById('volumeMeter').style.display = 'none';
            document.getElementById('skipCalibrationBtn').style.display = 'none';
        }

        function skipCalibration() {
            console.log('‚è≠ Skipping calibration - using clicks only');

            // Exit calibration mode
            progressGame.calibrationMode = false;
            progressGame.calibrationRecordings = [];
            progressGame.calibrationAudioClips = [];
            progressGame.calibrationCount = 0;

            // Hide skip button
            document.getElementById('skipCalibrationBtn').style.display = 'none';

            // Hide volume meter
            document.getElementById('volumeMeter').style.display = 'none';

            // Update status
            document.getElementById('progressStatus').textContent = 'üñ± Calibration skipped! Click letters to pop them.';

            // Stop audio analysis
            if (progressGame.audioAnalysisFrame) {
                cancelAnimationFrame(progressGame.audioAnalysisFrame);
                progressGame.audioAnalysisFrame = null;
            }

            updateProgressInstructions();
        }

        function resetProgressGame() {
            if (confirm('Are you sure you want to reset all progress? This cannot be undone.')) {
                localStorage.removeItem('progressGameData');
                progressGame.currentLevel = 1;
                progressGame.currentLetterIndex = 0;
                progressGame.score = 0;
                initializeLetterProgress();
                updateProgressUI();
                document.getElementById('progressStatus').textContent = 'Progress reset! Click Start to begin.';
            }
        }
        // ===================================
        // AUTO-CALIBRATION FUNCTIONS
        // ===================================

        function startVoiceRecording() {
            if (progressGame.currentRecorder) return; // Already recording

            const stream = microphone.mediaStream;
            const recorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
            const audioChunks = [];

            recorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };

            recorder.onstop = () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                progressGame.calibrationAudioClips.push(audioBlob);
                progressGame.currentRecorder = null;
            };

            recorder.start();
            progressGame.currentRecorder = recorder;
            console.log('üé§ Started recording for auto-calibration');
        }

        function stopVoiceRecording() {
            if (progressGame.currentRecorder && progressGame.currentRecorder.state === 'recording') {
                progressGame.currentRecorder.stop();
                console.log('üõë Stopped recording');
            }
        }

        async function finishAutoCalibration(letter) {
            document.getElementById('progressStatus').textContent = '‚ú® Processing your voice...';

            try {
                // Run clustering on patterns
                const cluster = findBestCluster(progressGame.calibrationRecordings);
                const baseline = averageSnapshots(cluster.cluster);

                // Find index of first pattern in cluster
                const bestIndex = cluster.indices[0];
                const bestAudioClip = progressGame.calibrationAudioClips[bestIndex];

                // Save to Supabase
                const success = await saveAutoCalibration(letter, baseline, bestAudioClip);

                if (success) {
                    document.getElementById('progressStatus').textContent = `‚úÖ Voice calibrated for ${letter}! Now tap to play!`;

                    // Update local calibration data
                    calibrationData[letter] = {
                        pattern: [baseline],
                        timestamp: Date.now()
                    };

                    // Switch to normal tap mode
                    progressGame.calibrationMode = false;
                    progressGame.calibrationRecordings = [];
                    progressGame.calibrationAudioClips = [];
                    progressGame.calibrationCount = 0;

                    // Continue game normally
                    updateProgressInstructions();
                } else {
                    document.getElementById('progressStatus').textContent = '‚ùå Save failed. Retrying...';
                    // Reset to try again
                    progressGame.calibrationRecordings = [];
                    progressGame.calibrationAudioClips = [];
                    progressGame.calibrationCount = 0;
                }
            } catch (error) {
                console.error('Auto-calibration error:', error);
                document.getElementById('progressStatus').textContent = '‚ùå Error occurred. Please try again.';
                // Reset to try again
                progressGame.calibrationRecordings = [];
                progressGame.calibrationAudioClips = [];
                progressGame.calibrationCount = 0;
            }
        }

        async function saveAutoCalibration(letter, baseline, audioBlob) {
            try {
                // Upload audio to Supabase Storage
                const filename = `${currentProfileId}/${letter}_${Date.now()}.webm`;
                const { data: uploadData, error: uploadError } = await supabase.storage
                    .from('calibration_audio')
                    .upload(filename, audioBlob, {
                        contentType: 'audio/webm',
                        upsert: false
                    });

                if (uploadError) throw uploadError;

                const audioUrl = `${SUPABASE_URL}/storage/v1/object/public/calibration_audio/${filename}`;

                // Save calibration to database
                const { data, error } = await supabase
                    .from('calibrations')
                    .upsert({
                        profile_id: currentProfileId,
                        letter: letter,
                        pattern: baseline,
                        audio_url: audioUrl,
                        calibration_method: 'auto',
                        updated_at: new Date().toISOString()
                    }, {
                        onConflict: 'profile_id,letter'
                    });

                if (error) throw error;

                console.log(`‚úÖ Auto-calibrated ${letter}`);
                return true;
            } catch (error) {
                console.error(`‚ùå Failed to save auto-calibration for ${letter}:`, error);
                return false;
            }
        }

        function gameLoop() {
            if (!progressGame.running) return;

            const now = Date.now();
            const { ctx, canvas } = progressGame;
            const mode = GAME_MODES[currentGameMode];

            // Apply screen shake if enabled
            let shakeX = 0, shakeY = 0;
            if (progressGame.shakeIntensity > 0) {
                shakeX = (Math.random() - 0.5) * progressGame.shakeIntensity;
                shakeY = (Math.random() - 0.5) * progressGame.shakeIntensity;
                progressGame.shakeIntensity *= 0.9; // Decay
                if (progressGame.shakeIntensity < 0.1) progressGame.shakeIntensity = 0;
            }

            ctx.save();
            ctx.translate(shakeX, shakeY);

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Spawn new letter if needed
            if (now - progressGame.lastSpawnTime > progressGame.spawnDelay) {
                spawnFallingLetter();
                progressGame.lastSpawnTime = now;
            }

            // Update and draw falling letters
            progressGame.fallingLetters = progressGame.fallingLetters.filter(letter => {
                letter.y += letter.speed;

                // Remove if off screen
                if (letter.y > canvas.height + 50) {
                    return false;
                }

                // Draw letter
                ctx.save();
                ctx.font = 'bold 80px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Highlight correct letter in Level 2
                if (progressGame.currentLevel === 2 && letter.isTarget) {
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#F44336';
                    ctx.fillStyle = '#FDD835';
                } else {
                    ctx.fillStyle = '#FDD835';
                }

                ctx.fillText(letter.letter, letter.x, letter.y);
                ctx.restore();

                return true;
            });

            // Update and draw particles
            particleSystem.update();
            particleSystem.draw(ctx);

            ctx.restore(); // Restore from screen shake transform

            progressGame.animationFrame = requestAnimationFrame(gameLoop);
        }

        function spawnFallingLetter() {
            const currentBatchLetters = getCurrentBatchLetters();
            const currentLetter = currentBatchLetters[progressGame.currentLetterIndex];
            const mode = GAME_MODES[currentGameMode];

            if (progressGame.currentLevel === 1) {
                // Level 1: Spawn only current letter
                const x = Math.random() * (progressGame.canvas.width - 100) + 50;
                const letter = {
                    letter: currentLetter,
                    x: x,
                    y: -50,
                    speed: mode.speed,
                    isTarget: true
                };
                progressGame.fallingLetters.push(letter);

                // Play audio for the letter
                playLetterAudio(currentLetter);

            } else if (progressGame.currentLevel === 2) {
                // Level 2: Spawn 2-3 letters, only one is correct
                const numLetters = Math.random() > 0.5 ? 3 : 2;
                const targetIndex = Math.floor(Math.random() * numLetters);

                // Get previously mastered letters from current batch for distractors
                const masteredLetters = currentBatchLetters.slice(0, progressGame.currentLetterIndex + 1);
                const availableLetters = masteredLetters.filter(l => l !== currentLetter);

                for (let i = 0; i < numLetters; i++) {
                    const isTarget = i === targetIndex;
                    const letterToSpawn = isTarget ? currentLetter :
                        availableLetters[Math.floor(Math.random() * availableLetters.length)] || currentLetter;

                    const x = (i + 1) * (progressGame.canvas.width / (numLetters + 1));
                    const letter = {
                        letter: letterToSpawn,
                        x: x,
                        y: -50 - (i * 100),  // Stagger vertically
                        speed: mode.speed,
                        isTarget: isTarget
                    };
                    progressGame.fallingLetters.push(letter);
                }

                // Play audio for the TARGET letter only
                playLetterAudio(currentLetter);

            } else if (progressGame.currentLevel === 3) {
                // Level 3: Spawn single letter, no audio (must say it)
                const x = Math.random() * (progressGame.canvas.width - 100) + 50;
                const letter = {
                    letter: currentLetter,
                    x: x,
                    y: -50,
                    speed: mode.speed,
                    isTarget: true
                };
                progressGame.fallingLetters.push(letter);
            }
        }

        function playLetterAudio(letter) {
            const phoneme = PHONEMES.find(p => p.letter === letter);
            if (phoneme && phoneme.audioUrl) {
                const audio = new Audio(phoneme.audioUrl);
                audio.volume = 0.7;
                audio.play().catch(e => console.log('Audio play failed:', e));
            }
        }

        function handleCanvasClick(event) {
            if (!progressGame.running) return;

            // In calibration mode, ignore clicks (voice-triggered only)
            if (progressGame.calibrationMode) return;

            const rect = progressGame.canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            // Scale to canvas coordinates
            const scaleX = progressGame.canvas.width / rect.width;
            const scaleY = progressGame.canvas.height / rect.height;
            const x = clickX * scaleX;
            const y = clickY * scaleY;

            // Check if clicked on any letter
            for (let i = progressGame.fallingLetters.length - 1; i >= 0; i--) {
                const letter = progressGame.fallingLetters[i];
                const dx = x - letter.x;
                const dy = y - letter.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 50) {  // Hit radius
                    handleLetterHit(letter, i);
                    break;
                }
            }
        }

        function handleLetterHit(letter, index) {
            const currentBatchLetters = getCurrentBatchLetters();
            const currentLetter = currentBatchLetters[progressGame.currentLetterIndex];
            const isCorrect = (progressGame.currentLevel === 2) ? letter.isTarget : (letter.letter === currentLetter);

            if (isCorrect) {
                // Remove the letter
                progressGame.fallingLetters.splice(index, 1);

                // Create explosion effect
                createProgressExplosion(letter.x, letter.y);

                // Update progress
                const levelKey = `level${progressGame.currentLevel}`;
                progressGame.letterProgress[currentLetter][levelKey]++;
                progressGame.score += 10;

                // Check if letter is mastered at this level
                if (progressGame.letterProgress[currentLetter][levelKey] >= progressGame.hitsNeeded) {
                    letterMasteredAtLevel(currentLetter);
                }

                updateProgressUI();
                saveProgressGameData();
            } else {
                // Wrong letter clicked
                document.getElementById('progressStatus').textContent = `‚ùå That's ${letter.letter}, not ${currentLetter}!`;
                setTimeout(() => updateProgressInstructions(), 1500);
            }
        }

        function createProgressExplosion(x, y) {
            const mode = GAME_MODES[currentGameMode];

            // Create particle explosion based on current mode
            particleSystem.explode(x, y, mode.particleColors, mode.particleCount, mode.particleSpeed);

            // Apply screen shake if mode has it enabled
            if (mode.screenShake) {
                progressGame.shakeIntensity = 15;
            }
        }

        function letterMasteredAtLevel(letter) {
            const levelKey = `level${progressGame.currentLevel}`;
            const currentBatchLetters = getCurrentBatchLetters();
            const batchNames = ['Vowels (A,E,I,O,U)', 'Consonants 1 (B,C,D,F,G)', 'Consonants 2 (H,J,K,L,M)',
                               'Consonants 3 (N,P,Q,R,S)', 'Consonants 4 (T,V,W,X,Y,Z)'];
            const mode = GAME_MODES[currentGameMode];

            document.getElementById('progressStatus').textContent =
                `üéâ ${letter} mastered at Level ${progressGame.currentLevel}!`;

            // Show confetti if mode enables it
            if (mode.confettiOnMastery) {
                particleSystem.confetti(progressGame.canvas.width / 2, progressGame.canvas.height / 2, 80);
            }

            // Move to next letter in current batch
            progressGame.currentLetterIndex++;

            if (progressGame.currentLetterIndex >= currentBatchLetters.length) {
                // All letters in batch done at this level
                if (progressGame.currentLevel < 3) {
                    // Move to next level with same batch
                    progressGame.currentLevel++;
                    progressGame.currentLetterIndex = 0;
                    document.getElementById('progressStatus').textContent =
                        `üèÜ ${batchNames[progressGame.currentBatch]} - Level ${progressGame.currentLevel - 1} Complete! Moving to Level ${progressGame.currentLevel}!`;

                    // Start voice analysis for Level 3
                    if (progressGame.currentLevel === 3 && !progressGame.audioAnalysisFrame) {
                        analyzeProgressAudio();
                    }
                } else {
                    // Level 3 complete for this batch!
                    if (progressGame.currentBatch < progressGame.batches.length - 1) {
                        // Move to next batch
                        progressGame.currentBatch++;
                        progressGame.currentLevel = 1;
                        progressGame.currentLetterIndex = 0;
                        document.getElementById('progressStatus').textContent =
                            `üéä ${batchNames[progressGame.currentBatch - 1]} COMPLETE! Unlocking ${batchNames[progressGame.currentBatch]}!`;
                    } else {
                        // ALL BATCHES COMPLETE!
                        stopProgressGame();
                        document.getElementById('progressStatus').textContent =
                            `üéä CONGRATULATIONS! You've mastered ALL 26 letters at ALL 3 levels! üéä`;
                        return;
                    }
                }
            }

            updateProgressInstructions();
            updateProgressUI();
            saveProgressGameData();
        }

        function updateProgressInstructions() {
            const currentBatchLetters = getCurrentBatchLetters();
            const currentLetter = currentBatchLetters[progressGame.currentLetterIndex];
            const batchNames = ['Vowels', 'Consonants 1', 'Consonants 2', 'Consonants 3', 'Consonants 4'];

            if (progressGame.currentLevel === 1) {
                document.getElementById('progressGameTitle').textContent = `üéÆ Level 1: Listen & Hit - ${batchNames[progressGame.currentBatch]}`;
                document.getElementById('progressGameInstructions').textContent =
                    `Listen to the sound and TAP the letter ${currentLetter} when it falls!`;
                document.getElementById('progressStatus').textContent =
                    `üéß Listen for "${currentLetter}" and tap it!`;
            } else if (progressGame.currentLevel === 2) {
                document.getElementById('progressGameTitle').textContent = `üéØ Level 2: Listen & Choose - ${batchNames[progressGame.currentBatch]}`;
                document.getElementById('progressGameInstructions').textContent =
                    `Multiple letters fall - TAP the one that matches the sound you hear!`;
                document.getElementById('progressStatus').textContent =
                    `üéß Which letter makes the sound? Tap ${currentLetter}!`;
            } else if (progressGame.currentLevel === 3) {
                document.getElementById('progressGameTitle').textContent = `üé§ Level 3: Say & Hit - ${batchNames[progressGame.currentBatch]}`;
                document.getElementById('progressGameInstructions').textContent =
                    `SAY the letter sound out loud, then TAP it!`;
                document.getElementById('progressStatus').textContent =
                    `üé§ Say "${currentLetter}" and tap it!`;
            }
        }

        function updateProgressUI() {
            // Exit early if Progressive Game DOM elements don't exist (happens when Game tab uses Tuner layout)
            if (!document.getElementById('currentLevel') || !document.getElementById('progressLetterGrid')) {
                return;
            }

            const currentBatchLetters = getCurrentBatchLetters();
            const allLetters = getAllLetters();

            document.getElementById('currentLevel').textContent = progressGame.currentLevel;
            document.getElementById('currentLetterDisplay').textContent =
                currentBatchLetters[progressGame.currentLetterIndex] || '‚úì';
            document.getElementById('progressScore').textContent = progressGame.score;

            // Count mastered letters across all batches
            let level1Count = 0, level2Count = 0, level3Count = 0;
            allLetters.forEach(letter => {
                const progress = progressGame.letterProgress[letter];
                if (progress) {
                    if (progress.level1 >= progressGame.hitsNeeded) level1Count++;
                    if (progress.level2 >= progressGame.hitsNeeded) level2Count++;
                    if (progress.level3 >= progressGame.hitsNeeded) level3Count++;
                }
            });

            document.getElementById('lettersMastered').textContent = level1Count + level2Count + level3Count;
            document.getElementById('level1Progress').textContent = `${level1Count}/26`;
            document.getElementById('level2Progress').textContent = `${level2Count}/26`;
            document.getElementById('level3Progress').textContent = `${level3Count}/26`;

            // Update letter grid - show all letters
            const grid = document.getElementById('progressLetterGrid');
            grid.innerHTML = '';
            allLetters.forEach(letter => {
                const badge = document.createElement('div');
                badge.className = 'progress-letter-badge';
                badge.textContent = letter;

                const progress = progressGame.letterProgress[letter];
                if (progress) {
                    if (progress.level3 >= progressGame.hitsNeeded) {
                        badge.classList.add('level3');
                    } else if (progress.level2 >= progressGame.hitsNeeded) {
                        badge.classList.add('level2');
                    } else if (progress.level1 >= progressGame.hitsNeeded) {
                        badge.classList.add('level1');
                    }
                }

                grid.appendChild(badge);
            });
        }

        // COPIED FROM TUNER - PROVEN TO WORK!
        function analyzeProgressAudio() {
            // Run for Level 3 OR calibration mode
            if (!progressGame.running || (progressGame.currentLevel !== 3 && !progressGame.calibrationMode)) {
                return;
            }

            if (!analyser || !dataArray) {
                console.error('‚ùå No analyser or dataArray!');
                return;
            }

            analyser.getByteFrequencyData(dataArray);

            // Calculate volume (same as Tuner)
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volumePercent = (sum / dataArray.length / 128) * 100;
            const volume = Math.max(...dataArray); // Peak volume for detection

            // Update volume meter
            const volumeBar = document.getElementById('volumeBar');
            const micStatus = document.getElementById('micStatus');
            const volumeDebug = document.getElementById('volumeDebug');

            if (volumeBar) {
                volumeBar.style.width = volumePercent + '%';
            }

            if (volumeDebug) {
                volumeDebug.textContent = `Volume: ${Math.round(volume)}/255 (${Math.round(volumePercent)}%)`;
            }

            // Update mic status indicator
            if (micStatus) {
                if (volume > 80) {
                    micStatus.textContent = '‚óè VOICE DETECTED';
                    micStatus.style.color = '#F44336';
                } else if (volume > 40) {
                    micStatus.textContent = '‚óè SPEAKING';
                    micStatus.style.color = '#FDD835';
                } else if (volume > 10) {
                    micStatus.textContent = '‚óè AMBIENT';
                    micStatus.style.color = '#2196F3';
                } else {
                    micStatus.textContent = '‚óè LISTENING';
                    micStatus.style.color = '#4CAF50';
                }
            }

            // ALWAYS add current frame to buffer (sliding window) - SAME AS TUNER
            const pattern = downsampleFrequencies(dataArray, PATTERN_BINS);
            progressGame.patternBuffer.push(pattern);

            // Keep buffer at PATTERN_LENGTH
            if (progressGame.patternBuffer.length > PATTERN_LENGTH) {
                progressGame.patternBuffer.shift();
            }

            // Check energy concentration (speech vs background noise)
            const peakEnergy = Math.max(...pattern);
            const avgEnergy = pattern.reduce((a, b) => a + b, 0) / pattern.length;
            const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;

            const currentBatchLetters = getCurrentBatchLetters();
            const currentLetter = currentBatchLetters[progressGame.currentLetterIndex];

            // Dynamic thresholds (COPIED FROM TUNER)
            const FRICATIVES = ['F', 'S', 'V', 'Z', 'H'];
            const LIQUIDS = ['L', 'R'];
            const isCurrentNasal = currentLetter && isNasal(currentLetter);
            const isFricative = currentLetter && FRICATIVES.includes(currentLetter);
            const isLiquid = currentLetter && LIQUIDS.includes(currentLetter);

            let volumeThreshold = 15;
            let concentrationThreshold = 2.0;

            if (isCurrentNasal || isLiquid) {
                volumeThreshold = 8;
                concentrationThreshold = 1.5;
            } else if (isFricative) {
                volumeThreshold = 10;
                concentrationThreshold = 1.8;
            }

            // ===== AUTO-CALIBRATION MODE (voice-triggered explosions) =====
            if (progressGame.calibrationMode && currentLetter) {
                // Use Tuner's detection logic!
                if (progressGame.patternBuffer.length === PATTERN_LENGTH &&
                    volume > volumeThreshold &&
                    energyConcentration > concentrationThreshold &&
                    !progressGame.currentRecorder) {

                    // Voice detected! Start recording
                    const pattern = extractPattern(dataArray);
                    progressGame.calibrationRecordings.push(pattern);

                    startVoiceRecording();

                    // Find closest letter and trigger explosion
                    let closestLetter = null;
                    let closestIndex = -1;
                    let minDist = Infinity;

                    progressGame.fallingLetters.forEach((letter, index) => {
                        if (letter.letter === currentLetter) {
                            const centerDist = Math.abs(letter.y - progressGame.canvas.height / 2);
                            if (centerDist < minDist) {
                                minDist = centerDist;
                                closestLetter = letter;
                                closestIndex = index;
                            }
                        }
                    });

                    if (closestLetter && closestIndex !== -1) {
                        // Remove the letter
                        progressGame.fallingLetters.splice(closestIndex, 1);

                        // Create explosion effect
                        createProgressExplosion(closestLetter.x, closestLetter.y);

                        // Continue recording for 700ms, then stop
                        setTimeout(() => {
                            stopVoiceRecording();

                            progressGame.calibrationCount++;
                            console.log(`‚úÖ Recorded ${progressGame.calibrationCount}/${progressGame.calibrationTarget}`);

                            document.getElementById('progressStatus').textContent =
                                `üé§ Great! Say "${currentLetter}" again! (${progressGame.calibrationCount}/${progressGame.calibrationTarget})`;

                            if (progressGame.calibrationCount >= progressGame.calibrationTarget) {
                                // Done! Process calibrations
                                setTimeout(() => finishAutoCalibration(currentLetter), 500);
                            }
                        }, 700);
                    }
                }
            }
            // ===== LEVEL 3 MODE (normal voice recognition) - COPIED FROM TUNER =====
            else if (progressGame.currentLevel === 3 && currentLetter && !progressGame.calibrationMode) {
                // Same detection logic as Tuner!
                if (progressGame.patternBuffer.length === PATTERN_LENGTH &&
                    volume > volumeThreshold &&
                    energyConcentration > concentrationThreshold) {

                    // Run S11-Snapshot detection (same as Tuner)
                    const results = testAllPlosiveStrategies(progressGame.patternBuffer, currentLetter);
                    const result = results[0];
                    const score = Math.max(0, Math.min(100, result.score || 0));
                    const prediction = result.predictedLetter || '?';
                    const isCorrect = prediction === currentLetter;

                    // Success if predicted correctly AND score > 80%
                    if (isCorrect && score > 80) {
                        console.log(`üéØ MATCH! ${currentLetter} detected with ${Math.round(score)}% confidence`);

                        // Find closest falling letter
                        let closestLetter = null;
                        let closestIndex = -1;
                        let minDist = Infinity;

                        progressGame.fallingLetters.forEach((letter, index) => {
                            if (letter.letter === currentLetter) {
                                const centerDist = Math.abs(letter.y - progressGame.canvas.height / 2);
                                if (centerDist < minDist) {
                                    minDist = centerDist;
                                    closestLetter = letter;
                                    closestIndex = index;
                                }
                            }
                        });

                        if (closestLetter && closestIndex !== -1) {
                            // Remove letter and trigger explosion!
                            progressGame.fallingLetters.splice(closestIndex, 1);
                            createProgressExplosion(closestLetter.x, closestLetter.y);

                            // Update progress (same as clicking)
                            const levelKey = `level${progressGame.currentLevel}`;
                            progressGame.letterProgress[currentLetter][levelKey]++;
                            progressGame.score += 10;

                            // Check if letter is mastered
                            if (progressGame.letterProgress[currentLetter][levelKey] >= progressGame.hitsNeeded) {
                                letterMasteredAtLevel(currentLetter);
                            }

                            updateProgressUI();
                            saveProgressGameData();
                        }

                        // Clear buffer after successful match
                        progressGame.patternBuffer = [];
                    }
                }
            }

            progressGame.audioAnalysisFrame = requestAnimationFrame(analyzeProgressAudio);
        }

        // Initialize on load
        loadProgressGameData();
    </script>
</body>
</html>
