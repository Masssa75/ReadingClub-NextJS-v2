<!--
    ReadingClub v1.4.0

    Version 1.4 Changes:
    - Removed localStorage fallback for calibration data (Supabase-only)
    - Removed localStorage audio storage (Supabase Storage-only)
    - Audio playback now uses Supabase public URLs
    - Fresh start: no migration from old localStorage data
    - Added Google OAuth + Magic Link authentication
    - Anonymous profiles created on first visit (zero friction)
    - Optional signup after 3 letters calibrated
    - Guest profiles automatically linked to auth account on signup

    Data Storage:
    ‚úÖ Supabase Database: calibration patterns + metadata + user accounts
    ‚úÖ Supabase Storage: audio recordings (WebM)
    ‚úÖ Supabase Auth: Google OAuth + Magic Link email
    ‚úÖ localStorage: guest profile ID + attempt history only

    User Flow:
    1. First visit ‚Üí Anonymous Supabase profile created automatically
    2. Start calibrating immediately (zero friction)
    3. After 3 letters ‚Üí Optional signup prompt (dismissible)
    4. On signup ‚Üí Guest profile linked to authenticated account
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ReadingClub - Learn Phonics with Your Voice</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
            color: white;
        }
        h1 {
            font-size: 48px;
            margin: 20px 0;
            text-shadow: 0 0 20px rgba(124, 179, 66, 0.8);
        }
        .subtitle {
            font-size: 16px;
            color: #ddd;
            margin-bottom: 20px;
        }
        .container {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 30px;
            padding: 40px;
            width: 900px;
            max-width: 95vw;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }
        .tab {
            padding: 15px 30px;
            background: transparent;
            border: none;
            color: #aaa;
            font-size: 18px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        .tab.active {
            color: #FDD835;
            border-bottom-color: #FDD835;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        /* Calibration */
        .calibration-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .phoneme-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
        }
        .phoneme-card:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        .phoneme-card.recording {
            border-color: #F44336;
            background: rgba(244, 67, 54, 0.2);
            animation: pulse 1s infinite;
        }
        .phoneme-card.calibrated {
            border-color: #7CB342;
            background: rgba(124, 179, 66, 0.2);
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }
        .phoneme-letter {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .phoneme-hint {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 5px;
        }
        .phoneme-status {
            font-size: 12px;
            margin-top: 10px;
        }

        /* Snapshot thumbnails */
        .snapshots-container {
            display: flex;
            gap: 4px;
            margin-top: 10px;
            justify-content: center;
            min-height: 40px;
        }
        .snapshot-thumb {
            width: 50px;
            height: 40px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            border: 1px solid rgba(124, 179, 66, 0.3);
        }
        .snapshot-thumb.captured {
            border-color: #7CB342;
        }

        /* Pattern visualization */
        .pattern-preview {
            width: 100%;
            height: 60px;
            margin-top: 10px;
            border-radius: 5px;
            overflow: hidden;
        }

        /* Tuner */
        #detectedLetter {
            text-align: center;
            font-size: 180px;
            font-weight: bold;
            color: #7CB342;
            margin: 30px 0;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 10px 30px rgba(124, 179, 66, 0.5);
            transition: all 0.15s;
        }
        #detectedLetter.active {
            transform: scale(1.1);
            color: #FDD835;
            text-shadow: 0 0 50px rgba(253, 216, 53, 0.8);
        }
        .confidence-bar {
            width: 100%;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }
        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #7CB342, #FDD835);
            width: 0%;
            transition: width 0.1s;
        }
        #spectrumCanvas {
            width: 100%;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 20px 0;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            font-size: 14px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #FDD835;
        }
        .btn {
            padding: 12px 30px;
            background: #7CB342;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn:hover {
            background: #689F38;
        }
        .actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        .info-box {
            background: rgba(124, 179, 66, 0.1);
            border-left: 4px solid #7CB342;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            font-size: 14px;
            line-height: 1.6;
        }
        #status {
            text-align: center;
            font-size: 14px;
            color: #999;
            margin: 15px 0;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        .level1-letter {
            text-align: center;
            font-size: 180px;
            font-weight: bold;
            color: #FDD835;
            margin: 30px 0;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 10px 30px rgba(253, 216, 53, 0.5);
        }
        .level1-instruction {
            text-align: center;
            font-size: 24px;
            color: #ddd;
            margin: 20px 0;
            min-height: 40px;
        }

        /* Calibration Modal */
        .calibration-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        .calibration-modal.active {
            display: flex;
        }
        .modal-content {
            background: rgba(30, 30, 30, 0.98);
            border-radius: 30px;
            padding: 40px;
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            border: 3px solid #7CB342;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            position: relative;
        }
        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            font-size: 24px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
        }
        .modal-close:hover {
            background: rgba(255, 67, 54, 0.3);
            transform: rotate(90deg);
        }
        .modal-instructions {
            text-align: center;
            color: #ddd;
            font-size: 16px;
            margin-bottom: 20px;
        }
        .modal-letter-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        .modal-letter {
            font-size: 180px;
            font-weight: bold;
            color: #FDD835;
            cursor: pointer;
            display: inline-block;
            text-shadow: 0 10px 30px rgba(253, 216, 53, 0.5);
            transition: all 0.15s;
            text-align: center;
        }
        .modal-letter:hover {
            transform: scale(1.1);
        }
        .modal-listen-icon {
            width: 60px;
            height: 60px;
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.2s;
            filter: drop-shadow(0 2px 8px rgba(253, 216, 53, 0.4));
        }
        .modal-listen-icon:hover {
            opacity: 1;
            transform: scale(1.15);
        }
        .modal-listen-icon svg {
            width: 100%;
            height: 100%;
            fill: #FDD835;
        }
        .modal-captures {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 30px;
        }
        .modal-capture-box {
            width: 100px;
            height: 80px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(124, 179, 66, 0.3);
            border-radius: 10px;
            transition: all 0.3s;
            position: relative;
        }
        .modal-capture-box.ready {
            border-color: #FDD835;
            box-shadow: 0 0 15px rgba(253, 216, 53, 0.5);
            animation: pulse 1.5s infinite;
        }
        .modal-capture-box.recording {
            border-color: #F44336;
            background: rgba(244, 67, 54, 0.2);
            animation: pulse 0.8s infinite;
        }
        .modal-capture-box.captured {
            border-color: #7CB342;
            background: rgba(124, 179, 66, 0.1);
        }
        .modal-capture-box canvas {
            width: 100%;
            height: 100%;
        }
        .mic-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .modal-capture-box.ready .mic-icon {
            opacity: 0.7;
        }
        .mic-icon svg {
            width: 100%;
            height: 100%;
            fill: #FDD835;
            filter: drop-shadow(0 0 5px rgba(253, 216, 53, 0.5));
        }
        .click-arrow {
            position: absolute;
            bottom: 90px;
            left: 50px;
            display: none;
            animation: arrowHover 2s ease-in-out infinite, arrowPulse 1.5s ease-in-out infinite;
        }
        .click-arrow.active {
            display: block;
        }
        .click-arrow svg {
            width: 50px;
            height: 50px;
            filter: drop-shadow(0 2px 10px rgba(124, 179, 66, 0.8));
        }
        @keyframes arrowHover {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        @keyframes arrowPulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        .modal-status {
            text-align: center;
            color: #ddd;
            font-size: 18px;
            margin-top: 20px;
        }
        .modal-next-button {
            display: none;
            margin: 30px auto 0;
            width: 80px;
            height: 80px;
            background: #7CB342;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(124, 179, 66, 0.5);
            animation: nextButtonPulse 1.5s ease-in-out infinite;
        }
        .modal-next-button.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-next-button:hover {
            transform: scale(1.1);
            background: #8BC34A;
            box-shadow: 0 6px 20px rgba(124, 179, 66, 0.7);
        }
        .modal-next-button svg {
            width: 40px;
            height: 40px;
            fill: white;
        }
        @keyframes nextButtonPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Progressive Learning Game */
        .progress-letter-badge {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: #999;
        }
        .progress-letter-badge.level1 {
            background: rgba(124, 179, 66, 0.3);
            border-color: #7CB342;
            color: #7CB342;
        }
        .progress-letter-badge.level2 {
            background: rgba(253, 216, 53, 0.3);
            border-color: #FDD835;
            color: #FDD835;
        }
        .progress-letter-badge.level3 {
            background: rgba(244, 67, 54, 0.3);
            border-color: #F44336;
            color: #F44336;
        }
        @keyframes letterPop {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        @keyframes explosionBurst {
            0% { transform: scale(0.5) rotate(0deg); opacity: 1; }
            100% { transform: scale(3) rotate(720deg); opacity: 0; }
        }

        /* Letter Smash Game */
        .smash-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            overflow: hidden;
        }
        .smash-letter {
            position: absolute;
            font-size: 120px;
            font-weight: bold;
            color: #FDD835;
            text-shadow: 0 0 30px rgba(253, 216, 53, 0.8);
            animation: smashPop 0.3s ease-out;
            cursor: pointer;
            user-select: none;
        }
        @keyframes smashPop {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .smash-explosion {
            position: absolute;
            font-size: 80px;
            animation: explode 0.6s ease-out forwards;
            pointer-events: none;
        }
        @keyframes explode {
            0% { transform: scale(1) rotate(0deg); opacity: 1; }
            100% { transform: scale(3) rotate(360deg); opacity: 0; }
        }
        .combo-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 48px;
            font-weight: bold;
            color: #F44336;
            text-shadow: 0 0 20px rgba(244, 67, 54, 0.8);
            animation: comboScale 0.3s ease-out;
        }
        @keyframes comboScale {
            0% { transform: scale(0.5); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* Treasure Hunt Game */
        .treasure-map {
            width: 100%;
            height: 600px;
            background: linear-gradient(135deg, #3a3a2a 0%, #2a2a1a 100%);
            border-radius: 20px;
            position: relative;
            overflow-y: auto;
            padding: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 15px;
            align-content: start;
        }
        .treasure-chest {
            width: 80px;
            height: 80px;
            background: rgba(139, 69, 19, 0.4);
            border: 3px solid rgba(139, 69, 19, 0.6);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        .treasure-chest:hover {
            transform: scale(1.1);
        }
        .treasure-chest.locked {
            border-color: rgba(139, 69, 19, 0.8);
            animation: chestWiggle 2s ease-in-out infinite;
        }
        .treasure-chest.unlocked {
            background: rgba(253, 216, 53, 0.3);
            border-color: #FDD835;
            box-shadow: 0 0 20px rgba(253, 216, 53, 0.5);
        }
        .treasure-chest.current {
            border-color: #F44336;
            box-shadow: 0 0 30px rgba(244, 67, 54, 0.8);
            animation: chestPulse 1s ease-in-out infinite;
        }
        @keyframes chestWiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-2deg); }
            75% { transform: rotate(2deg); }
        }
        @keyframes chestPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }
        .chest-letter {
            font-size: 32px;
            font-weight: bold;
            color: #FDD835;
        }
        .chest-icon {
            font-size: 24px;
            position: absolute;
            bottom: 5px;
        }
        .coin-shower {
            position: absolute;
            font-size: 24px;
            animation: coinFall 1s ease-out forwards;
            pointer-events: none;
        }
        @keyframes coinFall {
            0% { transform: translateY(-50px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100px) rotate(720deg); opacity: 0; }
        }

        /* Beat the Clock Game */
        .clock-container {
            text-align: center;
        }
        .clock-timer {
            font-size: 72px;
            font-weight: bold;
            color: #FDD835;
            text-shadow: 0 0 30px rgba(253, 216, 53, 0.8);
            margin: 30px 0;
        }
        .clock-timer.warning {
            color: #F44336;
            animation: timerPulse 0.5s ease-in-out infinite;
        }
        @keyframes timerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .clock-letter {
            font-size: 180px;
            font-weight: bold;
            color: #FDD835;
            text-shadow: 0 10px 30px rgba(253, 216, 53, 0.5);
            margin: 40px 0;
            transition: all 0.2s;
        }
        .clock-letter.success {
            color: #7CB342;
            transform: scale(1.2);
        }
        .clock-progress {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 30px 0;
        }
        .clock-progress-dot {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #999;
        }
        .clock-progress-dot.completed {
            background: rgba(124, 179, 66, 0.3);
            border-color: #7CB342;
            color: #7CB342;
        }
        .clock-progress-dot.current {
            background: rgba(253, 216, 53, 0.3);
            border-color: #FDD835;
            color: #FDD835;
            animation: dotPulse 1s ease-in-out infinite;
        }
        @keyframes dotPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
    </style>

    <!-- Supabase Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // Initialize Supabase client
        const SUPABASE_URL = 'https://eyrcioeihiaisjwnalkz.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImV5cmNpb2VpaGlhaXNqd25hbGt6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI3NDg0MDUsImV4cCI6MjA3ODMyNDQwNX0.Tj1_XyrC5XsnKtekYop_dWuCdng1hXHHVWqzjr3vJJQ';
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        console.log('‚úÖ Supabase client initialized');

        // ======================
        // Authentication Functions
        // ======================

        let currentUser = null;
        let guestProfileId = null; // Store guest profile ID in localStorage

        async function sendMagicLink() {
            const emailInput = document.getElementById('emailInput');
            const email = emailInput.value.trim();

            if (!email || !email.includes('@')) {
                alert('Please enter a valid email address');
                return;
            }

            try {
                const { error } = await supabase.auth.signInWithOtp({
                    email: email,
                    options: {
                        emailRedirectTo: window.location.origin
                    }
                });

                if (error) throw error;

                closeAuthModal();
                alert(`‚úÖ Magic link sent to ${email}!\n\nCheck your inbox and click the link to sign in.`);
                emailInput.value = '';
            } catch (error) {
                console.error('‚ùå Magic link error:', error);
                alert('Failed to send magic link. Please try again.');
            }
        }

        async function signOut() {
            try {
                const { error } = await supabase.auth.signOut();
                if (error) throw error;

                currentUser = null;
                location.reload(); // Refresh to reset to guest mode
            } catch (error) {
                console.error('‚ùå Sign out error:', error);
            }
        }

        function openAuthModal() {
            document.getElementById('authModal').style.display = 'flex';
        }

        function closeAuthModal() {
            document.getElementById('authModal').style.display = 'none';
        }

        async function linkGuestToAuthUser(userId) {
            // Link the current guest profile to the authenticated user
            if (!guestProfileId) {
                console.log('No guest profile to link');
                return;
            }

            try {
                const { error } = await supabase
                    .from('profiles')
                    .update({ user_id: userId })
                    .eq('id', guestProfileId);

                if (error) throw error;

                console.log('‚úÖ Guest profile linked to authenticated user');
                guestProfileId = null; // Clear guest ID
                localStorage.removeItem('guestProfileId');
            } catch (error) {
                console.error('‚ùå Error linking guest profile:', error);
            }
        }

        async function handleAuthStateChange() {
            // Listen for auth state changes
            supabase.auth.onAuthStateChange(async (event, session) => {
                console.log('Auth state changed:', event, session?.user?.email);

                if (session?.user) {
                    currentUser = session.user;

                    // Show user info
                    document.getElementById('userEmail').textContent = `‚úÖ ${session.user.email}`;
                    document.getElementById('userInfo').style.display = 'block';
                    document.getElementById('saveProgressBtn').style.display = 'none';

                    // Link guest profile if exists
                    await linkGuestToAuthUser(session.user.id);

                    // Load user's profiles
                    await loadUserProfiles(session.user.id);
                } else {
                    currentUser = null;
                    document.getElementById('userInfo').style.display = 'none';
                    document.getElementById('saveProgressBtn').style.display = 'inline-block';
                }
            });

            // Check current session
            const { data: { session } } = await supabase.auth.getSession();
            if (session?.user) {
                currentUser = session.user;
                document.getElementById('userEmail').textContent = `‚úÖ ${session.user.email}`;
                document.getElementById('userInfo').style.display = 'block';
                document.getElementById('saveProgressBtn').style.display = 'none';
            } else {
                document.getElementById('saveProgressBtn').style.display = 'inline-block';
            }
        }

        async function loadUserProfiles(userId) {
            try {
                const { data: profiles, error } = await supabase
                    .from('profiles')
                    .select('*')
                    .eq('user_id', userId);

                if (error) throw error;

                console.log(`‚úÖ Loaded ${profiles.length} profiles for user`);

                // Update UI with user's profiles
                // This will be integrated with existing profile management
            } catch (error) {
                console.error('‚ùå Error loading user profiles:', error);
            }
        }
    </script>
</head>
<body>
    <h1>üìö ReadingClub</h1>
    <div class="subtitle">Learn phonics with your voice - real-time sound recognition</div>

    <!-- Authentication Modal -->
    <div id="authModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; align-items: center; justify-content: center;">
        <div style="background: #2c3e50; padding: 30px; border-radius: 10px; max-width: 400px; text-align: center;">
            <div style="margin-bottom: 20px; color: #ddd; font-size: 20px;">
                üíæ Save your progress
            </div>
            <div style="margin-bottom: 20px; color: #aaa; font-size: 14px;">
                Get a magic link via email to save your calibrations across devices
            </div>
            <input
                id="emailInput"
                type="email"
                placeholder="your@email.com"
                style="
                    width: 100%;
                    padding: 12px 20px;
                    font-size: 16px;
                    border-radius: 5px;
                    background: rgba(255,255,255,0.1);
                    color: white;
                    border: 1px solid #555;
                    margin-bottom: 15px;
                    box-sizing: border-box;
                "
            />
            <button onclick="sendMagicLink()" style="
                width: 100%;
                padding: 12px 30px;
                background: #7CB342;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
                margin-bottom: 10px;
            ">
                Send Magic Link
            </button>
            <button onclick="closeAuthModal()" style="
                width: 100%;
                padding: 8px 20px;
                background: transparent;
                color: #999;
                border: 1px solid #555;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
            ">
                Cancel
            </button>
        </div>
    </div>

    <!-- User Info (when signed in) -->
    <div id="userInfo" style="text-align: center; margin: 20px 0; padding: 15px; background: rgba(124, 179, 66, 0.2); border-radius: 10px; display: none;">
        <span id="userEmail" style="color: #7CB342; margin-right: 15px;"></span>
        <button onclick="signOut()" style="
            padding: 8px 20px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        ">
            Sign Out
        </button>
    </div>

    <!-- Profile Selector -->
    <div style="text-align: center; margin: 20px 0; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 10px;">
        <label style="color: #aaa; margin-right: 10px;">üë§ Profile:</label>
        <select id="profileSelect" onchange="switchProfile()" style="padding: 8px 15px; font-size: 16px; border-radius: 5px; background: #2a2a2a; color: white; border: 1px solid #555;">
        </select>
        <button onclick="createNewProfile()" style="margin-left: 10px; padding: 8px 15px; background: #7CB342; color: white; border: none; border-radius: 5px; cursor: pointer;">‚ûï New Profile</button>
        <button id="saveProgressBtn" onclick="openAuthModal()" style="margin-left: 10px; padding: 8px 15px; background: #5A9; color: white; border: none; border-radius: 5px; cursor: pointer; display: none;">üíæ Save Progress</button>
    </div>

    <!-- Calibration Modal -->
    <div id="calibrationModal" class="calibration-modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeCalibrationModal()">‚úï</button>

            <!-- Instructions -->
            <div class="modal-instructions">
                Click the letter to hear its sound. Click each box below to record 5 sounds.
            </div>

            <!-- Big Letter Display -->
            <div class="modal-letter-container">
                <div id="modalLetter" class="modal-letter" onclick="playModalLetterSound()">A</div>
                <div class="modal-listen-icon" onclick="playModalLetterSound()" title="Click to hear sound">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                    </svg>
                </div>
            </div>

            <!-- 5 Capture Boxes -->
            <div class="modal-captures" style="position: relative;">
                <!-- Green arrow indicator -->
                <div class="click-arrow" id="clickArrow">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 4L12 20M12 20L5 13M12 20L19 13" stroke="#7CB342" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
                    </svg>
                </div>

                <div class="modal-capture-box" id="modalCaptureBox0">
                    <div class="mic-icon">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2C10.9 2 10 2.9 10 4V12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12V4C14 2.9 13.1 2 12 2Z"/>
                            <path d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"/>
                        </svg>
                    </div>
                    <canvas id="modalCaptureCanvas0" width="100" height="80"></canvas>
                </div>
                <div class="modal-capture-box" id="modalCaptureBox1">
                    <div class="mic-icon">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2C10.9 2 10 2.9 10 4V12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12V4C14 2.9 13.1 2 12 2Z"/>
                            <path d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"/>
                        </svg>
                    </div>
                    <canvas id="modalCaptureCanvas1" width="100" height="80"></canvas>
                </div>
                <div class="modal-capture-box" id="modalCaptureBox2">
                    <div class="mic-icon">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2C10.9 2 10 2.9 10 4V12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12V4C14 2.9 13.1 2 12 2Z"/>
                            <path d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"/>
                        </svg>
                    </div>
                    <canvas id="modalCaptureCanvas2" width="100" height="80"></canvas>
                </div>
                <div class="modal-capture-box" id="modalCaptureBox3">
                    <div class="mic-icon">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2C10.9 2 10 2.9 10 4V12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12V4C14 2.9 13.1 2 12 2Z"/>
                            <path d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"/>
                        </svg>
                    </div>
                    <canvas id="modalCaptureCanvas3" width="100" height="80"></canvas>
                </div>
                <div class="modal-capture-box" id="modalCaptureBox4">
                    <div class="mic-icon">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2C10.9 2 10 2.9 10 4V12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12V4C14 2.9 13.1 2 12 2Z"/>
                            <path d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"/>
                        </svg>
                    </div>
                    <canvas id="modalCaptureCanvas4" width="100" height="80"></canvas>
                </div>
            </div>

            <!-- Status Message -->
            <div id="modalStatus" class="modal-status">Click letter to hear sound, then start saying it!</div>

            <!-- Next Button (shown after calibration complete) -->
            <div id="modalNextButton" class="modal-next-button" onclick="goToNextLetter()">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"/>
                </svg>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="tabs">
            <button class="tab active" onclick="switchTab('calibrate')">üìä Calibrate</button>
            <button class="tab" onclick="switchTab('level1')">üéì Level 1</button>
            <button class="tab" onclick="switchTab('tuner')">üéØ Tuner</button>
            <button class="tab" onclick="switchTab('game')">üéÆ Game</button>
        </div>

        <!-- Calibration Tab -->
        <div id="calibrate" class="tab-content active">
            <div class="info-box">
                <strong>Pattern-Based Calibration</strong><br>
                Say each phoneme 3-4 times while recording. The system captures the actual waveform pattern (like a fingerprint).<br>
                This preserves the SHAPE of the sound, not just statistics.
            </div>

            <div class="calibration-grid" id="calibrationGrid"></div>

            <div class="actions">
                <button class="btn" onclick="resetCalibration()">üîÑ Reset All</button>
                <button class="btn" onclick="exportCalibration()">üíæ Export Calibration</button>
            </div>

            <div id="calibrationStats" style="margin-top: 20px; text-align: center; color: #aaa;"></div>
        </div>

        <!-- Level 1 Tab -->
        <div id="level1" class="tab-content">
            <div class="info-box">
                <strong>üéì Level 1: Listen & Learn</strong><br>
                Learn the vowels A, E, I, O, U by listening and practicing!
            </div>

            <div class="level1-instruction" id="level1Instruction">
                Click START to begin!
            </div>

            <div class="level1-letter" id="level1Letter">?</div>

            <div class="confidence-bar">
                <div class="confidence-fill" id="level1ConfidenceFill"></div>
            </div>

            <div class="stats">
                <div class="stat-item">
                    <div>Progress</div>
                    <div class="stat-value" id="level1Progress">0/5</div>
                </div>
                <div class="stat-item">
                    <div>Mode</div>
                    <div class="stat-value" id="level1Mode">Listen</div>
                </div>
            </div>

            <canvas id="level1SpectrumCanvas" style="width: 100%; height: 120px; background: rgba(0, 0, 0, 0.3); border-radius: 10px; margin: 20px 0;"></canvas>

            <div id="level1Status" style="font-family: monospace; font-size: 11px; white-space: pre-wrap; line-height: 1.4; text-align: center; margin: 20px 0;">Ready to start</div>

            <div class="actions">
                <button class="btn" id="level1Btn" onclick="toggleLevel1()">‚ñ∂ Start Level 1</button>
            </div>
        </div>

        <!-- Tuner Tab (Elimination Game) -->
        <div id="tuner" class="tab-content">
            <div style="text-align: center; margin-bottom: 20px; color: #ddd; font-size: 18px;">
                Say this sound:
                <span onclick="playCalibrationRecording()" style="cursor: pointer; font-size: 24px; margin-left: 10px; display: inline-block; opacity: 0.7; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'" title="Play my recording">üîä</span>
            </div>

            <div style="text-align: center; margin-bottom: 15px;">
                <label style="color: #ddd; cursor: pointer;">
                    <input type="checkbox" id="alphabetMode" onchange="toggleAlphabetMode()" style="margin-right: 5px;">
                    Alphabet Test Mode (A‚ÜíZ loop)
                </label>
                <span id="alphabetProgress" style="margin-left: 15px; color: #FDD835; display: none;"></span>
            </div>

            <div id="targetLetter" style="text-align: center; font-size: 180px; font-weight: bold; color: #FDD835; margin: 20px 0; text-shadow: 0 10px 30px rgba(253, 216, 53, 0.5); transition: all 0.3s;">?</div>

            <div class="confidence-bar">
                <div class="confidence-fill" id="confidenceFill"></div>
            </div>

            <div class="stats">
                <div class="stat-item">
                    <div>Match Score</div>
                    <div class="stat-value" id="matchScore">0%</div>
                </div>
                <div class="stat-item">
                    <div>Volume</div>
                    <div class="stat-value" id="volume">0%</div>
                </div>
            </div>

            <canvas id="spectrumCanvas"></canvas>

            <div id="status" style="font-family: monospace; font-size: 11px; white-space: pre-wrap; line-height: 1.4;">Click Start to begin</div>

            <div class="actions">
                <button class="btn" id="tunerBtn" onclick="toggleTuner()">‚ñ∂ Start Game</button>
                <button class="btn" onclick="tryAgain()" style="background: #7CB342; display: none;" id="tryAgainBtn">üîÑ Try Again</button>
                <button class="btn" onclick="skipLetter()" style="background: #999;">Skip</button>
            </div>

            <div class="actions" style="margin-top: 15px;">
                <button class="btn" onclick="viewStats()" style="background: #5E35B1;">üìä View Stats (<span id="trialsCount">0</span> trials)</button>
                <button class="btn" onclick="exportResults()" style="background: #00897B;">üíæ Export Results</button>
            </div>
        </div>

        <!-- Game Tab -->
        <div id="game" class="tab-content">
            <div class="info-box">
                <strong id="progressGameTitle">üéÆ Progressive Learning Game</strong><br>
                <span id="progressGameInstructions">Starting with Level 1: Listen and tap the letters!</span>
            </div>

            <div style="text-align: center; margin: 20px 0;">
                <div style="display: inline-block; margin: 0 20px;">
                    <div style="color: #aaa; font-size: 14px;">Current Level</div>
                    <div style="color: #FDD835; font-size: 42px; font-weight: bold;" id="currentLevel">1</div>
                </div>
                <div style="display: inline-block; margin: 0 20px;">
                    <div style="color: #aaa; font-size: 14px;">Current Letter</div>
                    <div style="color: #7CB342; font-size: 42px; font-weight: bold;" id="currentLetterDisplay">A</div>
                </div>
                <div style="display: inline-block; margin: 0 20px;">
                    <div style="color: #aaa; font-size: 14px;">Letters Mastered</div>
                    <div style="color: #FDD835; font-size: 42px; font-weight: bold;"><span id="lettersMastered">0</span>/26</div>
                </div>
                <div style="display: inline-block; margin: 0 20px;">
                    <div style="color: #aaa; font-size: 14px;">Score</div>
                    <div style="color: #F44336; font-size: 42px; font-weight: bold;" id="progressScore">0</div>
                </div>
            </div>

            <canvas id="progressGameCanvas" style="width: 500px; height: 600px; background: rgba(0,0,0,0.3); border-radius: 20px; display: block; margin: 20px auto; cursor: pointer;"></canvas>

            <div style="text-align: center; margin-top: 20px; color: #ddd; font-size: 18px; min-height: 40px;" id="progressStatus">Click Start to begin your learning journey!</div>

            <div class="actions">
                <button class="btn" id="progressGameBtn" onclick="toggleProgressGame()">‚ñ∂ Start Game</button>
                <button class="btn" onclick="resetProgressGame()" style="background: #F44336;">üîÑ Reset Progress</button>
            </div>

            <div style="margin-top: 30px; padding: 20px; background: rgba(0, 0, 0, 0.3); border-radius: 15px;">
                <div style="color: #FDD835; font-size: 18px; font-weight: bold; margin-bottom: 15px;">üìä Your Progress</div>
                <div style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;">
                    <div style="text-align: center;">
                        <div style="color: #aaa; font-size: 14px;">Level 1 Complete</div>
                        <div style="color: #7CB342; font-size: 24px; font-weight: bold;" id="level1Progress">0/26</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="color: #aaa; font-size: 14px;">Level 2 Complete</div>
                        <div style="color: #7CB342; font-size: 24px; font-weight: bold;" id="level2Progress">0/26</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="color: #aaa; font-size: 14px;">Level 3 Complete</div>
                        <div style="color: #7CB342; font-size: 24px; font-weight: bold;" id="level3Progress">0/26</div>
                    </div>
                </div>
                <div id="progressLetterGrid" style="display: flex; gap: 5px; flex-wrap: wrap; justify-content: center; margin-top: 20px;"></div>
            </div>
        </div>
    </div>

    <script>
        let audioContext;
        let analyser;
        let microphone;
        let mediaRecorder;
        let audioChunks = [];
        let dataArray;
        let isRunning = false;
        let isRecording = false;
        let recordingPhoneme = null;
        let recordedPatterns = [];
        let calibrationData = {};
        let audioRecordings = {};

        const canvas = document.getElementById('spectrumCanvas');
        const canvasCtx = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = 240;

        // Full phoneme list - All 26 letters in alphabetical order
        const PHONEMES = [
            { letter: 'A', hint: 'Say: aaa (like "apple")', type: 'vowel', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-a.mp3' },
            { letter: 'B', hint: 'Repeat: buh, buh', type: 'plosive', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-b.mp3' },
            { letter: 'C', hint: 'Repeat: cuh, cuh (like "cat")', type: 'plosive', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-c.mp3' },
            { letter: 'D', hint: 'Repeat: duh, duh (like "dog")', type: 'plosive', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-d.mp3' },
            { letter: 'E', hint: 'Say: eee (like "egg")', type: 'vowel', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-e.mp3' },
            { letter: 'F', hint: 'Say: fff (like "fan")', type: 'fricative', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-f.mp3' },
            { letter: 'G', hint: 'Repeat: guh, guh (like "go")', type: 'plosive', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-g.mp3' },
            { letter: 'H', hint: 'Say: hhh (like "hat")', type: 'fricative', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-h.mp3' },
            { letter: 'I', hint: 'Say: iii (like "igloo")', type: 'vowel', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-i.mp3' },
            { letter: 'J', hint: 'Say: juh (like "jump")', type: 'affricate', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-j.mp3' },
            { letter: 'K', hint: 'Repeat: kuh, kuh', type: 'plosive', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-k.mp3' },
            { letter: 'L', hint: 'Say: lll (like "lion")', type: 'liquid', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-l.mp3' },
            { letter: 'M', hint: 'Say: mmm (hum)', type: 'nasal', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-m.mp3' },
            { letter: 'N', hint: 'Say: nnn (like "no")', type: 'nasal', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-n.mp3' },
            { letter: 'O', hint: 'Say: ooo (like "octopus")', type: 'vowel', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-o-sh.mp3' },
            { letter: 'P', hint: 'Repeat: puh, puh', type: 'plosive', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-p-2.mp3' },
            { letter: 'Q', hint: 'Say: kwuh (like "queen")', type: 'affricate', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-q.mp3' },
            { letter: 'R', hint: 'Say: rrr (like "run")', type: 'liquid', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-r.mp3' },
            { letter: 'S', hint: 'Say: sss (like "snake")', type: 'fricative', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-z.mp3' },
            { letter: 'T', hint: 'Repeat: tuh, tuh', type: 'plosive', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-t.mp3' },
            { letter: 'U', hint: 'Say: uuu (like "umbrella")', type: 'vowel', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-u-sh.mp3' },
            { letter: 'V', hint: 'Say: vvv (like "van")', type: 'fricative', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-v.mp3' },
            { letter: 'W', hint: 'Say: www (like "water")', type: 'semivowel', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-w.mp3' },
            { letter: 'X', hint: 'Say: ks (like "fox")', type: 'affricate', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-x.mp3' },
            { letter: 'Y', hint: 'Say: yuh (like "yes")', type: 'semivowel', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/btalpha-i-long.mp3' },
            { letter: 'Z', hint: 'Say: zzz (like "zoo")', type: 'fricative', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-z.mp3' }
        ];

        // ======================
        // Supabase Helper Functions
        // ======================

        let currentProfileId = null; // Store the current profile's UUID

        async function getOrCreateProfile(profileName) {
            try {
                // Try to find existing profile by name (get the most recent one if multiple exist)
                const { data: existingProfiles, error: fetchError } = await supabase
                    .from('profiles')
                    .select('*')
                    .eq('name', profileName)
                    .is('user_id', null) // Only get anonymous profiles
                    .order('created_at', { ascending: false })
                    .limit(1);

                if (fetchError) throw fetchError;

                if (existingProfiles && existingProfiles.length > 0) {
                    console.log(`‚úÖ Found existing profile: ${profileName} (${existingProfiles[0].id.substring(0, 8)}...)`);
                    return existingProfiles[0];
                }

                // Create new profile if not found
                const { data: newProfile, error: createError } = await supabase
                    .from('profiles')
                    .insert([{ name: profileName }])
                    .select()
                    .single();

                if (createError) throw createError;

                console.log(`‚úÖ Created new profile: ${profileName} (${newProfile.id.substring(0, 8)}...)`);
                return newProfile;
            } catch (error) {
                console.error('‚ùå Error with profile:', error);
                return null;
            }
        }

        async function saveCalibrationToSupabase(letter, patternData, audioBlob) {
            if (!currentProfileId) {
                console.error('‚ùå No profile selected');
                return false;
            }

            try {
                const startTime = Date.now();
                let audioUrl = null;

                // Upload audio to Supabase Storage if provided
                if (audioBlob) {
                    const blobSizeKB = (audioBlob.size / 1024).toFixed(2);
                    console.log(`üì§ Uploading audio: ${blobSizeKB} KB`);

                    const audioFileName = `${currentProfileId}/${letter}_${Date.now()}.webm`;

                    const uploadStart = Date.now();
                    const { data: uploadData, error: uploadError } = await supabase.storage
                        .from('calibration-audio')
                        .upload(audioFileName, audioBlob, {
                            contentType: 'audio/webm'
                        });
                    const uploadTime = Date.now() - uploadStart;
                    console.log(`‚è±Ô∏è Upload took: ${uploadTime}ms`);

                    if (uploadError) {
                        console.error('‚ùå Audio upload error:', uploadError);
                        // Continue without audio if upload fails
                    } else {
                        // Get public URL
                        const { data: { publicUrl } } = supabase.storage
                            .from('calibration-audio')
                            .getPublicUrl(audioFileName);
                        audioUrl = publicUrl;
                        console.log('‚úÖ Audio uploaded:', audioUrl);
                    }
                }

                // Save calibration data to database
                console.log('üíæ Saving to database...');
                const dbStart = Date.now();
                const { data, error } = await supabase
                    .from('calibrations')
                    .upsert({
                        profile_id: currentProfileId,
                        letter: letter,
                        pattern_data: patternData,
                        audio_url: audioUrl,
                        updated_at: new Date().toISOString()
                    }, {
                        onConflict: 'profile_id,letter'
                    })
                    .select();
                const dbTime = Date.now() - dbStart;
                console.log(`‚è±Ô∏è Database save took: ${dbTime}ms`);

                if (error) throw error;

                const totalTime = Date.now() - startTime;
                console.log(`‚úÖ Saved calibration for letter ${letter} (total: ${totalTime}ms)`);
                return audioUrl; // Return the audio URL so it can be stored locally
            } catch (error) {
                console.error('‚ùå Error saving calibration:', error);
                alert(`Failed to save calibration: ${error.message}`);
                return null;
            }
        }

        async function loadCalibrationsFromSupabase() {
            if (!currentProfileId) {
                console.error('‚ùå No profile selected');
                return {};
            }

            try {
                const { data, error } = await supabase
                    .from('calibrations')
                    .select('*')
                    .eq('profile_id', currentProfileId);

                if (error) throw error;

                // Convert to the format expected by the app
                const calibrations = {};
                data.forEach(cal => {
                    calibrations[cal.letter] = {
                        pattern: cal.pattern_data.pattern || [cal.pattern_data],
                        timestamp: new Date(cal.created_at).getTime(),
                        audioUrl: cal.audio_url
                    };
                });

                console.log(`‚úÖ Loaded ${Object.keys(calibrations).length} calibrations from Supabase`);
                return calibrations;
            } catch (error) {
                console.error('‚ùå Error loading calibrations:', error);
                return {};
            }
        }

        const PLOSIVES = ['B', 'C', 'D', 'G', 'K', 'P', 'T'];
        const NASALS = ['M', 'N'];

        function isPlosive(letter) {
            return PLOSIVES.includes(letter);
        }

        function isNasal(letter) {
            return NASALS.includes(letter);
        }

        // Pattern matching parameters
        const PATTERN_LENGTH = 30; // Number of frequency snapshots
        const PATTERN_BINS = 64;   // Number of frequency bins per snapshot

        // Profile management
        let currentProfile = 'Default';

        function loadProfiles() {
            const saved = localStorage.getItem('phonicsProfiles');
            const profiles = saved ? JSON.parse(saved) : ['Default'];

            const select = document.getElementById('profileSelect');
            select.innerHTML = '';

            profiles.forEach(profile => {
                const option = document.createElement('option');
                option.value = profile;
                option.textContent = profile;
                if (profile === currentProfile) {
                    option.selected = true;
                }
                select.appendChild(option);
            });

            return profiles;
        }

        function saveProfiles(profiles) {
            localStorage.setItem('phonicsProfiles', JSON.stringify(profiles));
        }

        async function switchProfile() {
            const select = document.getElementById('profileSelect');
            currentProfile = select.value;
            localStorage.setItem('currentProfile', currentProfile);

            // Clear guest profile ID since we're using a named profile
            localStorage.removeItem('guestProfileId');
            guestProfileId = null;

            // Get or create profile in Supabase by name
            const profile = await getOrCreateProfile(currentProfile);
            if (profile) {
                currentProfileId = profile.id;
                console.log(`‚úÖ Switched to profile: ${currentProfile} (${profile.id.substring(0, 8)}...)`);
            }

            // Load calibration for this profile
            await loadCalibration();
            createCalibrationGrid();
            updateCalibrationStats();
        }

        async function createNewProfile() {
            const name = prompt('Enter profile name (e.g., "Ophelia", "Rey", "Marc"):');
            if (!name || name.trim() === '') return;

            const profiles = loadProfiles();
            if (profiles.includes(name.trim())) {
                alert('Profile already exists!');
                return;
            }

            profiles.push(name.trim());
            saveProfiles(profiles);
            currentProfile = name.trim();
            localStorage.setItem('currentProfile', currentProfile);

            // Clear guest profile ID
            localStorage.removeItem('guestProfileId');
            guestProfileId = null;

            // Create profile in Supabase
            const profile = await getOrCreateProfile(currentProfile);
            if (profile) {
                currentProfileId = profile.id;
                console.log(`‚úÖ Created new profile: ${currentProfile} (${profile.id.substring(0, 8)}...)`);
            }

            // Clear calibration for new profile
            calibrationData = {};

            loadProfiles();
            await loadCalibration();
            createCalibrationGrid();
            updateCalibrationStats();
        }

        async function loadCalibration() {
            // Load ONLY from Supabase (no localStorage fallback)
            if (currentProfileId) {
                const supabaseData = await loadCalibrationsFromSupabase();
                calibrationData = supabaseData;
                updateCalibrationUI();
            } else {
                calibrationData = {};
                console.warn('‚ö†Ô∏è No profile ID - waiting for Supabase profile initialization');
            }
        }

        function createCalibrationGrid() {
            const grid = document.getElementById('calibrationGrid');
            grid.innerHTML = '';

            PHONEMES.forEach(phoneme => {
                const card = document.createElement('div');
                card.className = 'phoneme-card';
                card.id = `card-${phoneme.letter}`;

                const isCalibrated = calibrationData[phoneme.letter];
                if (isCalibrated) {
                    card.classList.add('calibrated');
                }

                card.innerHTML = `
                    <div class="phoneme-letter">${phoneme.letter}</div>
                    <div class="phoneme-hint">${phoneme.hint}</div>
                    ${phoneme.audioUrl ? `<div style="font-size: 30px; cursor: pointer; margin: 5px 0;" onclick="event.stopPropagation(); playPhonemeSound('${phoneme.letter}')" title="Listen to sound">üîä</div>` : ''}
                    <div class="snapshots-container" id="snapshots-${phoneme.letter}"></div>
                    <div class="phoneme-status">${isCalibrated ? '‚úì Calibrated' : 'Click to record'}</div>
                `;

                card.onclick = () => openCalibrationModal(phoneme.letter);
                grid.appendChild(card);
            });
        }

        let capturedSnapshots = [];
        let lastPeakTime = 0;
        const SNAPSHOTS_NEEDED = 5;
        const PEAK_COOLDOWN = 500; // ms between peaks

        async function startCalibrationRecording(letter) {
            if (isRecording) return;

            if (!audioContext) {
                await setupAudio();
            }

            isRecording = true;
            recordingPhoneme = letter;
            capturedSnapshots = [];
            audioChunks = [];
            lastPeakTime = 0;

            // DISABLED: Audio recording takes too much localStorage space
            // if (microphone && microphone.stream) {
            //     mediaRecorder = new MediaRecorder(microphone.stream);
            //     mediaRecorder.ondataavailable = (event) => {
            //         if (event.data.size > 0) {
            //             audioChunks.push(event.data);
            //         }
            //     };
            //     mediaRecorder.start();
            // }

            const card = document.getElementById(`card-${letter}`);
            card.classList.add('recording');
            card.querySelector('.phoneme-status').textContent = `Say "${letter}" - 0/${SNAPSHOTS_NEEDED} captured`;

            // Create snapshot thumbnail canvases
            const snapshotsContainer = document.getElementById(`snapshots-${letter}`);
            snapshotsContainer.innerHTML = '';
            for (let i = 0; i < SNAPSHOTS_NEEDED; i++) {
                const canvas = document.createElement('canvas');
                canvas.className = 'snapshot-thumb';
                canvas.width = 50;
                canvas.height = 40;
                canvas.id = `snapshot-${letter}-${i}`;
                snapshotsContainer.appendChild(canvas);
            }

            // Start listening for peaks
            listenForPeaks(letter);
        }

        function listenForPeaks(letter) {
            if (!isRecording || recordingPhoneme !== letter) {
                if (!isRecording) console.log('Stopped listening: isRecording = false');
                if (recordingPhoneme !== letter) console.log(`Stopped listening: letter mismatch (${recordingPhoneme} vs ${letter})`);
                return;
            }

            analyser.getByteFrequencyData(dataArray);

            // Calculate current volume
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volume = (sum / dataArray.length / 128) * 100;

            // SOLUTION 1: Dynamic volume threshold for nasals
            const volumeThreshold = isNasal(letter) ? 8 : 15;

            // Detect peak (loud moment after cooldown)
            const now = Date.now();
            if (volume > volumeThreshold && (now - lastPeakTime) > PEAK_COOLDOWN) {
                // SNAP! Capture this peak moment
                let snapshot = downsampleFrequencies(dataArray, PATTERN_BINS);

                // SOLUTION 5: Check energy concentration for nasals
                const peakEnergy = Math.max(...snapshot);
                const avgEnergy = snapshot.reduce((a, b) => a + b, 0) / snapshot.length;
                const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;
                const concentrationThreshold = isNasal(letter) ? 1.5 : 2.0;

                // Skip if energy too diffuse (likely background noise)
                if (energyConcentration < concentrationThreshold) {
                    requestAnimationFrame(() => listenForPeaks(letter));
                    return;
                }

                // SOLUTION 3: Pre-amplify nasal sounds before normalization
                if (isNasal(letter)) {
                    snapshot = snapshot.map(v => v * 2.0);
                }

                // Normalize to 0-1 range
                const maxVal = Math.max(...snapshot);
                const normalized = snapshot.map(v => v / maxVal);

                capturedSnapshots.push(normalized);
                const snapshotIndex = capturedSnapshots.length - 1;
                lastPeakTime = now;

                console.log(`Captured snapshot ${capturedSnapshots.length}/${SNAPSHOTS_NEEDED} for letter ${letter}`);

                const card = document.getElementById(`card-${letter}`);
                card.querySelector('.phoneme-status').textContent = `‚úì Captured ${capturedSnapshots.length}/${SNAPSHOTS_NEEDED}`;

                // Draw snapshot thumbnail
                drawSnapshotThumbnail(letter, snapshotIndex, normalized);

                // Visual feedback
                card.style.transform = 'scale(1.05)';
                setTimeout(() => card.style.transform = 'scale(1)', 200);

                // Check if done
                if (capturedSnapshots.length >= SNAPSHOTS_NEEDED) {
                    console.log(`All ${SNAPSHOTS_NEEDED} snapshots captured! Finishing calibration...`);
                    isRecording = false;
                    finishCalibration(letter);
                    return;
                }

                console.log(`Continuing to listen for more snapshots...`);
            }

            // Keep listening
            requestAnimationFrame(() => listenForPeaks(letter));
        }

        function drawSnapshotThumbnail(letter, index, snapshot) {
            const canvas = document.getElementById(`snapshot-${letter}-${index}`);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, width, height);

            // Draw spectrum bars
            const barWidth = width / snapshot.length;
            for (let i = 0; i < snapshot.length; i++) {
                const barHeight = snapshot[i] * height;
                const x = i * barWidth;
                const y = height - barHeight;

                // Green bars
                ctx.fillStyle = '#7CB342';
                ctx.fillRect(x, y, barWidth - 1, barHeight);
            }

            // Mark as captured
            canvas.classList.add('captured');
        }

        function downsampleFrequencies(fullData, targetBins) {
            // Reduce full frequency data to targetBins by averaging
            const pattern = [];
            const binSize = Math.floor(fullData.length / targetBins);

            for (let i = 0; i < targetBins; i++) {
                let sum = 0;
                const start = i * binSize;
                const end = Math.min(start + binSize, fullData.length);

                for (let j = start; j < end; j++) {
                    sum += fullData[j];
                }

                pattern.push(sum / binSize);
            }

            return pattern;
        }

        function finishCalibration(letter) {
            isRecording = false;

            // DISABLED: Audio recording takes too much localStorage space
            // if (mediaRecorder && mediaRecorder.state === 'recording') {
            //     mediaRecorder.stop();
            //     mediaRecorder.onstop = () => {
            //         const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            //         saveAudioRecording(letter, audioBlob);
            //     };
            // }

            if (capturedSnapshots.length < 3) {
                alert('Not enough snapshots captured. Try again.');
                const card = document.getElementById(`card-${letter}`);
                card.classList.remove('recording');
                card.querySelector('.phoneme-status').textContent = 'Click to record';
                recordingPhoneme = null;
                capturedSnapshots = [];
                audioChunks = [];
                return;
            }

            // CLUSTERING: Find the most similar snapshots
            const clusterResult = findBestCluster(capturedSnapshots);

            // AVERAGE the cluster to create baseline
            const baseline = averageSnapshots(clusterResult.cluster);

            // Store as "pattern" (but it's just 1 peak snapshot, wrapped in array for compatibility)
            calibrationData[letter] = {
                pattern: [baseline], // Wrap in array for compatibility with existing code
                timestamp: Date.now()
            };

            // NOTE: This old calibration path is legacy - modal calibration saves to Supabase
            // No localStorage saving here

            const card = document.getElementById(`card-${letter}`);
            card.classList.remove('recording');
            card.classList.add('calibrated');
            card.querySelector('.phoneme-status').textContent = '‚úì Calibrated';

            updateCalibrationStats();

            recordingPhoneme = null;
            capturedSnapshots = [];

            console.log(`Calibrated ${letter}: Used ${clusterResult.cluster.length}/${capturedSnapshots.length} snapshots`);
        }

        function findBestCluster(snapshots) {
            // Find the group of most similar snapshots (remove outliers)
            // Returns { cluster: [...snapshots], indices: [...indices] }
            if (snapshots.length <= 3) {
                return {
                    cluster: snapshots,
                    indices: snapshots.map((_, i) => i)
                };
            }

            // Calculate pairwise distances
            const distances = [];
            for (let i = 0; i < snapshots.length; i++) {
                for (let j = i + 1; j < snapshots.length; j++) {
                    const dist = calculateSnapshotDistance(snapshots[i], snapshots[j]);
                    distances.push({ i, j, dist });
                }
            }

            // Sort by distance (most similar first)
            distances.sort((a, b) => a.dist - b.dist);

            // Find the 3 snapshots that are most similar to each other
            // Strategy: Start with the most similar pair, add the closest 3rd
            const pair = distances[0]; // Most similar pair
            const candidates = [pair.i, pair.j];

            // Find closest snapshot to this pair
            let bestThird = null;
            let bestAvgDist = Infinity;

            for (let k = 0; k < snapshots.length; k++) {
                if (candidates.includes(k)) continue;

                const dist1 = calculateSnapshotDistance(snapshots[k], snapshots[candidates[0]]);
                const dist2 = calculateSnapshotDistance(snapshots[k], snapshots[candidates[1]]);
                const avgDist = (dist1 + dist2) / 2;

                if (avgDist < bestAvgDist) {
                    bestAvgDist = avgDist;
                    bestThird = k;
                }
            }

            candidates.push(bestThird);
            return {
                cluster: candidates.map(i => snapshots[i]),
                indices: candidates
            };
        }

        function calculateSnapshotDistance(snap1, snap2) {
            // Simple distance: sum of absolute differences
            let sum = 0;
            const len = Math.min(snap1.length, snap2.length);
            for (let i = 0; i < len; i++) {
                sum += Math.abs(snap1[i] - snap2[i]);
            }
            return sum / len;
        }

        function averageSnapshots(snapshots) {
            // Average all snapshots bin-by-bin
            const numBins = snapshots[0].length;
            const averaged = new Array(numBins).fill(0);

            for (const snapshot of snapshots) {
                for (let i = 0; i < numBins; i++) {
                    averaged[i] += snapshot[i];
                }
            }

            return averaged.map(v => v / snapshots.length);
        }

        function normalizePattern(pattern2D) {
            // Normalize each time slice to 0-1 range
            return pattern2D.map(slice => {
                const max = Math.max(...slice);
                if (max === 0) return slice;
                return slice.map(v => v / max);
            });
        }

        function updateCalibrationStats() {
            const calibrated = Object.keys(calibrationData).length;
            const total = PHONEMES.length;
            const statsEl = document.getElementById('calibrationStats');
            statsEl.textContent = `Calibrated: ${calibrated} / ${total} phonemes`;

            if (calibrated === total) {
                statsEl.innerHTML += '<br><strong style="color: #7CB342;">‚úì All phonemes calibrated! Switch to Tuner tab.</strong>';
            }
        }

        function updateCalibrationUI() {
            PHONEMES.forEach(phoneme => {
                if (calibrationData[phoneme.letter]) {
                    const card = document.getElementById(`card-${phoneme.letter}`);
                    if (card) {
                        card.classList.add('calibrated');
                        card.querySelector('.phoneme-status').textContent = '‚úì Calibrated';
                    }
                }
            });
            updateCalibrationStats();
        }

        function resetCalibration() {
            if (confirm(`Reset all calibration data for ${currentProfile}?`)) {
                calibrationData = {};
                const key = `phonicsPatterns_${currentProfile}`;
                localStorage.removeItem(key);
                createCalibrationGrid();
                updateCalibrationStats();
            }
        }

        function exportCalibration() {
            const dataStr = JSON.stringify(calibrationData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `phonics-patterns-${currentProfile}.json`;
            a.click();
        }

        // ========== CALIBRATION MODAL ==========

        let modalAnimationFrame = null;
        let modalWaveformCanvas = null;
        let modalWaveformCtx = null;
        let modalCurrentLetter = '';
        let modalCapturedSnapshots = [];
        let modalIsListening = false;
        let modalListeningForIndex = -1;
        let modalMediaRecorder = null;
        let modalAudioChunks = [];
        let modalAudioClips = []; // Individual audio clips per snapshot
        let modalCurrentRecordingIndex = -1;

        function openCalibrationModal(letter) {
            modalCurrentLetter = letter;
            modalCapturedSnapshots = [];
            modalAudioClips = []; // Reset audio clips array
            modalIsListening = false;
            modalListeningForIndex = -1;
            modalCurrentRecordingIndex = -1;

            // Set up modal UI
            document.getElementById('modalLetter').textContent = letter;
            document.getElementById('modalStatus').textContent = `Click box 1 to record first sound`;

            // Hide next button
            document.getElementById('modalNextButton').classList.remove('active');

            // Reset and setup capture boxes as CLICKABLE
            for (let i = 0; i < 5; i++) {
                const box = document.getElementById(`modalCaptureBox${i}`);
                box.classList.remove('captured', 'recording', 'ready');
                const canvas = document.getElementById(`modalCaptureCanvas${i}`);
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Make boxes clickable
                box.onclick = () => startCaptureForBox(i);

                // Mark first box as ready
                if (i === 0) {
                    box.classList.add('ready');
                    box.style.cursor = 'pointer';
                } else {
                    box.style.cursor = 'not-allowed';
                }
            }

            // Show the click arrow pointing at box 1
            document.getElementById('clickArrow').classList.add('active');

            // Setup audio if needed (no session-long recording, we'll record per snapshot)
            if (!audioContext) {
                setupAudio().then(() => {
                    document.getElementById('calibrationModal').classList.add('active');
                    startModalVisualization();
                });
            } else {
                document.getElementById('calibrationModal').classList.add('active');
                startModalVisualization();
            }
        }

        function closeCalibrationModal() {
            modalIsListening = false;
            if (modalAnimationFrame) {
                cancelAnimationFrame(modalAnimationFrame);
                modalAnimationFrame = null;
            }
            // Stop audio recording if still active
            if (modalMediaRecorder && modalMediaRecorder.state === 'recording') {
                modalMediaRecorder.stop();
            }
            document.getElementById('clickArrow').classList.remove('active');
            document.getElementById('modalNextButton').classList.remove('active');
            document.getElementById('calibrationModal').classList.remove('active');
        }

        function playModalLetterSound() {
            playPhonemeSound(modalCurrentLetter);
        }

        function startCaptureForBox(index) {
            // Only allow capturing the next uncaptured box
            if (index !== modalCapturedSnapshots.length) {
                return;
            }

            // Already listening
            if (modalIsListening) return;

            // Hide the arrow once user starts interacting
            document.getElementById('clickArrow').classList.remove('active');

            // DON'T start listening yet - wait for delay first!
            modalListeningForIndex = index;
            modalCurrentRecordingIndex = index;

            const box = document.getElementById(`modalCaptureBox${index}`);
            box.classList.remove('ready');
            box.classList.add('recording');
            box.style.cursor = 'wait';

            document.getElementById('modalStatus').textContent = `Recording ${index + 1}/5... Get ready...`;

            // Wait 400ms to avoid click sound, THEN start listening AND recording
            setTimeout(() => {
                modalIsListening = true; // NOW we start listening!
                document.getElementById('modalStatus').textContent = `Recording ${index + 1}/5... Say "${modalCurrentLetter}" NOW!`;

                // Start individual audio recording for this snapshot
                modalAudioChunks = [];
                if (microphone && microphone.stream) {
                    modalMediaRecorder = new MediaRecorder(microphone.stream);
                    modalMediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            modalAudioChunks.push(event.data);
                        }
                    };
                    modalMediaRecorder.start();
                    console.log(`üéôÔ∏è Started recording clip ${index + 1}/5`);
                }
            }, 400);
        }

        function startModalVisualization() {
            let lastPeakTime = 0;
            const PEAK_COOLDOWN = 500;

            function visualize() {
                if (!document.getElementById('calibrationModal').classList.contains('active')) {
                    return;
                }

                modalAnimationFrame = requestAnimationFrame(visualize);

                if (!analyser || !dataArray) return;

                analyser.getByteFrequencyData(dataArray);

                // Draw waveform in modal
                drawModalWaveform();

                // Listen for peak if actively recording
                if (modalIsListening && modalListeningForIndex >= 0) {
                    // Calculate current volume
                    let sum = 0;
                    for (let i = 0; i < dataArray.length; i++) {
                        sum += dataArray[i];
                    }
                    const volume = (sum / dataArray.length / 128) * 100;

                    const volumeThreshold = isNasal(modalCurrentLetter) ? 8 : 15;

                    // Detect peak (after 400ms delay)
                    const now = Date.now();
                    if (volume > volumeThreshold && (now - lastPeakTime) > PEAK_COOLDOWN) {
                        // Capture snapshot
                        let snapshot = downsampleFrequencies(dataArray, PATTERN_BINS);

                        // Check energy concentration
                        const peakEnergy = Math.max(...snapshot);
                        const avgEnergy = snapshot.reduce((a, b) => a + b, 0) / snapshot.length;
                        const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;
                        const concentrationThreshold = isNasal(modalCurrentLetter) ? 1.5 : 2.0;

                        if (energyConcentration < concentrationThreshold) {
                            return; // Skip weak peaks
                        }

                        // Pre-amplify nasals
                        if (isNasal(modalCurrentLetter)) {
                            snapshot = snapshot.map(v => v * 2.0);
                        }

                        // Normalize
                        const maxVal = Math.max(...snapshot);
                        const normalized = snapshot.map(v => v / maxVal);

                        // Capture!
                        modalCapturedSnapshots.push(normalized);
                        lastPeakTime = now;

                        console.log(`üì∏ Captured snapshot ${modalCapturedSnapshots.length}/5`);

                        // Draw in box
                        drawSnapshotInModalBox(modalListeningForIndex, normalized);

                        // Mark box as captured
                        const box = document.getElementById(`modalCaptureBox${modalListeningForIndex}`);
                        box.classList.remove('recording');
                        box.classList.add('captured');
                        box.style.cursor = 'default';

                        // Stop listening (but keep recording for full sound)
                        modalIsListening = false;
                        modalListeningForIndex = -1;

                        // Continue recording for 700ms after peak to capture the full sound
                        setTimeout(() => {
                            if (modalMediaRecorder && modalMediaRecorder.state === 'recording') {
                                modalMediaRecorder.stop();
                                modalMediaRecorder.addEventListener('stop', () => {
                                    const audioBlob = new Blob(modalAudioChunks, { type: 'audio/webm' });
                                    modalAudioClips.push(audioBlob);
                                    const sizeKB = (audioBlob.size / 1024).toFixed(2);
                                    console.log(`üéôÔ∏è Saved audio clip ${modalAudioClips.length}/5 (${sizeKB} KB)`);
                                }, { once: true });
                            }
                        }, 700); // Continue recording for 700ms after peak detected

                        // Update status and enable next box
                        if (modalCapturedSnapshots.length < 5) {
                            const nextBox = document.getElementById(`modalCaptureBox${modalCapturedSnapshots.length}`);
                            nextBox.classList.add('ready');
                            nextBox.style.cursor = 'pointer';
                            document.getElementById('modalStatus').textContent = `‚úì Captured ${modalCapturedSnapshots.length}/5. Click box ${modalCapturedSnapshots.length + 1}`;
                        } else {
                            // All done!
                            document.getElementById('modalStatus').textContent = `‚úì All 5 captured! Saving...`;
                            setTimeout(() => {
                                finishModalCalibration();
                            }, 500);
                        }
                    }
                }
            }
            visualize();
        }

        function drawModalWaveform() {
            if (!modalWaveformCtx || !dataArray) return;

            const width = modalWaveformCanvas.width;
            const height = modalWaveformCanvas.height;

            // Clear with fade
            modalWaveformCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            modalWaveformCtx.fillRect(0, 0, width, height);

            // Draw frequency bars
            const barWidth = width / dataArray.length * 2.5;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * height;
                const hue = (i / dataArray.length) * 120 + 100;
                modalWaveformCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                modalWaveformCtx.fillRect(x, height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        function drawSnapshotInModalBox(index, snapshot) {
            const canvas = document.getElementById(`modalCaptureCanvas${index}`);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const barWidth = canvas.width / snapshot.length;
            for (let j = 0; j < snapshot.length; j++) {
                const barHeight = snapshot[j] * canvas.height;
                const x = j * barWidth;
                const y = canvas.height - barHeight;

                ctx.fillStyle = '#7CB342';
                ctx.fillRect(x, y, barWidth - 1, barHeight);
            }
        }

        async function finishModalCalibration() {
            console.log('Finishing modal calibration...');

            // Use the SAME logic as the original finishCalibration
            const clusterResult = findBestCluster(modalCapturedSnapshots);
            const baseline = averageSnapshots(clusterResult.cluster);

            // Save in the correct format
            const patternData = {
                pattern: [baseline],
                timestamp: Date.now()
            };

            // Select the best audio clip from the cluster
            // Strategy: Use the FIRST clip from the cluster (usually the most representative)
            let bestAudioBlob = null;
            if (modalAudioClips.length > 0 && clusterResult.indices.length > 0) {
                const bestIndex = clusterResult.indices[0]; // First snapshot in best cluster
                if (bestIndex < modalAudioClips.length) {
                    bestAudioBlob = modalAudioClips[bestIndex];
                    const sizeKB = (bestAudioBlob.size / 1024).toFixed(2);
                    console.log(`üéØ Selected best audio clip: snapshot ${bestIndex + 1} (${sizeKB} KB)`);
                }
            }

            // Save to Supabase (with ONLY the best audio clip)
            const audioUrl = await saveCalibrationToSupabase(modalCurrentLetter, patternData, bestAudioBlob);

            // Update local calibrationData with audioUrl for immediate playback
            calibrationData[modalCurrentLetter] = {
                ...patternData,
                audioUrl: audioUrl
            };

            // Update UI
            updateCalibrationUI();

            console.log(`‚úÖ Calibrated ${modalCurrentLetter}: Used ${clusterResult.cluster.length}/${modalCapturedSnapshots.length} snapshots`);

            document.getElementById('modalStatus').innerHTML = '<strong style="color: #7CB342;">üéâ Calibrated!</strong>';

            // Show next button
            document.getElementById('modalNextButton').classList.add('active');
        }

        function goToNextLetter() {
            // Find current letter index in PHONEMES
            const currentIndex = PHONEMES.findIndex(p => p.letter === modalCurrentLetter);

            // Look for next uncalibrated letter
            for (let i = currentIndex + 1; i < PHONEMES.length; i++) {
                const nextLetter = PHONEMES[i].letter;
                if (!calibrationData[nextLetter]) {
                    // Found next uncalibrated letter
                    closeCalibrationModal();
                    setTimeout(() => {
                        openCalibrationModal(nextLetter);
                    }, 300);
                    return;
                }
            }

            // If no uncalibrated letters after current, check from beginning
            for (let i = 0; i < currentIndex; i++) {
                const nextLetter = PHONEMES[i].letter;
                if (!calibrationData[nextLetter]) {
                    closeCalibrationModal();
                    setTimeout(() => {
                        openCalibrationModal(nextLetter);
                    }, 300);
                    return;
                }
            }

            // All letters calibrated!
            closeCalibrationModal();
        }

        // Elimination game mode
        let patternBuffer = [];
        let currentTarget = null;
        let experimentResults = []; // Track all trials for analysis
        let alphabetModeEnabled = false;
        let currentAlphabetIndex = 0;

        function toggleAlphabetMode() {
            alphabetModeEnabled = document.getElementById('alphabetMode').checked;
            currentAlphabetIndex = 0;
            updateAlphabetProgress();
        }

        function updateAlphabetProgress() {
            const progressEl = document.getElementById('alphabetProgress');
            if (alphabetModeEnabled && currentTarget) {
                progressEl.style.display = 'inline';
                const letterIndex = PHONEMES.findIndex(p => p.letter === currentTarget) + 1;
                progressEl.textContent = `Letter ${letterIndex}/26: ${currentTarget}`;
            } else {
                progressEl.style.display = 'none';
            }
        }

        function pickRandomLetter() {
            // Only pick from letters that are BOTH calibrated AND in current PHONEMES list
            const allowedLetters = PHONEMES.map(p => p.letter);
            const calibratedLetters = Object.keys(calibrationData).filter(letter =>
                allowedLetters.includes(letter)
            );
            if (calibratedLetters.length === 0) return null;
            return calibratedLetters[Math.floor(Math.random() * calibratedLetters.length)];
        }

        function pickNextAlphabetLetter() {
            const allLetters = PHONEMES.map(p => p.letter);
            const calibratedLetters = Object.keys(calibrationData);

            // Start from current index and find next calibrated letter
            let attempts = 0;
            while (attempts < 26) {
                const letter = allLetters[currentAlphabetIndex];
                currentAlphabetIndex = (currentAlphabetIndex + 1) % 26;

                if (calibratedLetters.includes(letter)) {
                    return letter;
                }
                attempts++;
            }

            return null;
        }

        function skipLetter() {
            if (isRunning) {
                setNextTarget();
            }
        }

        function tryAgain() {
            // Reset and start listening again for same letter
            document.getElementById('tryAgainBtn').style.display = 'none';
            document.getElementById('tunerBtn').textContent = '‚è∏ Stop Game';
            patternBuffer = [];
            isRunning = true;
            analyzeTuner();
        }

        function setNextTarget() {
            currentTarget = alphabetModeEnabled ? pickNextAlphabetLetter() : pickRandomLetter();
            if (currentTarget) {
                document.getElementById('targetLetter').textContent = currentTarget;
                document.getElementById('status').textContent = `Say: ${currentTarget}`;
                document.getElementById('tryAgainBtn').style.display = 'none';
                patternBuffer = [];
                updateAlphabetProgress();
            }
        }

        async function toggleTuner() {
            const btn = document.getElementById('tunerBtn');

            // If button says "Next Letter", just advance to next
            if (btn.textContent === '‚ñ∂ Next Letter') {
                btn.textContent = '‚è∏ Stop Game';
                isRunning = true;
                setNextTarget();
                analyzeTuner();
                return;
            }

            if (isRunning) {
                isRunning = false;
                btn.textContent = '‚ñ∂ Start Game';
                document.getElementById('status').textContent = 'Stopped';
                document.getElementById('targetLetter').textContent = '?';
            } else {
                if (Object.keys(calibrationData).length === 0) {
                    alert('Please calibrate at least one phoneme first!');
                    return;
                }
                if (!audioContext) {
                    await setupAudio();
                }
                isRunning = true;
                btn.textContent = '‚è∏ Stop Game';
                setNextTarget();
                analyzeTuner();
            }
        }

        function analyzeTuner() {
            if (!isRunning) return;
            requestAnimationFrame(analyzeTuner);

            analyser.getByteFrequencyData(dataArray);

            // Draw spectrum
            drawSpectrum();

            // Calculate volume
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volume = (sum / dataArray.length / 128) * 100;
            document.getElementById('volume').textContent = Math.round(volume) + '%';

            // ALWAYS add current frame to buffer (sliding window)
            const pattern = downsampleFrequencies(dataArray, PATTERN_BINS);
            patternBuffer.push(pattern);

            // Keep buffer at PATTERN_LENGTH
            if (patternBuffer.length > PATTERN_LENGTH) {
                patternBuffer.shift();
            }

            // DEBUG: Show buffer status only when NOT ready
            if (currentTarget && patternBuffer.length < PATTERN_LENGTH) {
                document.getElementById('status').textContent = `Buffer: ${patternBuffer.length}/${PATTERN_LENGTH} frames (keep talking...)`;
            }

            // Check energy concentration (speech vs background noise)
            const peakEnergy = Math.max(...pattern);
            const avgEnergy = pattern.reduce((a, b) => a + b, 0) / pattern.length;
            const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;

            // Skip detection if playing back a recording
            if (isPlayingRecording) {
                return;
            }

            // Dynamic thresholds for nasals (same as game mode)
            const FRICATIVES = ['F', 'S', 'V', 'Z', 'H'];
            const LIQUIDS = ['L', 'R'];
            const isCurrentNasal = currentTarget && isNasal(currentTarget);
            const isFricative = currentTarget && FRICATIVES.includes(currentTarget);
            const isLiquid = currentTarget && LIQUIDS.includes(currentTarget);

            let volumeThreshold = 15;
            let concentrationThreshold = 2.0;

            if (isCurrentNasal || isLiquid) {
                volumeThreshold = 8;
                concentrationThreshold = 1.5;
            } else if (isFricative) {
                volumeThreshold = 10;
                concentrationThreshold = 1.8;
            }

            // Try to match against TARGET letter only
            if (patternBuffer.length === PATTERN_LENGTH && volume > volumeThreshold && energyConcentration > concentrationThreshold && currentTarget) {

                // S11-Snapshot detection for ALL letters
                const results = testAllPlosiveStrategies(patternBuffer, currentTarget);

                const result = results[0]; // Only S11-Snapshot now
                const score = Math.max(0, Math.min(100, result.score || 0));
                const targetScore = Math.max(0, Math.min(100, result.targetScore || 0));
                const prediction = result.predictedLetter || '?';
                const isCorrect = prediction === currentTarget;

                // Show simplified status
                const barCount = Math.max(0, Math.floor(score / 10));
                const bar = '‚ñà'.repeat(barCount);
                const statusText = `üéØ S11-Snapshot: ${isCorrect ? '‚úì' : '‚úó'} Predicted: ${prediction} | Score: ${Math.round(score)}% ${bar}\nTarget ${currentTarget}: ${Math.round(targetScore)}%`;

                document.getElementById('status').textContent = statusText;
                document.getElementById('matchScore').textContent = Math.round(score) + '%';
                document.getElementById('confidenceFill').style.width = score + '%';

                // Success if S11 predicts correctly AND score > 80%
                if (isCorrect && score > 80) {
                    celebrateMatch();

                    // Log this trial for analysis
                    experimentResults.push({
                        target: currentTarget,
                        timestamp: Date.now(),
                        strategies: results
                    });

                    // Prepend success message to experimental results
                    const trialsCount = experimentResults.length;
                    document.getElementById('trialsCount').textContent = trialsCount;
                    document.getElementById('status').textContent = `‚úì MATCH! ${Math.round(score)}% - Trial #${trialsCount} logged\n\n` + statusText;
                    // Stop analyzing so results stay visible
                    isRunning = false;
                    document.getElementById('tunerBtn').textContent = '‚ñ∂ Next Letter';
                    document.getElementById('tryAgainBtn').style.display = 'inline-block';
                }

                if (false) {
                    // REGULAR DETECTION: Use pattern matching for non-plosives
                    const score = matchTargetPattern(patternBuffer, currentTarget);

                    // Also check BEST match among all letters
                    const allScores = Object.keys(calibrationData).map(letter => {
                        const normalized = normalizePattern(patternBuffer);
                        const storedPattern = calibrationData[letter].pattern;
                        const similarity = calculatePatternSimilarity(normalized, storedPattern);
                        return { letter, score: similarity * 100 };
                    });

                    allScores.sort((a, b) => b.score - a.score);
                    const bestMatch = allScores[0];

                    document.getElementById('matchScore').textContent = Math.round(score) + '%';
                    document.getElementById('confidenceFill').style.width = score + '%';
                    document.getElementById('status').textContent = `Best match: ${bestMatch.letter} (${Math.round(bestMatch.score)}%)`;

                    // Success! Pattern matched AND it's the best match
                    if (score > 85 && bestMatch.letter === currentTarget) {
                        celebrateMatch();
                        document.getElementById('status').textContent = `‚úì PERFECT MATCH! (Try Again or Next Letter)\nBest match: ${bestMatch.letter} (${Math.round(bestMatch.score)}%)`;
                        // Stop analyzing so results stay visible
                        isRunning = false;
                        document.getElementById('tunerBtn').textContent = '‚ñ∂ Next Letter';
                        document.getElementById('tryAgainBtn').style.display = 'inline-block';
                    }
                }
            }
        }

        function matchTargetPattern(currentPattern, targetLetter) {
            if (!calibrationData[targetLetter]) return 0;

            // Normalize current pattern
            const normalized = normalizePattern(currentPattern);
            const storedPattern = calibrationData[targetLetter].pattern;

            // Calculate correlation
            const score = calculatePatternSimilarity(normalized, storedPattern);

            // Convert to percentage
            return Math.min(100, score * 100);
        }

        function celebrateMatch() {
            const targetEl = document.getElementById('targetLetter');

            // Play success sound
            if (audioContext) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.4);
            }

            // Exciting animation sequence
            targetEl.style.transition = 'all 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55)';

            // Bounce and color sequence
            targetEl.style.transform = 'scale(1.5) rotate(5deg)';
            targetEl.style.color = '#FDD835';

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.3) rotate(-5deg)';
                targetEl.style.color = '#7CB342';
            }, 150);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.6) rotate(0deg)';
                targetEl.style.color = '#00BCD4';
            }, 300);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.2)';
                targetEl.style.color = '#FF5722';
            }, 450);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.4)';
                targetEl.style.color = '#9C27B0';
            }, 600);

            setTimeout(() => {
                targetEl.style.transition = 'all 0.3s ease-out';
                targetEl.style.transform = 'scale(1)';
                targetEl.style.color = '#FDD835';
            }, 800);

            // Create confetti particles
            createConfetti(targetEl);
        }

        function createConfetti(centerEl) {
            const container = centerEl.parentElement;
            const rect = centerEl.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const colors = ['#FDD835', '#7CB342', '#00BCD4', '#FF5722', '#9C27B0'];

            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.style.position = 'fixed';
                particle.style.left = centerX + 'px';
                particle.style.top = centerY + 'px';
                particle.style.width = '10px';
                particle.style.height = '10px';
                particle.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                particle.style.pointerEvents = 'none';
                particle.style.zIndex = '9999';

                document.body.appendChild(particle);

                const angle = (Math.PI * 2 * i) / 20;
                const velocity = 100 + Math.random() * 100;
                const vx = Math.cos(angle) * velocity;
                const vy = Math.sin(angle) * velocity;

                let x = 0, y = 0, time = 0;
                const gravity = 500;

                const animate = () => {
                    time += 0.016; // ~60fps
                    x = vx * time;
                    y = vy * time + 0.5 * gravity * time * time;

                    particle.style.transform = `translate(${x}px, ${y}px) rotate(${time * 360}deg)`;
                    particle.style.opacity = Math.max(0, 1 - time * 1.5);

                    if (time < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        particle.remove();
                    }
                };

                requestAnimationFrame(animate);
            }
        }

        // ========== EXPERIMENTAL PLOSIVE DETECTION STRATEGIES ==========

        function testAllPlosiveStrategies(patternBuffer, targetLetter) {
            if (!calibrationData[targetLetter]) return [{ strategy: 'none', score: 0, predictedLetter: '?' }];

            const results = [];
            const strategyFunctions = [
                { name: 'S11-Snapshot', fn: strategy11_simpleSnapshot }
            ];

            // For each strategy, test against ALL calibrated letters
            strategyFunctions.forEach(({ name, fn }) => {
                let bestLetter = null;
                let bestScore = 0;
                let targetScore = 0;

                // Test this strategy against all calibrated letters
                Object.keys(calibrationData).forEach(letter => {
                    const score = fn(patternBuffer, letter);
                    if (score > bestScore) {
                        bestScore = score;
                        bestLetter = letter;
                    }
                    if (letter === targetLetter) {
                        targetScore = score;
                    }
                });

                results.push({
                    strategy: name,
                    score: bestScore,
                    targetScore: targetScore,
                    predictedLetter: bestLetter || '?'
                });
            });

            // Sort by score (highest first)
            results.sort((a, b) => b.score - a.score);

            return results;
        }

        // Strategy 1: Focus on frames around peak energy
        function strategy1_burstWindow(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const peakIdx = energies.indexOf(Math.max(...energies));

            const burstWindow = buffer.slice(Math.max(0, peakIdx - 5), peakIdx + 5);
            return matchTargetPattern(burstWindow, target);
        }

        // Strategy 2: Use only first 10 frames
        function strategy2_shortWindow(buffer, target) {
            const shortBuffer = buffer.slice(0, 10);
            return matchTargetPattern(shortBuffer, target);
        }

        // Strategy 3: Compare peak frequency and amplitude
        function strategy3_peakEnergy(buffer, target) {
            const currentPeak = Math.max(...buffer.flat());
            const currentPeakFreq = buffer[0].indexOf(Math.max(...buffer[0]));

            const calibPattern = calibrationData[target].pattern;
            const calibPeak = Math.max(...calibPattern.flat());
            const calibPeakFreq = calibPattern[0].indexOf(Math.max(...calibPattern[0]));

            const peakSimilarity = 1 - Math.abs(currentPeak - calibPeak);
            const freqSimilarity = 1 - Math.abs(currentPeakFreq - calibPeakFreq) / PATTERN_BINS;

            return ((peakSimilarity + freqSimilarity) / 2) * 100;
        }

        // Strategy 4: Compare attack speed (volume rise rate)
        function strategy4_attackSpeed(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));

            let maxRise = 0;
            for (let i = 1; i < energies.length; i++) {
                const rise = energies[i] - energies[i - 1];
                if (rise > maxRise) maxRise = rise;
            }

            // Compare with calibration (would need to store this)
            // For now, just use pattern matching on energy envelope
            const normalized = normalizePattern(buffer);
            const stored = calibrationData[target].pattern;
            return calculatePatternSimilarity(normalized, stored) * 100;
        }

        // Strategy 5: Match derivatives (rate of change)
        function strategy5_derivative(buffer, target) {
            const derivatives = [];
            for (let i = 1; i < buffer.length; i++) {
                const diff = buffer[i].map((val, idx) => val - buffer[i - 1][idx]);
                derivatives.push(diff);
            }

            return matchTargetPattern(derivatives, target);
        }

        // Strategy 6: Simple burst detection + frequency check
        function strategy6_dualThreshold(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const maxEnergy = Math.max(...energies);
            const avgEnergy = energies.reduce((a, b) => a + b, 0) / energies.length;

            const isBurst = maxEnergy > avgEnergy * 2;

            if (!isBurst) return 0;

            return matchTargetPattern(buffer, target);
        }

        // Strategy 7: Average multiple high-energy frames
        function strategy7_multipleFrames(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const threshold = Math.max(...energies) * 0.7;

            const highEnergyFrames = buffer.filter((frame, idx) => energies[idx] > threshold);

            if (highEnergyFrames.length === 0) return 0;

            return matchTargetPattern(highEnergyFrames, target);
        }

        // Strategy 8: Measure quiet-to-loud ratio
        function strategy8_silenceRatio(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const avgEnergy = energies.reduce((a, b) => a + b, 0) / energies.length;

            const quietFrames = energies.filter(e => e < avgEnergy * 0.5).length;
            const silenceRatio = quietFrames / energies.length;

            // Plosives should have high silence ratio
            const expectedRatio = 0.6; // 60% quiet
            const ratioScore = 1 - Math.abs(silenceRatio - expectedRatio);

            const patternScore = matchTargetPattern(buffer, target) / 100;

            return ((ratioScore + patternScore) / 2) * 100;
        }

        // Strategy 10: Only match first 5 frames (immediate burst)
        function strategy10_firstFrames(buffer, target) {
            const firstFrames = buffer.slice(0, 5);
            return matchTargetPattern(firstFrames, target);
        }

        // Strategy 11: Simple Snapshot Comparison (peak moment bar heights)
        function strategy11_simpleSnapshot(buffer, target) {
            if (!calibrationData[target]) return 0;

            // Find peak moment in current buffer (highest energy frame)
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const currentPeakIdx = energies.indexOf(Math.max(...energies));
            let currentSnapshot = buffer[currentPeakIdx];

            // Normalize current snapshot to 0-1 range (same as calibration data)
            const maxCurrent = Math.max(...currentSnapshot);
            if (maxCurrent > 0) {
                currentSnapshot = currentSnapshot.map(v => v / maxCurrent);
            }

            // Get stored baseline snapshot (already averaged and normalized)
            const storedSnapshot = calibrationData[target].pattern[0]; // It's a single snapshot now

            // Calculate simple distance (sum of absolute differences)
            let totalDistance = 0;
            const minLength = Math.min(currentSnapshot.length, storedSnapshot.length);

            for (let i = 0; i < minLength; i++) {
                totalDistance += Math.abs(currentSnapshot[i] - storedSnapshot[i]);
            }

            // Convert distance to similarity score (0-100)
            // Max possible avgDistance is 1.0 (completely different patterns)
            const avgDistance = totalDistance / minLength;
            const similarity = Math.max(0, 100 - (avgDistance * 100));

            return similarity;
        }

        function calculatePatternSimilarity(pattern1, pattern2) {
            // Use correlation coefficient to measure similarity
            let sumProduct = 0;
            let sum1Sq = 0;
            let sum2Sq = 0;
            let count = 0;

            const minLength = Math.min(pattern1.length, pattern2.length);

            for (let t = 0; t < minLength; t++) {
                const slice1 = pattern1[t];
                const slice2 = pattern2[t];
                const minBins = Math.min(slice1.length, slice2.length);

                for (let f = 0; f < minBins; f++) {
                    sumProduct += slice1[f] * slice2[f];
                    sum1Sq += slice1[f] * slice1[f];
                    sum2Sq += slice2[f] * slice2[f];
                    count++;
                }
            }

            const denominator = Math.sqrt(sum1Sq * sum2Sq);
            if (denominator === 0) return 0;

            return sumProduct / denominator; // Correlation coefficient
        }

        function drawSpectrum() {
            const width = canvas.width;
            const height = canvas.height;

            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            canvasCtx.fillRect(0, 0, width, height);

            const barWidth = width / dataArray.length * 2.5;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * height;
                const hue = (i / dataArray.length) * 120 + 100;
                canvasCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                canvasCtx.fillRect(x, height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        // DEPRECATED: Audio is now stored in Supabase Storage
        // These functions are kept for backwards compatibility but are no longer used
        function saveAudioRecording(letter, audioBlob) {
            console.warn('‚ö†Ô∏è saveAudioRecording is deprecated - audio now saved to Supabase Storage');
        }

        function loadAudioRecordings() {
            console.warn('‚ö†Ô∏è loadAudioRecordings is deprecated - audio loaded from Supabase');
            audioRecordings = {}; // Keep empty for legacy code compatibility
        }

        let isPlayingRecording = false;
        let currentPhonemeAudio = null;

        function playPhonemeSound(letter) {
            const phoneme = PHONEMES.find(p => p.letter === letter);
            if (!phoneme || !phoneme.audioUrl) return;

            if (currentPhonemeAudio) {
                currentPhonemeAudio.pause();
                currentPhonemeAudio.currentTime = 0;
            }

            currentPhonemeAudio = new Audio(phoneme.audioUrl);
            currentPhonemeAudio.play().catch(err => {
                console.error('Audio playback failed:', err);
            });
        }

        function playCalibrationRecording() {
            if (!currentTarget) {
                alert('No letter selected. Start the tuner first!');
                return;
            }

            // Get audio URL from Supabase calibration data
            const calibration = calibrationData[currentTarget];
            if (!calibration || !calibration.audioUrl) {
                alert(`No recording found for ${currentTarget}. Please calibrate this letter first.`);
                return;
            }

            isPlayingRecording = true;
            const audio = new Audio(calibration.audioUrl);

            audio.onended = () => {
                isPlayingRecording = false;
            };

            audio.onerror = () => {
                isPlayingRecording = false;
                alert('Error playing audio from Supabase Storage');
            };

            audio.play();
        }

        async function setupAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.stream = stream;

                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.5;

                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);

                microphone.connect(analyser);

            } catch (err) {
                alert('Microphone access denied!');
                console.error('Audio setup error:', err);
            }
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                const tabs = document.querySelectorAll('.tab');
                tabs.forEach(tab => {
                    if (tab.textContent.toLowerCase().includes(tabName)) {
                        tab.classList.add('active');
                    }
                });
            }
            document.getElementById(tabName).classList.add('active');
        }

        // ========== STATISTICS & EXPORT ==========

        function viewStats() {
            if (experimentResults.length === 0) {
                alert('No trials recorded yet. Run some tests first!');
                return;
            }

            // Calculate accuracy per strategy
            const strategyStats = {};

            experimentResults.forEach(trial => {
                trial.strategies.forEach(result => {
                    if (!strategyStats[result.strategy]) {
                        strategyStats[result.strategy] = { correct: 0, total: 0 };
                    }
                    strategyStats[result.strategy].total++;
                    if (result.predictedLetter === trial.target) {
                        strategyStats[result.strategy].correct++;
                    }
                });
            });

            // Format stats display
            let statsText = `üìä EXPERIMENT STATISTICS (${experimentResults.length} trials):\n\n`;

            // Sort strategies by accuracy
            const sortedStrategies = Object.entries(strategyStats)
                .map(([name, stats]) => ({
                    name,
                    accuracy: (stats.correct / stats.total) * 100,
                    correct: stats.correct,
                    total: stats.total
                }))
                .sort((a, b) => b.accuracy - a.accuracy);

            sortedStrategies.forEach(s => {
                const bar = '‚ñà'.repeat(Math.floor(s.accuracy / 10));
                statsText += `${s.name.padEnd(12)} ${Math.round(s.accuracy).toString().padStart(3)}% ${bar} (${s.correct}/${s.total})\n`;
            });

            statsText += `\n\nTarget letter breakdown:\n`;
            const targetCounts = {};
            experimentResults.forEach(t => {
                targetCounts[t.target] = (targetCounts[t.target] || 0) + 1;
            });
            Object.entries(targetCounts).forEach(([letter, count]) => {
                statsText += `  ${letter}: ${count} trials\n`;
            });

            document.getElementById('status').textContent = statsText;
        }

        function exportResults() {
            if (experimentResults.length === 0) {
                alert('No trials recorded yet. Run some tests first!');
                return;
            }

            const dataStr = JSON.stringify(experimentResults, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `plosive-experiment-${Date.now()}.json`;
            a.click();

            alert(`Exported ${experimentResults.length} trials`);
        }

        // ========== GAME MODE ==========

        let gameCanvas;
        let gameCtx;
        let gameSpectrumCanvas;
        let gameSpectrumCtx;
        let gameRunning = false;
        let gameScore = 0;
        let gameLives = 3;
        let gameSpeed = 1;
        let fallingLetters = [];
        let gamePatternBuffer = [];
        let lastSpawnTime = 0;
        let gameAnimationFrame = null;

        class FallingLetter {
            constructor(letter, lane, speed) {
                this.letter = letter;
                this.lane = lane;
                this.y = 0;
                this.speed = speed;
                this.width = 100;
                this.height = 120;
            }

            update(deltaSpeed) {
                this.y += this.speed * deltaSpeed;
            }

            isAtBottom(canvasHeight) {
                return this.y + this.height >= canvasHeight;
            }

            getDistance(canvasHeight) {
                return canvasHeight - (this.y + this.height);
            }
        }

        function initGame() {
            gameCanvas = document.getElementById('gameCanvas');
            gameCtx = gameCanvas.getContext('2d');
            gameCanvas.width = 400;
            gameCanvas.height = 700;

            gameSpectrumCanvas = document.getElementById('gameSpectrumCanvas');
            gameSpectrumCtx = gameSpectrumCanvas.getContext('2d');
            gameSpectrumCanvas.width = 800;
            gameSpectrumCanvas.height = 100;
        }

        async function toggleGame() {
            const btn = document.getElementById('gameBtn');

            if (gameRunning) {
                stopGame();
            } else {
                if (Object.keys(calibrationData).length === 0) {
                    alert('Please calibrate at least one phoneme first!');
                    return;
                }
                if (!audioContext) {
                    await setupAudio();
                }
                startGame();
            }
        }

        function startGame() {
            gameRunning = true;
            gameScore = 0;
            gameLives = 3;
            gameSpeed = 1;
            fallingLetters = [];
            gamePatternBuffer = [];
            lastSpawnTime = 0;

            document.getElementById('gameBtn').textContent = '‚è∏ Pause';
            updateGameUI();

            if (!gameCanvas) initGame();

            gameLoop();
            analyzeGameAudio();
        }

        function stopGame() {
            gameRunning = false;
            document.getElementById('gameBtn').textContent = '‚ñ∂ Start Game';
            if (gameAnimationFrame) {
                cancelAnimationFrame(gameAnimationFrame);
            }
        }

        function restartGame() {
            stopGame();
            setTimeout(() => {
                if (audioContext) {
                    startGame();
                }
            }, 100);
        }

        function updateGameUI() {
            document.getElementById('gameScore').textContent = gameScore;
            document.getElementById('gameLives').textContent = gameLives;
            document.getElementById('gameSpeed').textContent = gameSpeed.toFixed(1) + 'x';
        }

        function spawnLetter() {
            const calibratedLetters = Object.keys(calibrationData);
            if (calibratedLetters.length === 0) return;

            if (fallingLetters.length >= 3) return;

            const usedLanes = fallingLetters.map(l => l.lane);
            const availableLanes = [0, 1, 2].filter(lane => !usedLanes.includes(lane));
            if (availableLanes.length === 0) return;

            const lane = availableLanes[Math.floor(Math.random() * availableLanes.length)];
            const letter = calibratedLetters[Math.floor(Math.random() * calibratedLetters.length)];
            const speed = 1 * gameSpeed;

            fallingLetters.push(new FallingLetter(letter, lane, speed));
        }

        function gameLoop() {
            if (!gameRunning) return;

            const now = Date.now();
            if (now - lastSpawnTime > 2000 && fallingLetters.length < 3) {
                spawnLetter();
                lastSpawnTime = now;
            }

            gameCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

            let closestLetter = null;
            let minDistance = Infinity;

            fallingLetters.forEach(letter => {
                letter.update(1);

                const distance = letter.getDistance(gameCanvas.height);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestLetter = letter;
                }
            });

            fallingLetters.forEach(letter => {
                const x = (letter.lane * (gameCanvas.width / 3)) + (gameCanvas.width / 6) - (letter.width / 2);
                const isClosest = letter === closestLetter;

                if (isClosest) {
                    gameCtx.fillStyle = '#F44336';
                    gameCtx.shadowBlur = 20;
                    gameCtx.shadowColor = '#F44336';
                } else {
                    gameCtx.fillStyle = '#FDD835';
                    gameCtx.shadowBlur = 0;
                }

                gameCtx.font = 'bold 80px Arial';
                gameCtx.textAlign = 'center';
                gameCtx.textBaseline = 'middle';
                gameCtx.fillText(letter.letter, x + letter.width / 2, letter.y + letter.height / 2);

                gameCtx.shadowBlur = 0;
            });

            const lettersThatHitBottom = fallingLetters.filter(l => l.isAtBottom(gameCanvas.height));
            if (lettersThatHitBottom.length > 0) {
                gameLives -= lettersThatHitBottom.length;
                fallingLetters = fallingLetters.filter(l => !l.isAtBottom(gameCanvas.height));
                updateGameUI();

                if (gameLives <= 0) {
                    endGame();
                    return;
                }
            }

            if (closestLetter) {
                document.getElementById('gameStatus').textContent = `Say: ${closestLetter.letter}`;
            } else {
                document.getElementById('gameStatus').textContent = 'Get ready...';
            }

            gameAnimationFrame = requestAnimationFrame(gameLoop);
        }

        function analyzeGameAudio() {
            if (!gameRunning) return;
            requestAnimationFrame(analyzeGameAudio);

            analyser.getByteFrequencyData(dataArray);

            const pattern = downsampleFrequencies(dataArray, PATTERN_BINS);
            gamePatternBuffer.push(pattern);

            if (gamePatternBuffer.length > PATTERN_LENGTH) {
                gamePatternBuffer.shift();
            }

            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volume = (sum / dataArray.length / 128) * 100;

            document.getElementById('gameVolume').textContent = Math.round(volume) + '%';
            document.getElementById('gameVolumeFill').style.width = volume + '%';

            drawGameSpectrum();

            const peakEnergy = Math.max(...pattern);
            const avgEnergy = pattern.reduce((a, b) => a + b, 0) / pattern.length;
            const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;

            // Skip detection if playing back a recording
            if (isPlayingRecording) {
                return;
            }

            if (gamePatternBuffer.length === PATTERN_LENGTH) {
                const closestLetter = getClosestLetter();
                if (!closestLetter) return;

                const NASALS = ['M', 'N'];
                const FRICATIVES = ['F', 'S', 'V', 'Z', 'H'];
                const LIQUIDS = ['L', 'R'];
                const isNasal = NASALS.includes(closestLetter.letter);
                const isFricative = FRICATIVES.includes(closestLetter.letter);
                const isLiquid = LIQUIDS.includes(closestLetter.letter);

                let volumeThreshold = 15;
                let concentrationThreshold = 2.0;

                if (isNasal || isLiquid) {
                    volumeThreshold = 8;
                    concentrationThreshold = 1.3;
                } else if (isFricative) {
                    volumeThreshold = 10;
                    concentrationThreshold = 1.8;
                }

                if (volume > volumeThreshold && energyConcentration > concentrationThreshold) {
                    const results = testAllPlosiveStrategies(gamePatternBuffer, closestLetter.letter);
                    const result = results[0];
                    const score = Math.max(0, Math.min(100, result.score || 0));
                    const prediction = result.predictedLetter || '?';
                    const isCorrect = prediction === closestLetter.letter;

                    if (isCorrect && score > 80) {
                        handleCorrectMatch(closestLetter);
                    }
                }
            }
        }

        function drawGameSpectrum() {
            if (!gameSpectrumCanvas) return;

            const width = gameSpectrumCanvas.width;
            const height = gameSpectrumCanvas.height;

            gameSpectrumCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            gameSpectrumCtx.fillRect(0, 0, width, height);

            const barWidth = width / dataArray.length * 2.5;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * height;
                const hue = (i / dataArray.length) * 120 + 100;
                gameSpectrumCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                gameSpectrumCtx.fillRect(x, height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        function getClosestLetter() {
            if (fallingLetters.length === 0) return null;

            let closest = fallingLetters[0];
            let minDistance = closest.getDistance(gameCanvas.height);

            fallingLetters.forEach(letter => {
                const distance = letter.getDistance(gameCanvas.height);
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = letter;
                }
            });

            return closest;
        }

        function handleCorrectMatch(letter) {
            fallingLetters = fallingLetters.filter(l => l !== letter);
            gameScore++;
            gamePatternBuffer = [];

            if (gameScore % 10 === 0) {
                gameSpeed += 0.2;
            }

            updateGameUI();
            document.getElementById('gameStatus').textContent = `‚úì Got ${letter.letter}! +1`;

            setTimeout(() => {
                const closest = getClosestLetter();
                if (closest) {
                    document.getElementById('gameStatus').textContent = `Say: ${closest.letter}`;
                }
            }, 500);
        }

        function endGame() {
            gameRunning = false;
            document.getElementById('gameBtn').textContent = '‚ñ∂ Start Game';
            document.getElementById('gameStatus').textContent = `GAME OVER! Final Score: ${gameScore}`;

            gameCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

            gameCtx.fillStyle = '#F44336';
            gameCtx.font = 'bold 60px Arial';
            gameCtx.textAlign = 'center';
            gameCtx.fillText('GAME OVER', gameCanvas.width / 2, gameCanvas.height / 2 - 40);

            gameCtx.fillStyle = '#FDD835';
            gameCtx.font = 'bold 40px Arial';
            gameCtx.fillText(`Score: ${gameScore}`, gameCanvas.width / 2, gameCanvas.height / 2 + 20);
        }

        // ========== LEVEL 1 LEARNING GAME ==========

        const VOWELS_LEARNING = ['A', 'E', 'I', 'O', 'U'];
        let level1Running = false;
        let level1State = {
            phase: 'intro',
            currentVowelIndex: 0,
            repetition: 0,
            mode: 'listen',
            mixedRound: 0,
            learnedVowels: [],
            demoPattern: [],
            demoIndex: 0
        };
        let level1PatternBuffer = [];
        let level1Canvas, level1CanvasCtx;

        async function toggleLevel1() {
            if (level1Running) {
                stopLevel1();
            } else {
                if (!audioContext) {
                    await setupAudio();
                }
                startLevel1();
            }
        }

        function startLevel1() {
            level1Running = true;
            level1State = {
                phase: 'teach',
                currentVowelIndex: 0,
                repetition: 0,
                mode: 'listen',
                mixedRound: 0,
                learnedVowels: [],
                demoPattern: [],
                demoIndex: 0
            };
            level1PatternBuffer = [];

            level1Canvas = document.getElementById('level1SpectrumCanvas');
            level1CanvasCtx = level1Canvas.getContext('2d');
            level1Canvas.width = 800;
            level1Canvas.height = 120;

            document.getElementById('level1Btn').textContent = '‚è∏ Stop';

            nextLevel1Step();
            analyzeLevel1Audio();
        }

        function stopLevel1() {
            level1Running = false;
            document.getElementById('level1Btn').textContent = '‚ñ∂ Start Level 1';
            document.getElementById('level1Letter').textContent = '?';
            document.getElementById('level1Instruction').textContent = 'Stopped';
        }

        function nextLevel1Step() {
            if (!level1Running) return;

            const state = level1State;
            const currentLetter = VOWELS_LEARNING[state.currentVowelIndex];

            if (state.phase === 'teach') {
                if (state.mode === 'listen') {
                    if (state.repetition < 5) {
                        showLevel1Letter(currentLetter);
                        document.getElementById('level1Instruction').textContent = `üëÇ Listen: ${currentLetter}`;
                        document.getElementById('level1Mode').textContent = 'Listen';
                        document.getElementById('level1Progress').textContent = `${state.repetition + 1}/5`;

                        setTimeout(() => {
                            playPhonemeSound(currentLetter);
                            state.repetition++;
                            setTimeout(() => nextLevel1Step(), 1500);
                        }, 500);
                    } else {
                        state.repetition = 0;
                        state.mode = 'practice';
                        nextLevel1Step();
                    }
                } else if (state.mode === 'practice') {
                    if (state.repetition < 5) {
                        showLevel1Letter(currentLetter);
                        document.getElementById('level1Instruction').textContent = `üé§ Your turn! Say: ${currentLetter}`;
                        document.getElementById('level1Mode').textContent = 'Practice';
                        document.getElementById('level1Progress').textContent = `${state.repetition + 1}/5`;
                    } else {
                        state.learnedVowels.push(currentLetter);

                        if (state.learnedVowels.length >= 2) {
                            state.phase = 'demo';
                            state.demoPattern = generateMixedPattern(state.learnedVowels);
                            state.demoIndex = 0;
                            state.repetition = 0;
                            nextLevel1Step();
                        } else {
                            state.currentVowelIndex++;
                            if (state.currentVowelIndex >= VOWELS_LEARNING.length) {
                                completeLevel1();
                            } else {
                                state.repetition = 0;
                                state.mode = 'listen';
                                nextLevel1Step();
                            }
                        }
                    }
                }
            } else if (state.phase === 'demo') {
                if (state.demoIndex === 0) {
                    document.getElementById('level1Instruction').textContent = `üëÄ Watch! I'll show you the pattern first...`;
                }

                if (state.demoIndex < state.demoPattern.length) {
                    const letter = state.demoPattern[state.demoIndex];
                    showLevel1Letter(letter);
                    document.getElementById('level1Mode').textContent = 'Demo';

                    setTimeout(() => {
                        playPhonemeSound(letter);
                        state.demoIndex++;
                        setTimeout(() => nextLevel1Step(), 1500);
                    }, 500);
                } else {
                    state.phase = 'mixed';
                    state.mixedRound = 0;
                    state.repetition = 0;
                    nextLevel1Step();
                }
            } else if (state.phase === 'mixed') {
                if (state.mixedRound < 5) {
                    const letter = state.learnedVowels[state.repetition % state.learnedVowels.length];
                    showLevel1Letter(letter);
                    document.getElementById('level1Instruction').textContent = `üé§ Say: ${letter}`;
                    document.getElementById('level1Mode').textContent = 'Mixed';
                    document.getElementById('level1Progress').textContent = `Round ${state.mixedRound + 1}/5`;
                } else {
                    state.currentVowelIndex++;
                    if (state.currentVowelIndex >= VOWELS_LEARNING.length) {
                        completeLevel1();
                    } else {
                        state.phase = 'teach';
                        state.mode = 'listen';
                        state.repetition = 0;
                        nextLevel1Step();
                    }
                }
            }
        }

        function generateMixedPattern(vowels) {
            const pattern = [];
            for (let i = 0; i < vowels.length; i++) {
                pattern.push(vowels[i]);
                if (i < vowels.length - 1) {
                    pattern.push(vowels[i + 1]);
                }
            }
            return pattern;
        }

        function showLevel1Letter(letter) {
            const letterEl = document.getElementById('level1Letter');
            letterEl.textContent = letter;
            letterEl.classList.remove('fade-in');
            void letterEl.offsetWidth;
            letterEl.classList.add('fade-in');
        }

        function analyzeLevel1Audio() {
            if (!level1Running) return;
            requestAnimationFrame(analyzeLevel1Audio);

            analyser.getByteFrequencyData(dataArray);

            drawLevel1Spectrum();

            const pattern = downsampleFrequencies(dataArray, PATTERN_BINS);
            level1PatternBuffer.push(pattern);

            if (level1PatternBuffer.length > PATTERN_LENGTH) {
                level1PatternBuffer.shift();
            }

            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volume = (sum / dataArray.length / 128) * 100;

            const peakEnergy = Math.max(...pattern);
            const avgEnergy = pattern.reduce((a, b) => a + b, 0) / pattern.length;
            const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;

            if (level1State.phase === 'teach' && level1State.mode === 'practice' && level1PatternBuffer.length === PATTERN_LENGTH) {
                const targetLetter = VOWELS_LEARNING[level1State.currentVowelIndex];

                if (volume > 15 && energyConcentration > 2.0) {
                    const results = testAllPlosiveStrategies(level1PatternBuffer, targetLetter);
                    const result = results[0];
                    const score = Math.max(0, Math.min(100, result.score || 0));
                    const prediction = result.predictedLetter || '?';
                    const isCorrect = prediction === targetLetter;

                    document.getElementById('level1Status').textContent = `Prediction: ${prediction} | Score: ${Math.round(score)}%`;
                    document.getElementById('level1ConfidenceFill').style.width = score + '%';

                    if (isCorrect && score > 80) {
                        celebrateLevel1Match();
                        level1State.repetition++;
                        level1PatternBuffer = [];
                        setTimeout(() => nextLevel1Step(), 1000);
                    }
                }
            } else if (level1State.phase === 'mixed' && level1PatternBuffer.length === PATTERN_LENGTH) {
                const targetLetter = level1State.learnedVowels[level1State.repetition % level1State.learnedVowels.length];

                if (volume > 15 && energyConcentration > 2.0) {
                    const results = testAllPlosiveStrategies(level1PatternBuffer, targetLetter);
                    const result = results[0];
                    const score = Math.max(0, Math.min(100, result.score || 0));
                    const prediction = result.predictedLetter || '?';
                    const isCorrect = prediction === targetLetter;

                    document.getElementById('level1Status').textContent = `Prediction: ${prediction} | Score: ${Math.round(score)}%`;
                    document.getElementById('level1ConfidenceFill').style.width = score + '%';

                    if (isCorrect && score > 80) {
                        celebrateLevel1Match();
                        level1State.repetition++;
                        level1PatternBuffer = [];

                        if (level1State.repetition >= level1State.learnedVowels.length * 2) {
                            level1State.mixedRound++;
                            level1State.repetition = 0;
                        }

                        setTimeout(() => nextLevel1Step(), 1000);
                    }
                }
            }
        }

        function drawLevel1Spectrum() {
            if (!level1Canvas) return;

            const width = level1Canvas.width;
            const height = level1Canvas.height;

            level1CanvasCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            level1CanvasCtx.fillRect(0, 0, width, height);

            const barWidth = width / dataArray.length * 2.5;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * height;
                const hue = (i / dataArray.length) * 120 + 100;
                level1CanvasCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                level1CanvasCtx.fillRect(x, height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        function celebrateLevel1Match() {
            const letterEl = document.getElementById('level1Letter');

            // Play success sound
            if (audioContext) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.4);
            }

            // Exciting animation sequence
            letterEl.style.transition = 'all 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55)';

            // Bounce and color sequence
            letterEl.style.transform = 'scale(1.5) rotate(5deg)';
            letterEl.style.color = '#FDD835';

            setTimeout(() => {
                letterEl.style.transform = 'scale(1.3) rotate(-5deg)';
                letterEl.style.color = '#7CB342';
            }, 150);

            setTimeout(() => {
                letterEl.style.transform = 'scale(1.6) rotate(0deg)';
                letterEl.style.color = '#00BCD4';
            }, 300);

            setTimeout(() => {
                letterEl.style.transform = 'scale(1.2)';
                letterEl.style.color = '#FF5722';
            }, 450);

            setTimeout(() => {
                letterEl.style.transform = 'scale(1.4)';
                letterEl.style.color = '#9C27B0';
            }, 600);

            setTimeout(() => {
                letterEl.style.transition = 'all 0.3s ease-out';
                letterEl.style.transform = 'scale(1)';
                letterEl.style.color = '#FDD835';
            }, 800);

            // Create confetti particles
            createLevel1Confetti(letterEl);
        }

        function createLevel1Confetti(centerEl) {
            const container = centerEl.parentElement;
            const rect = centerEl.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const colors = ['#FDD835', '#7CB342', '#00BCD4', '#FF5722', '#9C27B0'];

            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.style.position = 'fixed';
                particle.style.left = centerX + 'px';
                particle.style.top = centerY + 'px';
                particle.style.width = '10px';
                particle.style.height = '10px';
                particle.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                particle.style.pointerEvents = 'none';
                particle.style.zIndex = '9999';

                document.body.appendChild(particle);

                const angle = (Math.PI * 2 * i) / 20;
                const velocity = 100 + Math.random() * 100;
                const vx = Math.cos(angle) * velocity;
                const vy = Math.sin(angle) * velocity;

                let x = 0, y = 0, time = 0;
                const gravity = 500;

                const animate = () => {
                    time += 0.016; // ~60fps
                    x = vx * time;
                    y = vy * time + 0.5 * gravity * time * time;

                    particle.style.transform = `translate(${x}px, ${y}px) rotate(${time * 360}deg)`;
                    particle.style.opacity = Math.max(0, 1 - time * 1.5);

                    if (time < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        particle.remove();
                    }
                };

                requestAnimationFrame(animate);
            }
        }

        function completeLevel1() {
            level1Running = false;
            document.getElementById('level1Letter').textContent = 'üéâ';
            document.getElementById('level1Instruction').textContent = 'Amazing! You completed Level 1!';
            document.getElementById('level1Btn').textContent = 'üîÑ Play Again';
        }

        // Initialize
        (async () => {
            // Set up auth state listener
            handleAuthStateChange();

            // Check if user is authenticated
            const { data: { session } } = await supabase.auth.getSession();

            if (session?.user) {
                // Authenticated user - load their profiles
                console.log('‚úÖ Authenticated user:', session.user.email);
                await loadUserProfiles(session.user.id);
            } else {
                // Guest user - check for named profile first, then guest profile
                const savedProfileName = localStorage.getItem('currentProfile');

                if (savedProfileName && savedProfileName !== 'Default') {
                    // Has a saved named profile - load it
                    console.log('üìù Loading named profile:', savedProfileName);
                    currentProfile = savedProfileName;

                    const profile = await getOrCreateProfile(savedProfileName);
                    if (profile) {
                        currentProfileId = profile.id;
                        console.log(`‚úÖ Loaded profile: ${savedProfileName} (${profile.id.substring(0, 8)}...)`);
                    }
                } else {
                    // No named profile - use anonymous guest system
                    console.log('üìù Guest mode - creating anonymous profile');

                    // Check if we have a saved guest profile ID
                    const savedGuestId = localStorage.getItem('guestProfileId');

                    if (savedGuestId) {
                        // Try to load existing guest profile
                        console.log('üîç Attempting to load saved guest profile:', savedGuestId);
                        try {
                            const { data: existingProfile, error } = await supabase
                                .from('profiles')
                                .select('*')
                                .eq('id', savedGuestId)
                                .is('user_id', null)
                                .single();

                            if (error) {
                                console.error('‚ùå Error loading guest profile:', error);
                                throw error;
                            }

                            if (existingProfile) {
                                currentProfileId = existingProfile.id;
                                guestProfileId = existingProfile.id;
                                console.log('‚úÖ Loaded existing guest profile:', existingProfile.id);
                            } else {
                                console.log('‚ö†Ô∏è Profile not found, creating new');
                                await createAnonymousProfile();
                            }
                        } catch (error) {
                            console.error('‚ö†Ô∏è Failed to load guest profile, creating new:', error.message);
                            await createAnonymousProfile();
                        }
                    } else {
                        // No saved profile - create new anonymous profile
                        console.log('üÜï No saved profile, creating new');
                        await createAnonymousProfile();
                    }
                }
            }

            // Load calibration data
            await loadCalibration();

            // Load profile dropdown
            loadProfiles();

            // Create calibration grid
            createCalibrationGrid();
            updateCalibrationStats();
        })();

        async function createAnonymousProfile() {
            try {
                const { data: newProfile, error } = await supabase
                    .from('profiles')
                    .insert([{
                        name: `Guest_${Date.now()}`,
                        user_id: null  // Explicitly anonymous
                    }])
                    .select()
                    .single();

                if (error) throw error;

                currentProfileId = newProfile.id;
                guestProfileId = newProfile.id;

                // Save to localStorage
                localStorage.setItem('guestProfileId', newProfile.id);

                console.log('‚úÖ Created anonymous profile:', newProfile.id);
            } catch (error) {
                console.error('‚ùå Error creating anonymous profile:', error);
                alert('Failed to initialize app. Please refresh the page.');
            }
        }

        // ===================================
        // NEW GAME SYSTEM
        // ===================================

        function selectGame(gameName) {
            document.getElementById('gameSelector').classList.remove('active');

            if (gameName === 'smash') {
                document.getElementById('smashGame').classList.add('active');
                initSmashGame();
            } else if (gameName === 'treasure') {
                document.getElementById('treasureGame').classList.add('active');
                initTreasureGame();
            } else if (gameName === 'clock') {
                document.getElementById('clockGame').classList.add('active');
                initClockGame();
            }
        }

        function backToGameSelector() {
            document.querySelectorAll('.game-screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById('gameSelector').classList.add('active');

            stopSmashGame();
            stopTreasureGame();
            stopClockGame();
        }

        // ===================================
        // LETTER SMASH GAME
        // ===================================

        let smashRunning = false;
        let smashScore = 0;
        let smashCombo = 0;
        let smashHighScore = parseInt(localStorage.getItem('smashHighScore') || '0');
        let smashCurrentLetter = null;
        let smashSpawnTimeout = null;
        let smashAudioAnalysisFrame = null;
        let smashPatternBuffer = [];

        function initSmashGame() {
            document.getElementById('smashHighScore').textContent = smashHighScore;
            createTreasureMap();
            createClockProgress();
        }

        async function toggleSmashGame() {
            if (smashRunning) {
                stopSmashGame();
            } else {
                if (Object.keys(calibrationData).length === 0) {
                    alert('Please calibrate at least one phoneme first!');
                    return;
                }
                if (!audioContext) {
                    await setupAudio();
                }
                startSmashGame();
            }
        }

        function startSmashGame() {
            smashRunning = true;
            smashScore = 0;
            smashCombo = 0;
            updateSmashUI();

            document.getElementById('smashBtn').textContent = '‚è∏ Pause';
            document.getElementById('smashStatus').textContent = 'Say the letter sound to smash it!';

            spawnSmashLetter();
            analyzeSmashAudio();
        }

        function stopSmashGame() {
            smashRunning = false;
            document.getElementById('smashBtn').textContent = '‚ñ∂ Start Game';

            if (smashSpawnTimeout) {
                clearTimeout(smashSpawnTimeout);
            }
            if (smashAudioAnalysisFrame) {
                cancelAnimationFrame(smashAudioAnalysisFrame);
            }
            if (smashCurrentLetter) {
                const elem = document.querySelector('.smash-letter');
                if (elem) elem.remove();
                smashCurrentLetter = null;
            }
        }

        function restartSmashGame() {
            stopSmashGame();
            setTimeout(() => {
                if (audioContext) {
                    startSmashGame();
                }
            }, 100);
        }

        function spawnSmashLetter() {
            if (!smashRunning) return;

            const calibratedLetters = Object.keys(calibrationData);
            if (calibratedLetters.length === 0) return;

            const container = document.getElementById('smashContainer');
            const letter = calibratedLetters[Math.floor(Math.random() * calibratedLetters.length)];

            const letterElem = document.createElement('div');
            letterElem.className = 'smash-letter';
            letterElem.textContent = letter;
            letterElem.style.left = Math.random() * (container.offsetWidth - 120) + 'px';
            letterElem.style.top = Math.random() * (container.offsetHeight - 120) + 'px';

            container.appendChild(letterElem);
            smashCurrentLetter = letter;
        }

        function smashLetter() {
            if (!smashCurrentLetter) return;

            const letterElem = document.querySelector('.smash-letter');
            if (!letterElem) return;

            const rect = letterElem.getBoundingClientRect();
            const x = rect.left + rect.width / 2;
            const y = rect.top + rect.height / 2;

            letterElem.remove();

            createExplosion(x, y);

            smashScore += (10 + smashCombo * 5);
            smashCombo++;

            if (smashScore > smashHighScore) {
                smashHighScore = smashScore;
                localStorage.setItem('smashHighScore', smashHighScore.toString());
            }

            updateSmashUI();

            smashCurrentLetter = null;
            smashSpawnTimeout = setTimeout(spawnSmashLetter, 800);
        }

        function createExplosion(x, y) {
            const explosions = ['üí•', '‚≠ê', '‚ú®', 'üåü', 'üí´'];
            const container = document.getElementById('smashContainer');
            const containerRect = container.getBoundingClientRect();

            for (let i = 0; i < 5; i++) {
                const explosion = document.createElement('div');
                explosion.className = 'smash-explosion';
                explosion.textContent = explosions[Math.floor(Math.random() * explosions.length)];
                explosion.style.left = (x - containerRect.left + (Math.random() - 0.5) * 100) + 'px';
                explosion.style.top = (y - containerRect.top + (Math.random() - 0.5) * 100) + 'px';

                container.appendChild(explosion);

                setTimeout(() => explosion.remove(), 600);
            }
        }

        function updateSmashUI() {
            document.getElementById('smashScore').textContent = smashScore;
            document.getElementById('smashCombo').textContent = smashCombo + 'x';
            document.getElementById('smashHighScore').textContent = smashHighScore;
        }

        function analyzeSmashAudio() {
            if (!smashRunning) return;

            analyser.getByteFrequencyData(dataArray);

            const volume = Math.max(...dataArray);
            const volumePercent = Math.round((volume / 255) * 100);

            if (smashCurrentLetter && volume > 40) {
                const pattern = extractPattern(dataArray);
                smashPatternBuffer.push(pattern);

                if (smashPatternBuffer.length > 5) {
                    smashPatternBuffer.shift();
                }

                if (smashPatternBuffer.length >= 3 && volume > 50) {
                    const results = testAllPlosiveStrategies(smashPatternBuffer, smashCurrentLetter);
                    const result = results[0];
                    const score = Math.max(0, Math.min(100, result.score || 0));
                    const prediction = result.predictedLetter || '?';

                    if (prediction === smashCurrentLetter && score > 80) {
                        smashLetter();
                        smashPatternBuffer = [];
                    }
                }
            }

            if (volume < 30) {
                smashPatternBuffer = [];
            }

            smashAudioAnalysisFrame = requestAnimationFrame(analyzeSmashAudio);
        }

        // ===================================
        // TREASURE HUNT GAME
        // ===================================

        let treasureRunning = false;
        let treasureUnlocked = 0;
        let treasureCoins = 0;
        let treasureCurrentLetter = null;
        let treasureChests = [];
        let treasureAudioAnalysisFrame = null;
        let treasurePatternBuffer = [];

        function initTreasureGame() {
            createTreasureMap();
        }

        function createTreasureMap() {
            const map = document.getElementById('treasureMap');
            map.innerHTML = '';
            treasureChests = [];

            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');

            alphabet.forEach((letter, index) => {
                const chest = document.createElement('div');
                chest.className = 'treasure-chest locked';
                chest.id = `chest-${letter}`;
                chest.innerHTML = `
                    <div class="chest-letter">${letter}</div>
                    <div class="chest-icon">üîí</div>
                `;

                map.appendChild(chest);
                treasureChests.push({ letter, unlocked: false, element: chest });
            });
        }

        async function toggleTreasureGame() {
            if (treasureRunning) {
                stopTreasureGame();
            } else {
                if (Object.keys(calibrationData).length === 0) {
                    alert('Please calibrate at least one phoneme first!');
                    return;
                }
                if (!audioContext) {
                    await setupAudio();
                }
                startTreasureGame();
            }
        }

        function startTreasureGame() {
            treasureRunning = true;
            treasureUnlocked = 0;
            treasureCoins = 0;
            updateTreasureUI();

            createTreasureMap();

            document.getElementById('treasureBtn').textContent = '‚è∏ Pause';
            document.getElementById('treasureStatus').textContent = 'Say the highlighted letter sound!';

            selectNextTreasure();
            analyzeTreasureAudio();
        }

        function stopTreasureGame() {
            treasureRunning = false;
            document.getElementById('treasureBtn').textContent = '‚ñ∂ Start Game';

            if (treasureAudioAnalysisFrame) {
                cancelAnimationFrame(treasureAudioAnalysisFrame);
            }
        }

        function restartTreasureGame() {
            stopTreasureGame();
            setTimeout(() => {
                if (audioContext) {
                    startTreasureGame();
                }
            }, 100);
        }

        function selectNextTreasure() {
            const calibratedLetters = Object.keys(calibrationData);
            const availableChests = treasureChests.filter(c =>
                !c.unlocked && calibratedLetters.includes(c.letter)
            );

            if (availableChests.length === 0) {
                treasureRunning = false;
                document.getElementById('treasureStatus').textContent =
                    `üéâ You found all treasures! Coins: ${treasureCoins}`;
                document.getElementById('treasureBtn').textContent = '‚ñ∂ Start Game';
                return;
            }

            treasureChests.forEach(c => c.element.classList.remove('current'));

            const nextChest = availableChests[0];
            nextChest.element.classList.add('current');
            treasureCurrentLetter = nextChest.letter;
        }

        function unlockTreasure() {
            const chest = treasureChests.find(c => c.letter === treasureCurrentLetter);
            if (!chest || chest.unlocked) return;

            chest.unlocked = true;
            chest.element.classList.remove('locked', 'current');
            chest.element.classList.add('unlocked');
            chest.element.querySelector('.chest-icon').textContent = '‚úÖ';

            const coins = Math.floor(Math.random() * 10) + 5;
            treasureCoins += coins;
            treasureUnlocked++;

            createCoinShower(chest.element);

            updateTreasureUI();

            setTimeout(selectNextTreasure, 500);
        }

        function createCoinShower(chestElement) {
            const rect = chestElement.getBoundingClientRect();
            const mapRect = document.getElementById('treasureMap').getBoundingClientRect();

            for (let i = 0; i < 8; i++) {
                const coin = document.createElement('div');
                coin.className = 'coin-shower';
                coin.textContent = 'ü™ô';
                coin.style.left = (rect.left - mapRect.left + rect.width / 2) + 'px';
                coin.style.top = (rect.top - mapRect.top + rect.height / 2) + 'px';
                coin.style.animationDelay = (i * 0.05) + 's';

                document.getElementById('treasureMap').appendChild(coin);

                setTimeout(() => coin.remove(), 1000);
            }
        }

        function updateTreasureUI() {
            document.getElementById('treasureUnlocked').textContent = treasureUnlocked;
            document.getElementById('treasureCoins').textContent = treasureCoins;
        }

        function analyzeTreasureAudio() {
            if (!treasureRunning) return;

            analyser.getByteFrequencyData(dataArray);

            const volume = Math.max(...dataArray);

            if (treasureCurrentLetter && volume > 40) {
                const pattern = extractPattern(dataArray);
                treasurePatternBuffer.push(pattern);

                if (treasurePatternBuffer.length > 5) {
                    treasurePatternBuffer.shift();
                }

                if (treasurePatternBuffer.length >= 3 && volume > 50) {
                    const results = testAllPlosiveStrategies(treasurePatternBuffer, treasureCurrentLetter);
                    const result = results[0];
                    const score = Math.max(0, Math.min(100, result.score || 0));
                    const prediction = result.predictedLetter || '?';

                    if (prediction === treasureCurrentLetter && score > 80) {
                        unlockTreasure();
                        treasurePatternBuffer = [];
                    }
                }
            }

            if (volume < 30) {
                treasurePatternBuffer = [];
            }

            treasureAudioAnalysisFrame = requestAnimationFrame(analyzeTreasureAudio);
        }

        // ===================================
        // BEAT THE CLOCK GAME
        // ===================================

        let clockRunning = false;
        let clockTimeRemaining = 60;
        let clockCurrentIndex = 0;
        let clockStartTime = 0;
        let clockBestTime = parseFloat(localStorage.getItem('clockBestTime') || '0');
        let clockTimerInterval = null;
        let clockAudioAnalysisFrame = null;
        let clockPatternBuffer = [];
        let clockAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');

        function initClockGame() {
            createClockProgress();
            if (clockBestTime > 0) {
                document.getElementById('clockBestTime').textContent = clockBestTime.toFixed(1) + 's';
            }
        }

        function createClockProgress() {
            const progress = document.getElementById('clockProgress');
            progress.innerHTML = '';

            clockAlphabet.forEach((letter, index) => {
                const dot = document.createElement('div');
                dot.className = 'clock-progress-dot';
                dot.textContent = letter;
                dot.id = `clock-dot-${letter}`;
                progress.appendChild(dot);
            });
        }

        async function toggleClockGame() {
            if (clockRunning) {
                stopClockGame();
            } else {
                if (Object.keys(calibrationData).length === 0) {
                    alert('Please calibrate at least one phoneme first!');
                    return;
                }
                if (!audioContext) {
                    await setupAudio();
                }
                startClockGame();
            }
        }

        function startClockGame() {
            clockRunning = true;
            clockTimeRemaining = 60;
            clockCurrentIndex = 0;
            clockStartTime = Date.now();

            document.getElementById('clockBtn').textContent = '‚è∏ Pause';
            document.getElementById('clockStatus').textContent = 'Say each letter sound!';

            createClockProgress();
            updateClockLetter();

            clockTimerInterval = setInterval(updateClockTimer, 100);
            analyzeClockAudio();
        }

        function stopClockGame() {
            clockRunning = false;
            document.getElementById('clockBtn').textContent = '‚ñ∂ Start Game';

            if (clockTimerInterval) {
                clearInterval(clockTimerInterval);
            }
            if (clockAudioAnalysisFrame) {
                cancelAnimationFrame(clockAudioAnalysisFrame);
            }
        }

        function restartClockGame() {
            stopClockGame();
            setTimeout(() => {
                if (audioContext) {
                    startClockGame();
                }
            }, 100);
        }

        function updateClockTimer() {
            if (!clockRunning) return;

            clockTimeRemaining = Math.max(0, 60 - (Date.now() - clockStartTime) / 1000);

            const timerElem = document.getElementById('clockTimer');
            timerElem.textContent = clockTimeRemaining.toFixed(1) + 's';

            if (clockTimeRemaining < 10) {
                timerElem.classList.add('warning');
            } else {
                timerElem.classList.remove('warning');
            }

            if (clockTimeRemaining <= 0) {
                clockRunning = false;
                clearInterval(clockTimerInterval);
                document.getElementById('clockStatus').textContent =
                    `‚è∞ Time's up! You got ${clockCurrentIndex} letters!`;
                document.getElementById('clockBtn').textContent = '‚ñ∂ Start Game';
            }
        }

        function updateClockLetter() {
            if (clockCurrentIndex >= clockAlphabet.length) {
                const timeTaken = (Date.now() - clockStartTime) / 1000;
                clockRunning = false;

                if (clockBestTime === 0 || timeTaken < clockBestTime) {
                    clockBestTime = timeTaken;
                    localStorage.setItem('clockBestTime', clockBestTime.toString());
                    document.getElementById('clockBestTime').textContent = clockBestTime.toFixed(1) + 's';
                }

                document.getElementById('clockStatus').textContent =
                    `üéâ Complete! Time: ${timeTaken.toFixed(1)}s`;
                document.getElementById('clockBtn').textContent = '‚ñ∂ Start Game';
                clearInterval(clockTimerInterval);
                return;
            }

            const letter = clockAlphabet[clockCurrentIndex];
            document.getElementById('clockLetter').textContent = letter;

            document.querySelectorAll('.clock-progress-dot').forEach(dot => {
                dot.classList.remove('current', 'completed');
            });

            for (let i = 0; i < clockCurrentIndex; i++) {
                document.getElementById(`clock-dot-${clockAlphabet[i]}`).classList.add('completed');
            }
            document.getElementById(`clock-dot-${letter}`).classList.add('current');
        }

        function clockLetterCorrect() {
            const letterElem = document.getElementById('clockLetter');
            letterElem.classList.add('success');

            setTimeout(() => {
                letterElem.classList.remove('success');
                clockCurrentIndex++;
                updateClockLetter();
            }, 300);
        }

        function analyzeClockAudio() {
            if (!clockRunning) return;

            analyser.getByteFrequencyData(dataArray);

            const volume = Math.max(...dataArray);
            const currentLetter = clockAlphabet[clockCurrentIndex];

            if (currentLetter && volume > 40) {
                const pattern = extractPattern(dataArray);
                clockPatternBuffer.push(pattern);

                if (clockPatternBuffer.length > 5) {
                    clockPatternBuffer.shift();
                }

                if (clockPatternBuffer.length >= 3 && volume > 50) {
                    const results = testAllPlosiveStrategies(clockPatternBuffer, currentLetter);
                    const result = results[0];
                    const score = Math.max(0, Math.min(100, result.score || 0));
                    const prediction = result.predictedLetter || '?';

                    if (prediction === currentLetter && score > 80) {
                        clockLetterCorrect();
                        clockPatternBuffer = [];
                    }
                }
            }

            if (volume < 30) {
                clockPatternBuffer = [];
            }

            clockAudioAnalysisFrame = requestAnimationFrame(analyzeClockAudio);
        }
    </script>
</body>
</html>
