<!--
    ReadingClub v1.4.0

    Version 1.4 Changes:
    - Removed localStorage fallback for calibration data (Supabase-only)
    - Removed localStorage audio storage (Supabase Storage-only)
    - Audio playback now uses Supabase public URLs
    - Fresh start: no migration from old localStorage data
    - Added Google OAuth + Magic Link authentication
    - Anonymous profiles created on first visit (zero friction)
    - Optional signup after 3 letters calibrated
    - Guest profiles automatically linked to auth account on signup

    Data Storage:
    ‚úÖ Supabase Database: calibration patterns + metadata + user accounts
    ‚úÖ Supabase Storage: audio recordings (WebM)
    ‚úÖ Supabase Auth: Google OAuth + Magic Link email
    ‚úÖ localStorage: guest profile ID + attempt history only

    User Flow:
    1. First visit ‚Üí Anonymous Supabase profile created automatically
    2. Start calibrating immediately (zero friction)
    3. After 3 letters ‚Üí Optional signup prompt (dismissible)
    4. On signup ‚Üí Guest profile linked to authenticated account
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ReadingClub - Learn Phonics with Your Voice</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
            color: white;
        }
        h1 {
            font-size: 48px;
            margin: 20px 0;
            text-shadow: 0 0 20px rgba(124, 179, 66, 0.8);
        }
        .subtitle {
            font-size: 16px;
            color: #ddd;
            margin-bottom: 20px;
        }
        .container {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 30px;
            padding: 40px;
            width: 900px;
            max-width: 95vw;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }
        .tab {
            padding: 15px 30px;
            background: transparent;
            border: none;
            color: #aaa;
            font-size: 18px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        .tab.active {
            color: #FDD835;
            border-bottom-color: #FDD835;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        /* Calibration */
        .calibration-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .phoneme-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
        }
        .phoneme-card:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        .phoneme-card.recording {
            border-color: #F44336;
            background: rgba(244, 67, 54, 0.2);
            animation: pulse 1s infinite;
        }
        .phoneme-card.calibrated {
            border-color: #7CB342;
            background: rgba(124, 179, 66, 0.2);
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }
        .phoneme-letter {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .phoneme-hint {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 5px;
        }
        .phoneme-status {
            font-size: 12px;
            margin-top: 10px;
        }
        .calibration-group-header {
            grid-column: 1 / -1;
            padding: 15px 0 10px 0;
            font-size: 16px;
            font-weight: bold;
            color: #FDD835;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid rgba(253, 216, 53, 0.3);
            margin-bottom: 5px;
        }
        .calibration-group-header:first-child {
            padding-top: 0;
        }

        /* Snapshot thumbnails */
        .snapshots-container {
            display: flex;
            gap: 4px;
            margin-top: 10px;
            justify-content: center;
            min-height: 40px;
        }
        .snapshot-thumb {
            width: 50px;
            height: 40px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            border: 1px solid rgba(124, 179, 66, 0.3);
        }
        .snapshot-thumb.captured {
            border-color: #7CB342;
        }

        /* Pattern visualization */
        .pattern-preview {
            width: 100%;
            height: 60px;
            margin-top: 10px;
            border-radius: 5px;
            overflow: hidden;
        }

        /* Tuner */
        #detectedLetter {
            text-align: center;
            font-size: 180px;
            font-weight: bold;
            color: #7CB342;
            margin: 30px 0;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 10px 30px rgba(124, 179, 66, 0.5);
            transition: all 0.15s;
        }
        #detectedLetter.active {
            transform: scale(1.1);
            color: #FDD835;
            text-shadow: 0 0 50px rgba(253, 216, 53, 0.8);
        }
        .confidence-bar {
            width: 100%;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }
        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #7CB342, #FDD835);
            width: 0%;
            transition: width 0.1s;
        }
        #spectrumCanvas {
            width: 100%;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 20px 0;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            font-size: 14px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #FDD835;
        }
        .btn {
            padding: 12px 30px;
            background: #7CB342;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn:hover {
            background: #689F38;
        }
        .actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        .info-box {
            background: rgba(124, 179, 66, 0.1);
            border-left: 4px solid #7CB342;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            font-size: 14px;
            line-height: 1.6;
        }
        #status {
            text-align: center;
            font-size: 14px;
            color: #999;
            margin: 15px 0;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        .level1-letter {
            text-align: center;
            font-size: 180px;
            font-weight: bold;
            color: #FDD835;
            margin: 30px 0;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 10px 30px rgba(253, 216, 53, 0.5);
        }
        .level1-instruction {
            text-align: center;
            font-size: 24px;
            color: #ddd;
            margin: 20px 0;
            min-height: 40px;
        }

        /* Calibration Modal */
        .calibration-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        .calibration-modal.active {
            display: flex;
        }
        .modal-content {
            background: rgba(30, 30, 30, 0.98);
            border-radius: 30px;
            padding: 40px;
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            border: 3px solid #7CB342;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            position: relative;
        }
        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            font-size: 24px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
        }
        .modal-close:hover {
            background: rgba(255, 67, 54, 0.3);
            transform: rotate(90deg);
        }
        .modal-instructions {
            text-align: center;
            color: #ddd;
            font-size: 16px;
            margin-bottom: 20px;
        }
        .modal-letter-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        .modal-letter {
            font-size: 180px;
            font-weight: bold;
            color: #FDD835;
            cursor: pointer;
            display: inline-block;
            text-shadow: 0 10px 30px rgba(253, 216, 53, 0.5);
            transition: all 0.15s;
            text-align: center;
        }
        .modal-letter:hover {
            transform: scale(1.1);
        }
        .modal-listen-icon {
            width: 60px;
            height: 60px;
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.2s;
            filter: drop-shadow(0 2px 8px rgba(253, 216, 53, 0.4));
        }
        .modal-listen-icon:hover {
            opacity: 1;
            transform: scale(1.15);
        }
        .modal-listen-icon svg {
            width: 100%;
            height: 100%;
            fill: #FDD835;
        }
        .modal-captures {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 30px;
        }
        .modal-capture-box {
            width: 100px;
            height: 80px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(124, 179, 66, 0.3);
            border-radius: 10px;
            transition: all 0.3s;
            position: relative;
        }
        .modal-capture-box.ready {
            border-color: #FDD835;
            box-shadow: 0 0 15px rgba(253, 216, 53, 0.5);
            animation: pulse 1.5s infinite;
        }
        .modal-capture-box.recording {
            border-color: #F44336;
            background: rgba(244, 67, 54, 0.2);
            animation: pulse 0.8s infinite;
        }
        .modal-capture-box.captured {
            border-color: #7CB342;
            background: rgba(124, 179, 66, 0.1);
        }
        .modal-capture-box canvas {
            width: 100%;
            height: 100%;
        }
        .mic-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .modal-capture-box.ready .mic-icon {
            opacity: 0.7;
        }
        .mic-icon svg {
            width: 100%;
            height: 100%;
            fill: #FDD835;
            filter: drop-shadow(0 0 5px rgba(253, 216, 53, 0.5));
        }
        .click-arrow {
            position: absolute;
            bottom: 90px;
            left: 50px;
            display: none;
            animation: arrowHover 2s ease-in-out infinite, arrowPulse 1.5s ease-in-out infinite;
        }
        .click-arrow.active {
            display: block;
        }
        .click-arrow svg {
            width: 50px;
            height: 50px;
            filter: drop-shadow(0 2px 10px rgba(124, 179, 66, 0.8));
        }
        @keyframes arrowHover {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        @keyframes arrowPulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        .modal-status {
            text-align: center;
            color: #ddd;
            font-size: 18px;
            margin-top: 20px;
        }
        .modal-next-button {
            display: none;
            margin: 30px auto 0;
            width: 80px;
            height: 80px;
            background: #7CB342;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(124, 179, 66, 0.5);
            animation: nextButtonPulse 1.5s ease-in-out infinite;
        }
        .modal-next-button.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-next-button:hover {
            transform: scale(1.1);
            background: #8BC34A;
            box-shadow: 0 6px 20px rgba(124, 179, 66, 0.7);
        }
        .modal-next-button svg {
            width: 40px;
            height: 40px;
            fill: white;
        }
        @keyframes nextButtonPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Progressive Learning Game */
        .progress-letter-badge {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: #999;
        }
        .auto-cal-dot.ready {
            border-color: #FDD835;
            box-shadow: 0 0 15px rgba(253, 216, 53, 0.5);
            animation: pulse 1.5s infinite;
        }
        .auto-cal-dot.recording {
            border-color: #F44336;
            background: rgba(244, 67, 54, 0.2);
            animation: pulse 0.8s infinite;
        }
        .auto-cal-dot.captured {
            border-color: #7CB342;
            background: rgba(124, 179, 66, 0.3);
        }
        .progress-letter-badge.level1 {
            background: rgba(124, 179, 66, 0.3);
            border-color: #7CB342;
            color: #7CB342;
        }
        .progress-letter-badge.level2 {
            background: rgba(253, 216, 53, 0.3);
            border-color: #FDD835;
            color: #FDD835;
        }
        .progress-letter-badge.level3 {
            background: rgba(244, 67, 54, 0.3);
            border-color: #F44336;
            color: #F44336;
        }
        @keyframes letterPop {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        @keyframes explosionBurst {
            0% { transform: scale(0.5) rotate(0deg); opacity: 1; }
            100% { transform: scale(3) rotate(720deg); opacity: 0; }
        }

        /* Letter Smash Game */
        .smash-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            overflow: hidden;
        }
        .smash-letter {
            position: absolute;
            font-size: 120px;
            font-weight: bold;
            color: #FDD835;
            text-shadow: 0 0 30px rgba(253, 216, 53, 0.8);
            animation: smashPop 0.3s ease-out;
            cursor: pointer;
            user-select: none;
        }
        @keyframes smashPop {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .smash-explosion {
            position: absolute;
            font-size: 80px;
            animation: explode 0.6s ease-out forwards;
            pointer-events: none;
        }
        @keyframes explode {
            0% { transform: scale(1) rotate(0deg); opacity: 1; }
            100% { transform: scale(3) rotate(360deg); opacity: 0; }
        }
        .combo-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 48px;
            font-weight: bold;
            color: #F44336;
            text-shadow: 0 0 20px rgba(244, 67, 54, 0.8);
            animation: comboScale 0.3s ease-out;
        }
        @keyframes comboScale {
            0% { transform: scale(0.5); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* Treasure Hunt Game */
        .treasure-map {
            width: 100%;
            height: 600px;
            background: linear-gradient(135deg, #3a3a2a 0%, #2a2a1a 100%);
            border-radius: 20px;
            position: relative;
            overflow-y: auto;
            padding: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 15px;
            align-content: start;
        }
        .treasure-chest {
            width: 80px;
            height: 80px;
            background: rgba(139, 69, 19, 0.4);
            border: 3px solid rgba(139, 69, 19, 0.6);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        .treasure-chest:hover {
            transform: scale(1.1);
        }
        .treasure-chest.locked {
            border-color: rgba(139, 69, 19, 0.8);
            animation: chestWiggle 2s ease-in-out infinite;
        }
        .treasure-chest.unlocked {
            background: rgba(253, 216, 53, 0.3);
            border-color: #FDD835;
            box-shadow: 0 0 20px rgba(253, 216, 53, 0.5);
        }
        .treasure-chest.current {
            border-color: #F44336;
            box-shadow: 0 0 30px rgba(244, 67, 54, 0.8);
            animation: chestPulse 1s ease-in-out infinite;
        }
        @keyframes chestWiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-2deg); }
            75% { transform: rotate(2deg); }
        }
        @keyframes chestPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }
        .chest-letter {
            font-size: 32px;
            font-weight: bold;
            color: #FDD835;
        }
        .chest-icon {
            font-size: 24px;
            position: absolute;
            bottom: 5px;
        }
        .coin-shower {
            position: absolute;
            font-size: 24px;
            animation: coinFall 1s ease-out forwards;
            pointer-events: none;
        }
        @keyframes coinFall {
            0% { transform: translateY(-50px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100px) rotate(720deg); opacity: 0; }
        }

        /* Beat the Clock Game */
        .clock-container {
            text-align: center;
        }
        .clock-timer {
            font-size: 72px;
            font-weight: bold;
            color: #FDD835;
            text-shadow: 0 0 30px rgba(253, 216, 53, 0.8);
            margin: 30px 0;
        }
        .clock-timer.warning {
            color: #F44336;
            animation: timerPulse 0.5s ease-in-out infinite;
        }
        @keyframes timerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .clock-letter {
            font-size: 180px;
            font-weight: bold;
            color: #FDD835;
            text-shadow: 0 10px 30px rgba(253, 216, 53, 0.5);
            margin: 40px 0;
            transition: all 0.2s;
        }
        .clock-letter.success {
            color: #7CB342;
            transform: scale(1.2);
        }
        .clock-progress {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 30px 0;
        }
        .clock-progress-dot {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #999;
        }
        .clock-progress-dot.completed {
            background: rgba(124, 179, 66, 0.3);
            border-color: #7CB342;
            color: #7CB342;
        }
        .clock-progress-dot.current {
            background: rgba(253, 216, 53, 0.3);
            border-color: #FDD835;
            color: #FDD835;
            animation: dotPulse 1s ease-in-out infinite;
        }
        @keyframes dotPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        /* Instruction Modal Styles */
    </style>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Supabase Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // Initialize Supabase client
        const SUPABASE_URL = 'https://eyrcioeihiaisjwnalkz.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImV5cmNpb2VpaGlhaXNqd25hbGt6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI3NDg0MDUsImV4cCI6MjA3ODMyNDQwNX0.Tj1_XyrC5XsnKtekYop_dWuCdng1hXHHVWqzjr3vJJQ';
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        console.log('‚úÖ Supabase client initialized');

        // ======================
        // Authentication Functions
        // ======================

        let currentUser = null;
        let guestProfileId = null; // Store guest profile ID in localStorage

        async function sendMagicLink() {
            const emailInput = document.getElementById('emailInput');
            const email = emailInput.value.trim();

            if (!email || !email.includes('@')) {
                alert('Please enter a valid email address');
                return;
            }

            try {
                const { error } = await supabase.auth.signInWithOtp({
                    email: email,
                    options: {
                        emailRedirectTo: window.location.origin
                    }
                });

                if (error) throw error;

                closeAuthModal();
                alert(`‚úÖ Magic link sent to ${email}!\n\nCheck your inbox and click the link to sign in.`);
                emailInput.value = '';
            } catch (error) {
                console.error('‚ùå Magic link error:', error);
                alert('Failed to send magic link. Please try again.');
            }
        }

        async function signOut() {
            try {
                const { error } = await supabase.auth.signOut();
                if (error) throw error;

                currentUser = null;
                location.reload(); // Refresh to reset to guest mode
            } catch (error) {
                console.error('‚ùå Sign out error:', error);
            }
        }

        function openAuthModal() {
            document.getElementById('authModal').style.display = 'flex';
        }

        function closeAuthModal() {
            document.getElementById('authModal').style.display = 'none';
        }

        async function linkGuestToAuthUser(userId) {
            // Link the current guest profile to the authenticated user
            if (!guestProfileId) {
                console.log('No guest profile to link');
                return;
            }

            try {
                const { error } = await supabase
                    .from('profiles')
                    .update({ user_id: userId })
                    .eq('id', guestProfileId);

                if (error) throw error;

                console.log('‚úÖ Guest profile linked to authenticated user');
                guestProfileId = null; // Clear guest ID
                localStorage.removeItem('guestProfileId');
            } catch (error) {
                console.error('‚ùå Error linking guest profile:', error);
            }
        }

        async function handleAuthStateChange() {
            // Listen for auth state changes
            supabase.auth.onAuthStateChange(async (event, session) => {
                console.log('Auth state changed:', event, session?.user?.email);

                if (session?.user) {
                    currentUser = session.user;

                    // Show user info
                    document.getElementById('userEmail').textContent = `‚úÖ ${session.user.email}`;
                    document.getElementById('userInfo').style.display = 'block';
                    document.getElementById('saveProgressBtn').style.display = 'none';

                    // Link guest profile if exists
                    await linkGuestToAuthUser(session.user.id);

                    // Load user's profiles
                    await loadUserProfiles(session.user.id);
                } else {
                    currentUser = null;
                    document.getElementById('userInfo').style.display = 'none';
                    document.getElementById('saveProgressBtn').style.display = 'inline-block';
                }
            });

            // Check current session
            const { data: { session } } = await supabase.auth.getSession();
            if (session?.user) {
                currentUser = session.user;
                document.getElementById('userEmail').textContent = `‚úÖ ${session.user.email}`;
                document.getElementById('userInfo').style.display = 'block';
                document.getElementById('saveProgressBtn').style.display = 'none';
            } else {
                document.getElementById('saveProgressBtn').style.display = 'inline-block';
            }
        }

        async function loadUserProfiles(userId) {
            try {
                const { data: profiles, error } = await supabase
                    .from('profiles')
                    .select('*')
                    .eq('user_id', userId);

                if (error) throw error;

                console.log(`‚úÖ Loaded ${profiles.length} profiles for user`);

                // Update UI with user's profiles
                // This will be integrated with existing profile management
            } catch (error) {
                console.error('‚ùå Error loading user profiles:', error);
            }
        }
    </script>
</head>
<body>
    <h1>üìö ReadingClub</h1>
    <div class="subtitle">Learn phonics with your voice - real-time sound recognition</div>

    <!-- Authentication Modal -->
    <div id="authModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; align-items: center; justify-content: center;">
        <div style="background: #2c3e50; padding: 30px; border-radius: 10px; max-width: 400px; text-align: center;">
            <div style="margin-bottom: 20px; color: #ddd; font-size: 20px;">
                üíæ Save your progress
            </div>
            <div style="margin-bottom: 20px; color: #aaa; font-size: 14px;">
                Get a magic link via email to save your calibrations across devices
            </div>
            <input
                id="emailInput"
                type="email"
                placeholder="your@email.com"
                style="
                    width: 100%;
                    padding: 12px 20px;
                    font-size: 16px;
                    border-radius: 5px;
                    background: rgba(255,255,255,0.1);
                    color: white;
                    border: 1px solid #555;
                    margin-bottom: 15px;
                    box-sizing: border-box;
                "
            />
            <button onclick="sendMagicLink()" style="
                width: 100%;
                padding: 12px 30px;
                background: #7CB342;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
                margin-bottom: 10px;
            ">
                Send Magic Link
            </button>
            <button onclick="closeAuthModal()" style="
                width: 100%;
                padding: 8px 20px;
                background: transparent;
                color: #999;
                border: 1px solid #555;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
            ">
                Cancel
            </button>
        </div>
    </div>

    <!-- User Info (when signed in) -->
    <div id="userInfo" style="text-align: center; margin: 20px 0; padding: 15px; background: rgba(124, 179, 66, 0.2); border-radius: 10px; display: none;">
        <span id="userEmail" style="color: #7CB342; margin-right: 15px;"></span>
        <button onclick="signOut()" style="
            padding: 8px 20px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        ">
            Sign Out
        </button>
    </div>

    <!-- Profile Selector -->
    <div style="text-align: center; margin: 20px 0; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 10px;">
        <label style="color: #aaa; margin-right: 10px;">üë§ Profile:</label>
        <select id="profileSelect" onchange="switchProfile()" style="padding: 8px 15px; font-size: 16px; border-radius: 5px; background: #2a2a2a; color: white; border: 1px solid #555;">
        </select>
        <button onclick="createNewProfile()" style="margin-left: 10px; padding: 8px 15px; background: #7CB342; color: white; border: none; border-radius: 5px; cursor: pointer;">‚ûï New Profile</button>
        <button id="saveProgressBtn" onclick="openAuthModal()" style="margin-left: 10px; padding: 8px 15px; background: #5A9; color: white; border: none; border-radius: 5px; cursor: pointer; display: none;">üíæ Save Progress</button>
    </div>

    <!-- Calibration Modal -->
    <div id="calibrationModal" class="calibration-modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeCalibrationModal()">‚úï</button>

            <!-- Instructions -->
            <div class="modal-instructions">
                Click the letter to hear its sound. Click each box below to record 5 sounds.
            </div>

            <!-- Big Letter Display -->
            <div class="modal-letter-container">
                <div id="modalLetter" class="modal-letter" onclick="playModalLetterSound()">A</div>
                <div class="modal-listen-icon" onclick="playModalLetterSound()" title="Click to hear sound">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                    </svg>
                </div>
            </div>

            <!-- 5 Capture Boxes -->
            <div class="modal-captures" style="position: relative;">
                <!-- Green arrow indicator -->
                <div class="click-arrow" id="clickArrow">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 4L12 20M12 20L5 13M12 20L19 13" stroke="#7CB342" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
                    </svg>
                </div>

                <div class="modal-capture-box" id="modalCaptureBox0">
                    <div class="mic-icon">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2C10.9 2 10 2.9 10 4V12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12V4C14 2.9 13.1 2 12 2Z"/>
                            <path d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"/>
                        </svg>
                    </div>
                    <canvas id="modalCaptureCanvas0" width="100" height="80"></canvas>
                </div>
                <div class="modal-capture-box" id="modalCaptureBox1">
                    <div class="mic-icon">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2C10.9 2 10 2.9 10 4V12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12V4C14 2.9 13.1 2 12 2Z"/>
                            <path d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"/>
                        </svg>
                    </div>
                    <canvas id="modalCaptureCanvas1" width="100" height="80"></canvas>
                </div>
                <div class="modal-capture-box" id="modalCaptureBox2">
                    <div class="mic-icon">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2C10.9 2 10 2.9 10 4V12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12V4C14 2.9 13.1 2 12 2Z"/>
                            <path d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"/>
                        </svg>
                    </div>
                    <canvas id="modalCaptureCanvas2" width="100" height="80"></canvas>
                </div>
                <div class="modal-capture-box" id="modalCaptureBox3">
                    <div class="mic-icon">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2C10.9 2 10 2.9 10 4V12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12V4C14 2.9 13.1 2 12 2Z"/>
                            <path d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"/>
                        </svg>
                    </div>
                    <canvas id="modalCaptureCanvas3" width="100" height="80"></canvas>
                </div>
                <div class="modal-capture-box" id="modalCaptureBox4">
                    <div class="mic-icon">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2C10.9 2 10 2.9 10 4V12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12V4C14 2.9 13.1 2 12 2Z"/>
                            <path d="M17 11C17 13.76 14.76 16 12 16C9.24 16 7 13.76 7 11H5C5 14.53 7.61 17.43 11 17.92V21H13V17.92C16.39 17.43 19 14.53 19 11H17Z"/>
                        </svg>
                    </div>
                    <canvas id="modalCaptureCanvas4" width="100" height="80"></canvas>
                </div>
            </div>

            <!-- Status Message -->
            <div id="modalStatus" class="modal-status">Click letter to hear sound, then start saying it!</div>

            <!-- Next Button (shown after calibration complete) -->
            <div id="modalNextButton" class="modal-next-button" onclick="goToNextLetter()">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"/>
                </svg>
            </div>
        </div>
    </div>

    <!-- Sensitivity Modal -->
    <div id="sensitivityModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; align-items: center; justify-content: center;">
        <div style="background: #2c3e50; padding: 30px; border-radius: 10px; max-width: 400px; text-align: center; position: relative;">
            <button onclick="closeSensitivityModal()" style="position: absolute; top: 10px; right: 10px; background: none; border: none; color: #aaa; font-size: 24px; cursor: pointer; padding: 5px 10px;">‚úï</button>

            <div style="font-size: 48px; margin-bottom: 10px;" id="sensitivityLetter">a</div>
            <h3 style="color: #fff; margin-bottom: 20px;">Adjust Sensitivity</h3>

            <div style="margin: 30px 0;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px; color: #ddd; font-size: 14px;">
                    <span>Easy (70%)</span>
                    <span id="sensitivityValue">85%</span>
                    <span>Strict (95%)</span>
                </div>
                <input type="range" id="sensitivitySlider" min="70" max="95" value="85"
                       style="width: 100%; height: 8px; border-radius: 5px; background: #555; outline: none; -webkit-appearance: none;"
                       oninput="updateSensitivityDisplay(this.value)">
            </div>

            <div style="margin-top: 20px; color: #aaa; font-size: 14px;">
                Lower = easier to match<br>
                Higher = more accurate required
            </div>

            <button onclick="saveSensitivity()" class="btn" style="margin-top: 20px; width: 100%;">Save</button>
        </div>
    </div>

    <!-- Manual Recording Modal -->
    <div id="manualRecordModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; align-items: center; justify-content: center;">
        <div style="background: #2c3e50; padding: 30px; border-radius: 10px; max-width: 500px; text-align: center; position: relative;">
            <button onclick="closeManualRecordModal()" style="position: absolute; top: 10px; right: 10px; background: none; border: none; color: #aaa; font-size: 24px; cursor: pointer; padding: 5px 10px;">‚úï</button>

            <div style="font-size: 48px; margin-bottom: 10px;" id="manualRecordLetter">a</div>
            <h3 style="color: #fff; margin-bottom: 10px;">Add Correct Example</h3>
            <p style="color: #aaa; font-size: 14px; margin-bottom: 20px;">Record the correct sound to add as a positive example</p>

            <div id="manualRecordStatus" style="margin: 20px 0; font-size: 16px; color: #FDD835; min-height: 30px;">
                Ready to record
            </div>

            <!-- Waveform visualization -->
            <canvas id="manualRecordCanvas" style="width: 100%; height: 80px; background: rgba(0,0,0,0.3); border-radius: 5px; margin: 20px 0;"></canvas>

            <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                <button id="manualRecordStartBtn" onclick="startManualRecord()" class="btn" style="background: #4CAF50;">
                    üé§ Start Recording
                </button>
                <button id="manualRecordRedoBtn" onclick="redoManualRecord()" class="btn" style="background: #f44336; display: none;">
                    üîÑ Redo
                </button>
                <button id="manualRecordAcceptBtn" onclick="acceptManualRecord()" class="btn" style="background: #1976D2; display: none;">
                    ‚úì Accept
                </button>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="tabs">
            <button class="tab active" onclick="switchTab('calibrate')">üìä Calibrate</button>
            <button class="tab" onclick="switchTab('tuner')">‚ñ∂ Play</button>
            <button class="tab" onclick="switchTab('stats')">üìà Stats</button>
        </div>

        <!-- Calibration Tab -->
        <div id="calibrate" class="tab-content active">
            <div class="info-box">
                <strong>Pattern-Based Calibration</strong><br>
                Say each phoneme 3-4 times while recording. The system captures the actual waveform pattern (like a fingerprint).<br>
                This preserves the SHAPE of the sound, not just statistics.
            </div>

            <div class="calibration-grid" id="calibrationGrid"></div>

            <div class="actions">
                <button class="btn" onclick="resetCalibration()">üîÑ Reset All</button>
                <button class="btn" onclick="exportCalibration()">üíæ Export Calibration</button>
                <button class="btn" onclick="migrateLocalStorageToSupabase()" style="background: #FF9800;">üîÑ Migrate Old Data</button>
            </div>

            <!-- Migration Progress Indicator -->
            <div id="migrationProgress" style="display: none; margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px; font-family: monospace;">
                <div id="migrationStatus" style="margin-bottom: 10px; font-weight: bold; font-size: 16px;"></div>
                <div id="migrationDetails" style="font-size: 0.9em; color: rgba(255,255,255,0.8); white-space: pre-line;"></div>
            </div>

            <div id="calibrationStats" style="margin-top: 20px; text-align: center; color: #aaa;"></div>
        </div>

        <!-- Play Tab (Voice Recognition Game) -->
        <div id="tuner" class="tab-content">
            <!-- Letter Progress Tracker -->
            <div id="letterProgressTracker" style="display: none; margin-bottom: 20px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                <div style="font-size: 14px; color: #aaa; margin-bottom: 10px;">Letters in Practice:</div>
                <div id="letterProgressCards" style="display: flex; gap: 12px; flex-wrap: wrap;">
                    <!-- Cards will be inserted here -->
                </div>
            </div>

            <div class="actions" style="margin-bottom: 20px; display: flex; justify-content: center; align-items: center; gap: 15px; flex-wrap: wrap;">
                <label style="color: #ddd; font-size: 14px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
                    <span style="opacity: 0.8;">Auto-next:</span>
                    <div style="position: relative; width: 44px; height: 24px; background: rgba(255,255,255,0.2); border-radius: 12px; transition: background 0.3s;" id="toggleBg">
                        <input type="checkbox" id="continuousPlayMode" onchange="toggleContinuousPlay()" style="opacity: 0; width: 0; height: 0; position: absolute;">
                        <div id="toggleSlider" style="position: absolute; top: 3px; left: 3px; width: 18px; height: 18px; background: white; border-radius: 50%; transition: transform 0.3s;"></div>
                    </div>
                </label>

                <button class="btn" id="muteBtn" onclick="toggleMute()" style="background: #666; display: none;">üé§ Mute</button>
                <button class="btn" id="tunerBtn" onclick="toggleTuner()">‚ñ∂ Start Game</button>
                <button class="btn" onclick="tryAgain()" style="background: #7CB342; display: none;" id="tryAgainBtn">üîÑ Try Again</button>
                <button class="btn" onclick="skipLetter()" style="background: #999;">Skip</button>
                <button class="btn" onclick="openSensitivityModal()" style="background: #666; display: none;" id="sensitivityBtn"><i data-lucide="sliders" style="width: 18px; height: 18px;"></i></button>
            </div>

            <!-- Manual Recording Button -->
            <div style="text-align: center; margin-bottom: 15px;">
                <button class="btn" onclick="openManualRecordModal()" style="background: #1976D2; font-size: 13px;" id="manualRecordBtn">
                    üé§ Add Correct Example
                </button>
                <div style="color: #999; font-size: 10px; margin-top: 5px;">If it's correct but not recognized</div>
            </div>

            <!-- Training Correction Buttons (moved to top for visibility) -->
            <div id="trainingButtons" style="display: none; margin-bottom: 15px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px; text-align: center;">
                <div style="color: #ddd; font-size: 13px; margin-bottom: 10px;">Recognition issue? Train the system:</div>
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    <button id="addPositiveBtn" class="btn" style="background: #4CAF50; display: none;">
                        ‚úì Add to '<span id="positiveTarget">?</span>'
                    </button>
                    <button id="addNegativeBtn" class="btn" style="background: #f44336; display: none;">
                        ‚úó Not '<span id="negativeTarget">?</span>'
                    </button>
                    <button id="addCorrectBtn" class="btn" style="background: #7CB342; display: none;">
                        ‚úì Was '<span id="correctTarget">?</span>'
                    </button>
                </div>
                <div style="color: #999; font-size: 11px; margin-top: 8px;" id="trainingFeedback"></div>
            </div>

            <div style="text-align: center; margin-bottom: 20px; color: #ddd; font-size: 36px; font-weight: 600;">
                Say this sound:
                <span onclick="playCalibrationRecording()" style="cursor: pointer; font-size: 44px; margin-left: 15px; display: inline-block; opacity: 0.7; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'" title="Play my recording">üîä</span>
            </div>

            <div id="targetLetter" style="text-align: center; font-size: 180px; font-weight: bold; color: #FDD835; margin: 20px 0; text-shadow: 0 10px 30px rgba(253, 216, 53, 0.5); transition: all 0.3s;">?</div>

            <div class="confidence-bar">
                <div class="confidence-fill" id="confidenceFill"></div>
            </div>

            <!-- Threshold Meter -->
            <div id="thresholdMeter" style="margin: 20px 0; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px; display: none;">
                <div style="color: #aaa; font-size: 12px; margin-bottom: 12px; font-weight: bold;">üé§ Voice Detection Thresholds</div>

                <!-- Volume Meter -->
                <div style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        <span style="color: #ddd; font-size: 11px;">Volume</span>
                        <span style="color: #ddd; font-size: 11px;">
                            <span id="volumeMeterValue">0</span> / <span id="volumeMeterThreshold">15</span>
                        </span>
                    </div>
                    <div style="position: relative; width: 100%; height: 20px; background: rgba(255,255,255,0.1); border-radius: 10px; overflow: hidden;">
                        <div id="volumeMeterFill" style="height: 100%; width: 0%; background: #f44336; border-radius: 10px; transition: width 0.1s, background 0.3s;"></div>
                        <!-- Threshold marker -->
                        <div id="volumeThresholdMarker" style="position: absolute; top: 0; height: 100%; width: 2px; background: #FDD835; box-shadow: 0 0 4px #FDD835;"></div>
                    </div>
                </div>

                <!-- Energy Concentration Meter -->
                <div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        <span style="color: #ddd; font-size: 11px;">Energy Focus</span>
                        <span style="color: #ddd; font-size: 11px;">
                            <span id="concentrationMeterValue">0.0</span> / <span id="concentrationMeterThreshold">2.0</span>
                        </span>
                    </div>
                    <div style="position: relative; width: 100%; height: 20px; background: rgba(255,255,255,0.1); border-radius: 10px; overflow: hidden;">
                        <div id="concentrationMeterFill" style="height: 100%; width: 0%; background: #f44336; border-radius: 10px; transition: width 0.1s, background 0.3s;"></div>
                        <!-- Threshold marker -->
                        <div id="concentrationThresholdMarker" style="position: absolute; top: 0; height: 100%; width: 2px; background: #FDD835; box-shadow: 0 0 4px #FDD835;"></div>
                    </div>
                </div>

                <div style="color: #999; font-size: 10px; margin-top: 10px; text-align: center;">
                    Both bars must reach the yellow line for voice detection
                </div>
            </div>

            <div class="stats">
                <div class="stat-item">
                    <div>Match Score</div>
                    <div class="stat-value" id="matchScore">0%</div>
                </div>
                <div class="stat-item">
                    <div>Volume</div>
                    <div class="stat-value" id="volume">0%</div>
                </div>
            </div>

            <canvas id="spectrumCanvas"></canvas>

            <!-- Pattern Comparison Visualization -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 20px;" id="patternComparison">
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px;">
                    <div style="color: #aaa; font-size: 11px; margin-bottom: 8px; text-align: center;">üì¶ Stored Calibration</div>
                    <canvas id="storedPatternCanvas" style="width: 100%; height: 80px; background: rgba(0,0,0,0.3); border-radius: 5px;"></canvas>
                    <div style="color: #999; font-size: 10px; margin-top: 5px; text-align: center;">
                        <span id="patternCount">-</span>
                    </div>
                </div>
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px;">
                    <div style="color: #aaa; font-size: 11px; margin-bottom: 8px; text-align: center;">üé§ Current Recording</div>
                    <canvas id="currentPatternCanvas" style="width: 100%; height: 80px; background: rgba(0,0,0,0.3); border-radius: 5px;"></canvas>
                </div>
            </div>

            <!-- Additional Patterns Visualization -->
            <div id="additionalPatternsContainer" style="margin-top: 15px; display: none;">
                <div style="color: #aaa; font-size: 12px; margin-bottom: 10px; font-weight: bold;">Additional Training Patterns:</div>
                <div id="additionalPatternsGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;">
                    <!-- Pattern cards will be inserted here -->
                </div>
            </div>

            <div id="status" style="font-family: monospace; font-size: 11px; white-space: pre-wrap; line-height: 1.4;">Click Start to begin</div>
        </div>

        <!-- Stats Tab (Adaptive Learning) -->
        <div id="stats" class="tab-content">
            <div class="info-box" style="margin-bottom: 20px;">
                <strong>üìà Adaptive Learning Statistics</strong>
                <p style="margin-top: 10px; color: #ddd;">Track your progress across sessions. The system adapts letter selection based on your proficiency.</p>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px;">
                    <div style="color: #999; font-size: 14px; margin-bottom: 8px;">Session Phase</div>
                    <div id="statsPhase" style="color: #FDD835; font-size: 24px; font-weight: bold;">Not Started</div>
                </div>
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px;">
                    <div style="color: #999; font-size: 14px; margin-bottom: 8px;">Total Attempts</div>
                    <div id="statsAttempts" style="color: #4CAF50; font-size: 24px; font-weight: bold;">0</div>
                </div>
            </div>

            <div style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                <h3 style="color: #FDD835; margin-top: 0; margin-bottom: 15px;">Letter Proficiency Pools</h3>
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; text-align: center;">
                    <div style="background: rgba(255,215,0,0.1); padding: 15px; border-radius: 10px; border: 2px solid #FFD700;">
                        <div style="color: #FFD700; font-size: 36px; font-weight: bold;" id="statsMastered">0</div>
                        <div style="color: #FFD700; font-size: 14px; font-weight: bold; margin-top: 5px;">MASTERED</div>
                        <div style="color: #999; font-size: 11px; margin-top: 5px;">Long-term memory</div>
                    </div>
                    <div style="background: rgba(76,175,80,0.1); padding: 15px; border-radius: 10px; border: 2px solid #4CAF50;">
                        <div style="color: #4CAF50; font-size: 36px; font-weight: bold;" id="statsKnown">0</div>
                        <div style="color: #4CAF50; font-size: 14px; font-weight: bold; margin-top: 5px;">KNOWN</div>
                        <div style="color: #999; font-size: 11px; margin-top: 5px;">Recent mastery</div>
                    </div>
                    <div style="background: rgba(253,216,53,0.1); padding: 15px; border-radius: 10px; border: 2px solid #FDD835;">
                        <div style="color: #FDD835; font-size: 36px; font-weight: bold;" id="statsSometimes">0</div>
                        <div style="color: #FDD835; font-size: 14px; font-weight: bold; margin-top: 5px;">SOMETIMES</div>
                        <div style="color: #999; font-size: 11px; margin-top: 5px;">Inconsistent</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px; border: 2px solid #666;">
                        <div style="color: #999; font-size: 36px; font-weight: bold;" id="statsUnknown">0</div>
                        <div style="color: #999; font-size: 14px; font-weight: bold; margin-top: 5px;">UNKNOWN</div>
                        <div style="color: #999; font-size: 11px; margin-top: 5px;">Not learned</div>
                    </div>
                </div>
            </div>

            <div style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                <h3 style="color: #FDD835; margin-top: 0; margin-bottom: 15px;">Current Session</h3>
                <div style="color: #ddd; font-size: 16px;">
                    <div style="display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <span><strong>üÜï New Letters Introduced:</strong></span>
                        <span id="statsNewLetters" style="color: #FDD835;">None</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <span><strong>üéì Graduated to KNOWN:</strong></span>
                        <span id="statsGraduated" style="color: #4CAF50;">None</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; padding: 10px 0;">
                        <span><strong>üî• Current Streak:</strong></span>
                        <span id="statsStreak" style="color: #FF5722; font-size: 20px; font-weight: bold;">0</span>
                    </div>
                </div>
            </div>
        </div>

    </div>


    <script>
        // ========== ADAPTIVE LEARNING SYSTEM ==========

        // Proficiency levels (stored in Supabase)
        const LetterProficiency = {
            UNKNOWN: 0,      // Never learned or forgot
            SOMETIMES: 1,    // Getting it ~50% in current session
            KNOWN: 2,        // Mastered in current session (10+ correct without LISTEN)
            MASTERED: 3      // Long-term memory (correct from first attempts in next session)
        };

        // Session configuration
        const SESSION_CONFIG = {
            TIMEOUT_MINUTES: 30,
            GRADUATION_THRESHOLD: 10,              // 10 correct without LISTEN to graduate
            MAX_NEW_LETTERS_PER_SESSION: 3,
            GRADUATION_TEST_ATTEMPTS: 3,          // First 3 attempts next session
            GRADUATION_TEST_REQUIRED: 2,          // 2 of 3 must be correct
            MASTERED_DEMOTION_LISTEN_CLICKS: 2,
            KNOWN_DEMOTION_LISTEN_CLICKS: 1,
            RAPID_REP_COUNT: 3,                   // 3 reps after LISTEN click (keeps it engaging)
            WARMUP_COUNT: 5,                      // First 5 letters are warmup
            MIX_RATIO_PRACTICING: 0.5,            // 50% practicing letters
            RECENT_HISTORY_SIZE: 3                // Avoid last 3 letters
        };

        // Current session data (localStorage)
        let currentSession = null;

        // ========== GLOBAL VARIABLES ==========

        let audioContext;
        let analyser;
        let microphone;
        let mediaRecorder;
        let audioChunks = [];
        let dataArray;
        let isRunning = false;
        let isRecording = false;
        let recordingPhoneme = null;
        let recordedPatterns = [];
        let calibrationData = {};
        let audioRecordings = {};
        let letterSensitivity = {}; // Sensitivity multiplier for each letter (0.5 - 1.5)

        const canvas = document.getElementById('spectrumCanvas');
        const canvasCtx = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = 240;

        // Pattern comparison canvases (will be initialized when switching to Play tab)
        let storedPatternCanvas = null;
        let storedPatternCtx = null;
        let currentPatternCanvas = null;
        let currentPatternCtx = null;

        // Initialize pattern canvases
        function initializePatternCanvases() {
            if (storedPatternCanvas) return; // Already initialized

            storedPatternCanvas = document.getElementById('storedPatternCanvas');
            currentPatternCanvas = document.getElementById('currentPatternCanvas');

            if (!storedPatternCanvas || !currentPatternCanvas) {
                console.warn('‚ö†Ô∏è Pattern canvases not found');
                return;
            }

            storedPatternCtx = storedPatternCanvas.getContext('2d');
            storedPatternCanvas.width = storedPatternCanvas.offsetWidth || 400;
            storedPatternCanvas.height = 80;

            currentPatternCtx = currentPatternCanvas.getContext('2d');
            currentPatternCanvas.width = currentPatternCanvas.offsetWidth || 400;
            currentPatternCanvas.height = 80;

            console.log('‚úÖ Pattern canvases initialized:', storedPatternCanvas.width, 'x', storedPatternCanvas.height);

            // Visualize stored pattern if letter is already selected
            if (currentTarget) {
                visualizeStoredPattern(currentTarget);
            }
        }

        // ========== SESSION MANAGEMENT FUNCTIONS ==========

        function initializeSession(profileId) {
            const now = new Date();
            const existingSessionKey = `session_${profileId}`;
            const existingSessionData = localStorage.getItem(existingSessionKey);

            // Check if we can resume existing session
            if (existingSessionData) {
                try {
                    const session = JSON.parse(existingSessionData);
                    const lastActivity = new Date(session.lastActivityTime);
                    const minutesSinceActivity = (now - lastActivity) / 1000 / 60;

                    if (minutesSinceActivity < SESSION_CONFIG.TIMEOUT_MINUTES) {
                        // Resume session
                        console.log(`üìù Resuming session from ${minutesSinceActivity.toFixed(1)} minutes ago`);
                        session.lastActivityTime = now.toISOString();

                        // Convert letterStats back to Map
                        session.letterStats = new Map(Object.entries(session.letterStats || {}));

                        // Initialize unknownLettersIntroduced if missing (backward compatibility)
                        if (!session.unknownLettersIntroduced) {
                            session.unknownLettersIntroduced = [];
                        }

                        currentSession = session;
                        saveSessionData();
                        return session;
                    } else {
                        // Session expired - end it and start new
                        console.log('‚è∞ Session expired, starting new session');
                        // Convert letterStats to Map before ending session
                        session.letterStats = new Map(Object.entries(session.letterStats || {}));
                        endSession(session);
                    }
                } catch (error) {
                    console.error('‚ùå Error loading session:', error);
                }
            }

            // Create new session
            const newSession = {
                sessionId: generateUUID(),
                profileId: profileId,
                startTime: now.toISOString(),
                lastActivityTime: now.toISOString(),
                attempts: [],
                letterStats: new Map(),
                newLettersIntroduced: [],
                unknownLettersIntroduced: [], // Track letters introduced as UNKNOWN (for 3-letter limit)
                lettersGraduated: [],
                recentHistory: []
            };

            console.log('üÜï Created new session:', newSession.sessionId);
            currentSession = newSession;
            saveSessionData();
            return newSession;
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function getSessionData() {
            if (!currentSession) {
                console.warn('‚ö†Ô∏è No active session');
                return null;
            }
            return currentSession;
        }

        function saveSessionData() {
            if (!currentSession) return;

            const sessionKey = `session_${currentSession.profileId}`;

            // Convert Map to Object for JSON storage
            const sessionToSave = {
                ...currentSession,
                letterStats: Object.fromEntries(currentSession.letterStats)
            };

            localStorage.setItem(sessionKey, JSON.stringify(sessionToSave));
        }

        function recordAttempt(letter, success, clickedListen, matchScore) {
            if (!currentSession) {
                console.warn('‚ö†Ô∏è No active session to record attempt');
                return;
            }

            const now = Date.now();
            currentSession.lastActivityTime = new Date(now).toISOString();

            // Add to attempts array
            currentSession.attempts.push({
                letter,
                clickedListen,
                success,
                matchScore,
                timestamp: now
            });

            // Update letter stats
            let stats = currentSession.letterStats.get(letter);
            if (!stats) {
                stats = {
                    total_attempts: 0,
                    successes: 0,
                    listen_clicks: 0,
                    first_attempts_result: [],
                    consecutive_success_no_listen: 0,
                    rapid_reps_remaining: 0,
                    state: 'new'
                };
                currentSession.letterStats.set(letter, stats);
            }

            stats.total_attempts++;
            if (success) stats.successes++;
            if (clickedListen) {
                stats.listen_clicks++;
                // Start rapid reinforcement: 5 additional reps after LISTEN
                stats.rapid_reps_remaining = SESSION_CONFIG.RAPID_REP_COUNT;
            }

            // Track first 3 attempts for graduation test (MASTERED)
            if (stats.first_attempts_result.length < SESSION_CONFIG.GRADUATION_TEST_ATTEMPTS) {
                stats.first_attempts_result.push(success && !clickedListen);
            }

            // Track consecutive successes without LISTEN for graduation to KNOWN
            if (success && !clickedListen) {
                stats.consecutive_success_no_listen++;
            } else {
                stats.consecutive_success_no_listen = 0;
            }

            // Check for graduation to KNOWN in this session
            if (currentSession.newLettersIntroduced.includes(letter) &&
                !currentSession.lettersGraduated.includes(letter) &&
                stats.consecutive_success_no_listen >= SESSION_CONFIG.GRADUATION_THRESHOLD) {

                stats.state = 'graduated_to_known';
                currentSession.lettersGraduated.push(letter);
                console.log(`üéì ${letter} graduated to KNOWN!`);

                // Remove from unknown letters list (frees up slot for new UNKNOWN letter)
                if (currentSession.unknownLettersIntroduced) {
                    const index = currentSession.unknownLettersIntroduced.indexOf(letter);
                    if (index > -1) {
                        currentSession.unknownLettersIntroduced.splice(index, 1);
                        console.log(`‚ú® Freed up slot - can now introduce another UNKNOWN letter (${currentSession.unknownLettersIntroduced.length}/${SESSION_CONFIG.MAX_NEW_LETTERS_PER_SESSION})`);
                    }
                }

                // Update proficiency in Supabase immediately
                updateLetterProficiency(currentProfileId, [{ letter, proficiency: LetterProficiency.KNOWN }]);

                // TODO: Show celebration animation
            }

            saveSessionData();
            console.log(`üìù Recorded attempt: ${letter} ${success ? '‚úÖ' : '‚ùå'} ${clickedListen ? 'üîä' : ''} (${stats.consecutive_success_no_listen} streak)`);

            // Update displays
            updateLetterProgressTracker();

            // Update stats display if Stats tab is active
            const statsTab = document.getElementById('stats');
            if (statsTab && statsTab.classList.contains('active')) {
                updateAdaptiveStatsDisplay();
            }
        }

        async function endSession(session = currentSession) {
            if (!session) return;

            console.log('üèÅ Ending session:', session.sessionId);

            // Calculate proficiency updates
            const updates = [];

            for (const [letter, stats] of session.letterStats.entries()) {
                // Get current proficiency from Supabase
                const currentProficiency = await getLetterProficiencyFromDB(letter);
                let newProficiency = currentProficiency;

                // Check for graduation to KNOWN
                if (session.lettersGraduated.includes(letter)) {
                    newProficiency = LetterProficiency.KNOWN;
                    console.log(`üìà ${letter}: UNKNOWN ‚Üí KNOWN`);
                }

                // Check for graduation to MASTERED (from previous KNOWN)
                if (currentProficiency === LetterProficiency.KNOWN) {
                    const firstThreeResults = stats.first_attempts_result.slice(0, 3);
                    const correctCount = firstThreeResults.filter(r => r === true).length;

                    if (correctCount >= SESSION_CONFIG.GRADUATION_TEST_REQUIRED && stats.listen_clicks === 0) {
                        newProficiency = LetterProficiency.MASTERED;
                        console.log(`üåü ${letter}: KNOWN ‚Üí MASTERED`);
                        // TODO: Show MASTERED celebration
                    }
                }

                // Check for demotion from MASTERED
                if (currentProficiency === LetterProficiency.MASTERED) {
                    if (stats.listen_clicks >= SESSION_CONFIG.MASTERED_DEMOTION_LISTEN_CLICKS) {
                        newProficiency = LetterProficiency.UNKNOWN;
                        console.log(`üìâ ${letter}: MASTERED ‚Üí UNKNOWN (${stats.listen_clicks} LISTEN clicks)`);
                    } else if (stats.listen_clicks === 1) {
                        newProficiency = LetterProficiency.SOMETIMES;
                        console.log(`üìâ ${letter}: MASTERED ‚Üí SOMETIMES (1 LISTEN click)`);
                    }
                }

                // Check for demotion from KNOWN
                if (currentProficiency === LetterProficiency.KNOWN) {
                    if (stats.listen_clicks >= SESSION_CONFIG.KNOWN_DEMOTION_LISTEN_CLICKS) {
                        newProficiency = LetterProficiency.SOMETIMES;
                        console.log(`üìâ ${letter}: KNOWN ‚Üí SOMETIMES (${stats.listen_clicks} LISTEN clicks)`);
                    }
                }

                updates.push({ letter, proficiency: newProficiency });
            }

            // Batch update Supabase
            await updateLetterProficiency(session.profileId, updates);

            // Clear session data
            localStorage.removeItem(`session_${session.profileId}`);
            currentSession = null;

            console.log('‚úÖ Session ended and proficiency saved');
        }

        async function getLetterProficiencyFromDB(letter) {
            if (!currentProfileId) return LetterProficiency.UNKNOWN;

            try {
                const { data, error } = await supabase
                    .from('calibrations')
                    .select('proficiency')
                    .eq('profile_id', currentProfileId)
                    .eq('letter', letter)
                    .maybeSingle();

                if (error || !data) return LetterProficiency.UNKNOWN;
                return data.proficiency || LetterProficiency.UNKNOWN;
            } catch (error) {
                console.error('Error loading proficiency:', error);
                return LetterProficiency.UNKNOWN;
            }
        }

        async function updateLetterProficiency(profileId, updates) {
            if (!profileId || updates.length === 0) return;

            try {
                const promises = updates.map(update =>
                    supabase
                        .from('calibrations')
                        .update({
                            proficiency: update.proficiency,
                            updated_at: new Date().toISOString()
                        })
                        .eq('profile_id', profileId)
                        .eq('letter', update.letter)
                );

                await Promise.all(promises);
                console.log(`‚úÖ Updated proficiency for ${updates.length} letters`);
            } catch (error) {
                console.error('‚ùå Error updating proficiency:', error);
            }
        }

        // ========== ADAPTIVE SELECTION ALGORITHM ==========

        async function loadProficiencyMap(profileId) {
            const calibratedLetters = Object.keys(calibrationData);
            const proficiencyMap = {};

            for (const letter of calibratedLetters) {
                proficiencyMap[letter] = await getLetterProficiencyFromDB(letter);
            }

            return proficiencyMap;
        }

        function groupLettersByProficiency(proficiencyMap, calibratedLetters) {
            const pools = {
                mastered: [],
                known: [],
                sometimes: [],
                unknown: []
            };

            calibratedLetters.forEach(letter => {
                const proficiency = proficiencyMap[letter] || LetterProficiency.UNKNOWN;

                switch (proficiency) {
                    case LetterProficiency.MASTERED:
                        pools.mastered.push(letter);
                        break;
                    case LetterProficiency.KNOWN:
                        pools.known.push(letter);
                        break;
                    case LetterProficiency.SOMETIMES:
                        pools.sometimes.push(letter);
                        break;
                    default:
                        pools.unknown.push(letter);
                }
            });

            return pools;
        }

        function selectRandomLetter(pool, recentHistory = []) {
            if (!pool || pool.length === 0) return null;

            // Filter out recently seen letters
            const available = pool.filter(l => !recentHistory.includes(l));

            if (available.length === 0) {
                // If all filtered out, just use full pool
                return pool[Math.floor(Math.random() * pool.length)];
            }

            return available[Math.floor(Math.random() * available.length)];
        }

        async function updateLetterProgressTracker() {
            const tracker = document.getElementById('letterProgressTracker');
            const cardsContainer = document.getElementById('letterProgressCards');

            if (!tracker || !cardsContainer) return;

            // Only show if there's an active session with introduced letters
            if (!currentSession || currentSession.newLettersIntroduced.length === 0) {
                tracker.style.display = 'none';
                return;
            }

            tracker.style.display = 'block';

            // Get proficiency map to show current level
            const proficiencyMap = await loadProficiencyMap(currentProfileId);

            // Clear and rebuild cards
            cardsContainer.innerHTML = '';

            // Show ALL introduced letters (not just practicing)
            currentSession.newLettersIntroduced.forEach(letter => {
                const stats = currentSession.letterStats.get(letter);
                if (!stats) return;

                // Check if graduated in current session first, then fall back to database proficiency
                let currentProficiency = proficiencyMap[letter] || LetterProficiency.UNKNOWN;

                // If graduated to KNOWN in this session, update proficiency locally
                if (currentSession.lettersGraduated.includes(letter)) {
                    currentProficiency = LetterProficiency.KNOWN;
                }
                const rawProgress = stats.consecutive_success_no_listen || 0;

                // Always show progress toward NEXT level (not current achievement)
                let target, nextLevel, progress, showProgressBar;

                if (currentProficiency === LetterProficiency.MASTERED) {
                    // Already at max level
                    target = null;
                    nextLevel = 'MASTERED ‚úì';
                    progress = 0;
                    showProgressBar = false;
                } else if (currentProficiency === LetterProficiency.KNOWN) {
                    // Show progress toward MASTERED
                    // Note: MASTERED requires first 3 attempts of NEXT session to be perfect
                    // But we can still show current session progress
                    target = SESSION_CONFIG.GRADUATION_THRESHOLD; // Show progress toward 10
                    nextLevel = 'MASTERED';
                    progress = Math.min(rawProgress, target);
                    showProgressBar = true;
                } else {
                    // UNKNOWN or SOMETIMES - show progress toward KNOWN
                    target = SESSION_CONFIG.GRADUATION_THRESHOLD;
                    nextLevel = 'KNOWN';

                    // If already at or past threshold, show as ready for next level
                    if (rawProgress >= target) {
                        // Ready to graduate to KNOWN, continue showing progress toward MASTERED
                        progress = target; // Show as full (10/10)
                    } else {
                        progress = rawProgress;
                    }
                    showProgressBar = true;
                }

                const percentage = target ? Math.round((progress / target) * 100) : 100;

                const card = document.createElement('div');
                card.style.cssText = `
                    background: rgba(255,255,255,0.08);
                    border-radius: 6px;
                    padding: 10px 14px;
                    min-width: 130px;
                    flex: 0 0 auto;
                `;

                const progressText = target ? `${progress}/${target} to ${nextLevel}` : nextLevel;

                const progressBarHTML = showProgressBar ? `
                    <div style="background: rgba(0,0,0,0.3); height: 6px; border-radius: 3px; overflow: hidden;">
                        <div style="background: #7CB342; height: 100%; width: ${percentage}%; transition: width 0.3s;"></div>
                    </div>
                ` : '';

                card.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 8px; ${showProgressBar ? 'margin-bottom: 6px;' : ''}">
                        <div style="font-size: 20px; font-weight: bold; color: #FDD835;">${letter}</div>
                        <div style="font-size: 11px; color: #aaa;">${progressText}</div>
                    </div>
                    ${progressBarHTML}
                `;

                cardsContainer.appendChild(card);
            });
        }

        function selectWarmupLetter(pools, recentHistory) {
            // Give them letters they know (MASTERED or KNOWN)
            const comfortableLetters = [...pools.mastered, ...pools.known];

            let selectedLetter;
            if (comfortableLetters.length === 0) {
                // All letters are new, pick random calibrated letter
                const allCalibrated = Object.keys(calibrationData);
                selectedLetter = selectRandomLetter(allCalibrated, recentHistory);
            } else {
                // Prefer MASTERED over KNOWN (2:1 ratio)
                if (pools.mastered.length > 0 && Math.random() < 0.67) {
                    selectedLetter = selectRandomLetter(pools.mastered, recentHistory);
                } else {
                    selectedLetter = selectRandomLetter(comfortableLetters, recentHistory);
                }
            }

            // Add to newLettersIntroduced if not already there
            if (selectedLetter && currentSession && !currentSession.newLettersIntroduced.includes(selectedLetter)) {
                currentSession.newLettersIntroduced.push(selectedLetter);
                console.log(`üî• Warmup introduced: ${selectedLetter}`);
            }

            return selectedLetter;
        }

        async function introduceNewLetter(pools, sessionData) {
            // Only enforce limit on UNKNOWN letters that haven't graduated yet
            const currentUnknownCount = sessionData.unknownLettersIntroduced?.length || 0;

            if (currentUnknownCount >= SESSION_CONFIG.MAX_NEW_LETTERS_PER_SESSION) {
                console.log(`‚ö†Ô∏è Max UNKNOWN letters (${SESSION_CONFIG.MAX_NEW_LETTERS_PER_SESSION}) reached this session`);
                return null;
            }

            // Pick from UNKNOWN or SOMETIMES pool
            const newLetterPool = pools.unknown.length > 0 ? pools.unknown : pools.sometimes;

            if (newLetterPool.length === 0) {
                console.log('‚úÖ No new letters available - all letters practiced!');
                return null;
            }

            // Filter out already introduced letters
            const available = newLetterPool.filter(l => !sessionData.newLettersIntroduced.includes(l));

            if (available.length === 0) {
                return null;
            }

            // Select first available letter following PHONEMES curriculum order (vowels ‚Üí easy ‚Üí common ‚Üí advanced)
            const newLetter = PHONEMES.map(p => p.letter).find(letter => available.includes(letter));
            sessionData.newLettersIntroduced.push(newLetter);

            // Track as unknown letter (counts toward 3-letter limit)
            if (!sessionData.unknownLettersIntroduced) {
                sessionData.unknownLettersIntroduced = [];
            }
            sessionData.unknownLettersIntroduced.push(newLetter);

            saveSessionData();

            console.log(`üÜï Introduced new UNKNOWN letter: ${newLetter} (${currentUnknownCount + 1}/${SESSION_CONFIG.MAX_NEW_LETTERS_PER_SESSION} unknown)`);
            return newLetter;
        }

        async function selectMixedPracticeLetter(pools, sessionData, recentHistory) {
            // Get currently practicing letters (introduced but not graduated)
            const practicingLetters = sessionData.newLettersIntroduced.filter(
                letter => !sessionData.lettersGraduated.includes(letter)
            );

            if (practicingLetters.length === 0) {
                // No letters in practice, try to introduce new one
                const newLetter = await introduceNewLetter(pools, sessionData);
                if (newLetter) {
                    return newLetter;
                }

                // Can't introduce new letter (max reached or none available)
                // Fall back to comfortable letters for review
                const comfortableLetters = [...pools.mastered, ...pools.known];
                if (comfortableLetters.length > 0) {
                    console.log('üìö Reviewing comfortable letters (max new letters reached)');
                    return selectRandomLetter(comfortableLetters, recentHistory);
                }

                // No letters available at all - should rarely happen
                console.warn('‚ö†Ô∏è No letters available for practice');
                return null;
            }

            // 50% chance: practicing letter
            // 50% chance: comfortable letter (known/mastered)
            const rand = Math.random();

            if (rand < SESSION_CONFIG.MIX_RATIO_PRACTICING) {
                return selectRandomLetter(practicingLetters, recentHistory);
            } else {
                const comfortableLetters = [...pools.mastered, ...pools.known];

                if (comfortableLetters.length === 0) {
                    // No comfortable letters, stick with practicing
                    return selectRandomLetter(practicingLetters, recentHistory);
                }

                return selectRandomLetter(comfortableLetters, recentHistory);
            }
        }

        async function selectNextLetter() {
            if (!currentSession) {
                console.error('‚ùå No active session for adaptive selection');
                return null;
            }

            const calibratedLetters = Object.keys(calibrationData);
            if (calibratedLetters.length === 0) {
                console.warn('‚ö†Ô∏è No calibrated letters yet');
                return null;
            }

            // Load proficiency map
            const proficiencyMap = await loadProficiencyMap(currentProfileId);
            const pools = groupLettersByProficiency(proficiencyMap, calibratedLetters);

            console.log('üìä Pools:', {
                mastered: pools.mastered.length,
                known: pools.known.length,
                sometimes: pools.sometimes.length,
                unknown: pools.unknown.length
            });

            const attemptCount = currentSession.attempts.length;
            const recentHistory = currentSession.recentHistory || [];

            // Phase 1: Warmup (first 5 attempts)
            if (attemptCount < SESSION_CONFIG.WARMUP_COUNT) {
                console.log(`üî• Warmup phase (${attemptCount + 1}/${SESSION_CONFIG.WARMUP_COUNT})`);
                return selectWarmupLetter(pools, recentHistory);
            }

            // Phase 2: Check if we need rapid reinforcement (letter with remaining rapid reps)
            if (currentSession.attempts.length > 0) {
                // Check all letters to see if any are in rapid reinforcement mode
                for (const [letter, stats] of currentSession.letterStats) {
                    if (stats.rapid_reps_remaining > 0) {
                        const repsCompleted = SESSION_CONFIG.RAPID_REP_COUNT - stats.rapid_reps_remaining + 1;
                        console.log(`üîÅ Rapid reinforcement: ${letter} (${repsCompleted}/${SESSION_CONFIG.RAPID_REP_COUNT})`);
                        // Decrement counter for next round
                        stats.rapid_reps_remaining--;
                        return letter;
                    }
                }
            }

            // Phase 3: Mixed practice or introduce new letter
            const selected = await selectMixedPracticeLetter(pools, currentSession, recentHistory);

            // Update recent history
            if (selected) {
                currentSession.recentHistory = currentSession.recentHistory || [];
                currentSession.recentHistory.push(selected);
                if (currentSession.recentHistory.length > SESSION_CONFIG.RECENT_HISTORY_SIZE) {
                    currentSession.recentHistory.shift();
                }
                saveSessionData();
            }

            return selected;
        }

        const PHONEMES = [
            // ===== VOWELS =====
            { letter: 'a', hint: 'Say: aaa (like "apple")', type: 'vowel', group: 'vowels', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-a.mp3' },
            { letter: 'e', hint: 'Say: eee (like "egg")', type: 'vowel', group: 'vowels', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-e.mp3' },
            { letter: 'i', hint: 'Say: iii (like "igloo")', type: 'vowel', group: 'vowels', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-i.mp3' },
            { letter: 'o', hint: 'Say: ooo (like "octopus")', type: 'vowel', group: 'vowels', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-o-sh.mp3' },
            { letter: 'u', hint: 'Say: uuu (like "umbrella")', type: 'vowel', group: 'vowels', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-u-sh.mp3' },

            // ===== EASY CONSONANTS =====
            { letter: 'm', hint: 'Say: mmm (hum)', type: 'nasal', group: 'easy', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-m.mp3' },
            { letter: 's', hint: 'Say: sss (like "snake")', type: 'fricative', group: 'easy', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-z.mp3' },
            { letter: 't', hint: 'Repeat: tuh, tuh', type: 'plosive', group: 'easy', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-t.mp3' },
            { letter: 'b', hint: 'Repeat: buh, buh', type: 'plosive', group: 'easy', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-b.mp3' },
            { letter: 'f', hint: 'Say: fff (like "fan")', type: 'fricative', group: 'easy', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-f.mp3' },
            { letter: 'n', hint: 'Say: nnn (like "no")', type: 'nasal', group: 'easy', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-n.mp3' },

            // ===== COMMON CONSONANTS =====
            { letter: 'p', hint: 'Repeat: puh, puh', type: 'plosive', group: 'common', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-p-2.mp3' },
            { letter: 'd', hint: 'Repeat: duh, duh (like "dog")', type: 'plosive', group: 'common', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-d.mp3' },
            { letter: 'l', hint: 'Say: lll (like "lion")', type: 'liquid', group: 'common', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-l.mp3' },
            { letter: 'r', hint: 'Say: rrr (like "run")', type: 'liquid', group: 'common', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-r.mp3' },
            { letter: 'c', hint: 'Repeat: cuh, cuh (like "cat")', type: 'plosive', group: 'common', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-c.mp3' },
            { letter: 'g', hint: 'Repeat: guh, guh (like "go")', type: 'plosive', group: 'common', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-g.mp3' },
            { letter: 'h', hint: 'Say: hhh (like "hat")', type: 'fricative', group: 'common', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-h.mp3' },

            // ===== ADVANCED =====
            { letter: 'w', hint: 'Say: www (like "water")', type: 'semivowel', group: 'advanced', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-w.mp3' },
            { letter: 'y', hint: 'Say: yuh (like "yes")', type: 'semivowel', group: 'advanced', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/btalpha-i-long.mp3' },
            { letter: 'j', hint: 'Say: juh (like "jump")', type: 'affricate', group: 'advanced', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-j.mp3' },
            { letter: 'k', hint: 'Repeat: kuh, kuh', type: 'plosive', group: 'advanced', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-k.mp3' },
            { letter: 'v', hint: 'Say: vvv (like "van")', type: 'fricative', group: 'advanced', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-v.mp3' },
            { letter: 'z', hint: 'Say: zzz (like "zoo")', type: 'fricative', group: 'advanced', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-z.mp3' },
            { letter: 'x', hint: 'Say: ks (like "fox")', type: 'affricate', group: 'advanced', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-x.mp3' },
            { letter: 'q', hint: 'Say: kwuh (like "queen")', type: 'affricate', group: 'advanced', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-q.mp3' }
        ];

        // ======================
        // Supabase Helper Functions
        // ======================

        let currentProfileId = null; // Store the current profile's UUID

        async function getOrCreateProfile(profileName) {
            try {
                // Try to find existing profile by name (get the most recent one if multiple exist)
                const { data: existingProfiles, error: fetchError } = await supabase
                    .from('profiles')
                    .select('*')
                    .eq('name', profileName)
                    .is('user_id', null) // Only get anonymous profiles
                    .order('created_at', { ascending: false })
                    .limit(1);

                if (fetchError) throw fetchError;

                if (existingProfiles && existingProfiles.length > 0) {
                    console.log(`‚úÖ Found existing profile: ${profileName} (${existingProfiles[0].id.substring(0, 8)}...)`);
                    return existingProfiles[0];
                }

                // Create new profile if not found
                const { data: newProfile, error: createError } = await supabase
                    .from('profiles')
                    .insert([{ name: profileName }])
                    .select()
                    .single();

                if (createError) throw createError;

                console.log(`‚úÖ Created new profile: ${profileName} (${newProfile.id.substring(0, 8)}...)`);
                return newProfile;
            } catch (error) {
                console.error('‚ùå Error with profile:', error);
                return null;
            }
        }

        async function saveCalibrationToSupabase(letter, patternData, audioBlob) {
            if (!currentProfileId) {
                console.error('‚ùå No profile selected');
                return false;
            }

            try {
                const startTime = Date.now();
                let audioUrl = null;

                // Upload audio to Supabase Storage if provided
                if (audioBlob) {
                    const blobSizeKB = (audioBlob.size / 1024).toFixed(2);
                    console.log(`üì§ Uploading audio: ${blobSizeKB} KB`);

                    const audioFileName = `${currentProfileId}/${letter}_${Date.now()}.webm`;

                    const uploadStart = Date.now();
                    const { data: uploadData, error: uploadError } = await supabase.storage
                        .from('calibration-audio')
                        .upload(audioFileName, audioBlob, {
                            contentType: 'audio/webm'
                        });
                    const uploadTime = Date.now() - uploadStart;
                    console.log(`‚è±Ô∏è Upload took: ${uploadTime}ms`);

                    if (uploadError) {
                        console.error('‚ùå Audio upload error:', uploadError);
                        // Continue without audio if upload fails
                    } else {
                        // Get public URL
                        const { data: { publicUrl } } = supabase.storage
                            .from('calibration-audio')
                            .getPublicUrl(audioFileName);
                        audioUrl = publicUrl;
                        console.log('‚úÖ Audio uploaded:', audioUrl);
                    }
                }

                // Save calibration data to database
                console.log('üíæ Saving to database...');
                const dbStart = Date.now();
                const { data, error } = await supabase
                    .from('calibrations')
                    .upsert({
                        profile_id: currentProfileId,
                        letter: letter,
                        pattern_data: patternData,
                        audio_url: audioUrl,
                        updated_at: new Date().toISOString()
                    }, {
                        onConflict: 'profile_id,letter'
                    })
                    .select();
                const dbTime = Date.now() - dbStart;
                console.log(`‚è±Ô∏è Database save took: ${dbTime}ms`);

                if (error) throw error;

                const totalTime = Date.now() - startTime;
                console.log(`‚úÖ Saved calibration for letter ${letter} (total: ${totalTime}ms)`);
                return audioUrl; // Return the audio URL so it can be stored locally
            } catch (error) {
                console.error('‚ùå Error saving calibration:', error);
                alert(`Failed to save calibration: ${error.message}`);
                return null;
            }
        }

        async function loadCalibrationsFromSupabase() {
            if (!currentProfileId) {
                console.error('‚ùå No profile selected');
                return {};
            }

            try {
                const loadStart = Date.now();
                console.log('‚è≥ Loading calibrations from ALL profiles (cross-profile pooling)...');

                // LOAD FROM ALL PROFILES (not just current one)
                const { data, error} = await supabase
                    .from('calibrations')
                    .select('*');

                const loadTime = Date.now() - loadStart;
                console.log(`‚è±Ô∏è Supabase query took: ${loadTime}ms`);

                if (error) throw error;

                // Convert to the NEW snapshot-based format
                const calibrations = {};
                let totalSnapshots = 0;

                data.forEach(cal => {
                    // Force letter to lowercase (handles old uppercase calibrations)
                    const letter = cal.letter.toLowerCase();

                    // Initialize letter if not exists
                    if (!calibrations[letter]) {
                        calibrations[letter] = {
                            snapshots: [],
                            audioUrl: null
                        };
                    }

                    // BACKWARD COMPATIBILITY: Handle old format
                    let snapshots = [];
                    if (cal.pattern_data.snapshots) {
                        // NEW FORMAT: Already has snapshots array
                        snapshots = cal.pattern_data.snapshots;
                    } else if (cal.pattern_data.pattern) {
                        // OLD FORMAT: { pattern: [[...], [...]] }
                        snapshots = cal.pattern_data.pattern.map(data => ({
                            data: data,
                            score: 0,
                            isNegative: false,
                            profileId: cal.profile_id,
                            createdAt: cal.created_at
                        }));
                    } else {
                        // VERY OLD FORMAT: pattern_data is just the array
                        snapshots = [{
                            data: cal.pattern_data,
                            score: 0,
                            isNegative: false,
                            profileId: cal.profile_id,
                            createdAt: cal.created_at
                        }];
                    }

                    // Add all snapshots from this calibration to the pool
                    calibrations[letter].snapshots.push(...snapshots);
                    totalSnapshots += snapshots.length;

                    // Keep the most recent audio URL
                    if (cal.audio_url && !calibrations[letter].audioUrl) {
                        calibrations[letter].audioUrl = cal.audio_url;
                    }

                    // Load any local additions from localStorage (for current profile)
                    if (cal.profile_id === currentProfileId) {
                        const localKey = `calibration_extras_${currentProfileId}_${letter}`;
                        const localData = localStorage.getItem(localKey);
                        if (localData) {
                            try {
                                const extras = JSON.parse(localData);
                                // Convert old localStorage format to snapshot format
                                if (extras.patterns) {
                                    extras.patterns.forEach(data => {
                                        calibrations[letter].snapshots.push({
                                            data: data,
                                            score: 0,
                                            isNegative: false,
                                            profileId: currentProfileId,
                                            createdAt: new Date().toISOString()
                                        });
                                        totalSnapshots++;
                                    });
                                }
                                if (extras.negativePatterns) {
                                    extras.negativePatterns.forEach(data => {
                                        calibrations[letter].snapshots.push({
                                            data: data,
                                            score: 0,
                                            isNegative: true,
                                            profileId: currentProfileId,
                                            createdAt: new Date().toISOString()
                                        });
                                        totalSnapshots++;
                                    });
                                }
                            } catch (e) {
                                console.warn(`Failed to load local extras for ${letter}:`, e);
                            }
                        }
                    }
                });

                console.log(`‚úÖ Loaded ${Object.keys(calibrations).length} letters with ${totalSnapshots} total snapshots from ${data.length} profiles`);

                // Auto-migrate old format calibrations to new format
                await migrateOldCalibrationsToNewFormat(data);

                return calibrations;
            } catch (error) {
                console.error('‚ùå Error loading calibrations:', error);
                return {};
            }
        }

        // Migrate old format calibrations to new snapshot format
        async function migrateOldCalibrationsToNewFormat(calibrationRecords) {
            if (!calibrationRecords || calibrationRecords.length === 0) return;

            let migratedCount = 0;
            const migrations = [];

            for (const cal of calibrationRecords) {
                // Check if already in new format
                if (cal.pattern_data.snapshots) {
                    continue; // Already migrated
                }

                // Convert old format to new format
                let snapshots = [];
                if (cal.pattern_data.pattern) {
                    // OLD FORMAT: { pattern: [[...], [...]] }
                    snapshots = cal.pattern_data.pattern.map(data => ({
                        data: data,
                        score: 0,
                        isNegative: false,
                        profileId: cal.profile_id,
                        createdAt: cal.created_at
                    }));
                } else {
                    // VERY OLD FORMAT: pattern_data is just the array
                    snapshots = [{
                        data: cal.pattern_data,
                        score: 0,
                        isNegative: false,
                        profileId: cal.profile_id,
                        createdAt: cal.created_at
                    }];
                }

                // Queue the migration update
                migrations.push({
                    profile_id: cal.profile_id,
                    letter: cal.letter,
                    pattern_data: { snapshots }
                });

                migratedCount++;
            }

            // Execute all migrations
            if (migrations.length > 0) {
                console.log(`üîÑ Migrating ${migrations.length} calibrations to new snapshot format...`);

                try {
                    for (const migration of migrations) {
                        const { error } = await supabase
                            .from('calibrations')
                            .update({
                                pattern_data: migration.pattern_data,
                                updated_at: new Date().toISOString()
                            })
                            .eq('profile_id', migration.profile_id)
                            .eq('letter', migration.letter);

                        if (error) {
                            console.error(`‚ùå Error migrating ${migration.letter}:`, error);
                        }
                    }
                    console.log(`‚úÖ Successfully migrated ${migratedCount} calibrations to new format`);
                } catch (error) {
                    console.error('‚ùå Error during migration:', error);
                }
            }
        }

        const PLOSIVES = ['b', 'c', 'd', 'g', 'k', 'p', 't'];
        const NASALS = ['m', 'n'];

        function isPlosive(letter) {
            return PLOSIVES.includes(letter);
        }

        function isNasal(letter) {
            return NASALS.includes(letter);
        }

        // Pattern matching parameters
        const PATTERN_LENGTH = 30; // Number of frequency snapshots
        const PATTERN_BINS = 64;   // Number of frequency bins per snapshot

        // ========== SNAPSHOT SCORING SYSTEM ==========
        // Track which negative snapshots already got points this round (per letter display)
        let currentScoringRound = {
            letter: null,
            negativeSnapshotsAwarded: new Set() // Set of snapshot objects that already got points
        };

        // Increment score for a snapshot (in memory)
        function incrementSnapshotScore(letter, snapshot) {
            if (!snapshot || !calibrationData[letter] || !calibrationData[letter].snapshots) {
                console.log('‚ùå incrementSnapshotScore: Missing data', {
                    hasSnapshot: !!snapshot,
                    hasCalibrationData: !!calibrationData[letter],
                    hasSnapshots: !!calibrationData[letter]?.snapshots
                });
                return;
            }

            console.log('üîç incrementSnapshotScore called:', {
                letter,
                hasSnapshotData: !!snapshot.data,
                snapshotDataLength: snapshot.data?.length,
                snapshotProfileId: snapshot.profileId?.substring(0, 8),
                totalSnapshotsInMemory: calibrationData[letter].snapshots.length
            });

            // First try: Direct object reference lookup (fastest)
            let snapshotIndex = calibrationData[letter].snapshots.indexOf(snapshot);

            // Second try: Match by data content if direct reference fails
            if (snapshotIndex === -1) {
                console.log('‚ö†Ô∏è Direct object reference failed, trying data comparison...');
                snapshotIndex = calibrationData[letter].snapshots.findIndex(s => {
                    // Match by comparing the actual pattern data
                    if (!s.data || !snapshot.data) {
                        console.log('  Missing data:', { sHasData: !!s.data, snapshotHasData: !!snapshot.data });
                        return false;
                    }
                    if (s.data.length !== snapshot.data.length) {
                        console.log('  Length mismatch:', { sLength: s.data.length, snapshotLength: snapshot.data.length });
                        return false;
                    }

                    // Compare first few values to confirm it's the same pattern
                    const matches = s.data.slice(0, 10).every((val, i) => Math.abs(val - snapshot.data[i]) < 0.0001);
                    if (!matches) {
                        console.log('  Data mismatch in first 10 values:', {
                            storedFirst10: s.data.slice(0, 10),
                            searchFirst10: snapshot.data.slice(0, 10),
                            differences: s.data.slice(0, 10).map((val, i) => Math.abs(val - snapshot.data[i]))
                        });
                    }
                    return matches;
                });
            }

            console.log(`üîç Snapshot lookup result:`, {
                snapshotsAvailable: calibrationData[letter].snapshots.length,
                foundIndex: snapshotIndex,
                searchingFor: snapshot.profileId?.substring(0, 8)
            });

            if (snapshotIndex !== -1) {
                const foundSnapshot = calibrationData[letter].snapshots[snapshotIndex];
                foundSnapshot.score = (foundSnapshot.score || 0) + 1;
                console.log(`üìä Snapshot score incremented: ${letter} [${foundSnapshot.isNegative ? 'NEG' : 'POS'}] ‚Üí ${foundSnapshot.score} (profile: ${foundSnapshot.profileId?.substring(0, 8)}...)`);

                // Persist to Supabase (debounced to avoid too many DB calls)
                debounceSaveScores(letter, foundSnapshot.profileId);
            } else {
                console.error(`‚ùå Could not find matching snapshot in calibrationData for ${letter}`, {
                    snapshotObject: snapshot,
                    availableSnapshots: calibrationData[letter].snapshots.map(s => ({
                        profileId: s.profileId?.substring(0, 8),
                        hasData: !!s.data,
                        dataLength: s.data?.length,
                        isNegative: s.isNegative
                    }))
                });
            }
        }

        // Debounce score saves to avoid hammering the database
        let saveScoreTimers = {};
        let pendingSaves = new Set(); // Track which letter/profile combos need saving

        function debounceSaveScores(letter, profileId) {
            const key = `${letter}_${profileId}`;
            pendingSaves.add(key); // Mark as needing save

            if (saveScoreTimers[key]) {
                clearTimeout(saveScoreTimers[key]);
            }
            saveScoreTimers[key] = setTimeout(() => {
                saveSnapshotScoresToSupabase(letter, profileId);
                pendingSaves.delete(key); // Remove from pending after save
            }, 2000); // Save 2 seconds after last score change
        }

        // Immediately flush all pending score saves (called on letter change or page unload)
        async function flushAllPendingScores() {
            const saves = Array.from(pendingSaves).map(key => {
                const [letter, ...profileIdParts] = key.split('_');
                const profileId = profileIdParts.join('_'); // Handle UUIDs with underscores
                return { letter, profileId };
            });

            if (saves.length === 0) return;

            console.log(`üîÑ Flushing ${saves.length} pending score save(s)...`);

            // Clear all timers
            Object.values(saveScoreTimers).forEach(timer => clearTimeout(timer));
            saveScoreTimers = {};

            // Save all immediately
            await Promise.all(saves.map(({ letter, profileId }) =>
                saveSnapshotScoresToSupabase(letter, profileId)
            ));

            pendingSaves.clear();
            console.log('‚úÖ All pending scores flushed');
        }

        // Save snapshot scores back to Supabase
        async function saveSnapshotScoresToSupabase(letter, profileId) {
            if (!calibrationData[letter] || !calibrationData[letter].snapshots) return;

            try {
                // Get all snapshots for this letter from this profile
                const profileSnapshots = calibrationData[letter].snapshots.filter(s => s.profileId === profileId);
                if (profileSnapshots.length === 0) return;

                // Build the pattern_data object with updated scores
                const patternData = {
                    snapshots: profileSnapshots
                };

                // Update in Supabase
                const { error } = await supabase
                    .from('calibrations')
                    .update({
                        pattern_data: patternData,
                        updated_at: new Date().toISOString()
                    })
                    .eq('profile_id', profileId)
                    .eq('letter', letter);

                if (error) {
                    console.error(`‚ùå Error saving scores for ${letter}:`, error);
                } else {
                    console.log(`üíæ Saved snapshot scores to Supabase: ${letter} (${profileSnapshots.length} snapshots)`);
                }
            } catch (error) {
                console.error(`‚ùå Error in saveSnapshotScoresToSupabase:`, error);
            }
        }

        // Reset round tracking when letter changes
        async function startNewScoringRound(letter) {
            // Flush any pending scores from previous letter
            await flushAllPendingScores();

            currentScoringRound = {
                letter: letter,
                negativeSnapshotsAwarded: new Set()
            };
        }

        // Check if negative snapshot can get a point this round
        function canAwardNegativePoint(snapshot) {
            return !currentScoringRound.negativeSnapshotsAwarded.has(snapshot);
        }

        // Mark negative snapshot as awarded for this round
        function markNegativeSnapshotAwarded(snapshot) {
            currentScoringRound.negativeSnapshotsAwarded.add(snapshot);
        }

        // ========== LOCALSTORAGE TO SUPABASE MIGRATION ==========
        async function migrateLocalStorageToSupabase() {
            const progressDiv = document.getElementById('migrationProgress');
            const statusDiv = document.getElementById('migrationStatus');
            const detailsDiv = document.getElementById('migrationDetails');

            // Show progress UI
            progressDiv.style.display = 'block';
            statusDiv.textContent = 'üîç Scanning for old data...';
            detailsDiv.textContent = '';

            try {
                // Get all profiles from Supabase
                const { data: profiles, error: profilesError } = await supabase
                    .from('profiles')
                    .select('id, name');

                if (profilesError) throw profilesError;

                if (!profiles || profiles.length === 0) {
                    statusDiv.textContent = '‚ùå No profiles found';
                    detailsDiv.textContent = 'Please create a profile and calibrate at least one letter first.';
                    return;
                }

                statusDiv.textContent = `üìä Found ${profiles.length} profile(s)`;
                detailsDiv.textContent = `Checking: ${profiles.map(p => p.name).join(', ')}`;

                await new Promise(resolve => setTimeout(resolve, 500)); // Brief pause

                let totalMigrated = 0;
                let totalSnapshots = 0;
                const letters = 'abcdefghijklmnopqrstuvwxyz'.split('');
                const migrationLog = [];

                // For each profile, check localStorage for extras
                for (const profile of profiles) {
                    statusDiv.textContent = `üîÑ Migrating profile: ${profile.name}...`;

                    for (const letter of letters) {
                        const localKey = `calibration_extras_${profile.id}_${letter}`;
                        const localData = localStorage.getItem(localKey);

                        if (!localData) continue;

                        try {
                            const extras = JSON.parse(localData);
                            const snapshots = [];

                            // Convert positive patterns
                            if (extras.patterns && extras.patterns.length > 0) {
                                extras.patterns.forEach(data => {
                                    snapshots.push({
                                        data: data,
                                        score: 0,
                                        isNegative: false,
                                        profileId: profile.id,
                                        createdAt: new Date().toISOString()
                                    });
                                });
                            }

                            // Convert negative patterns
                            if (extras.negativePatterns && extras.negativePatterns.length > 0) {
                                extras.negativePatterns.forEach(data => {
                                    snapshots.push({
                                        data: data,
                                        score: 0,
                                        isNegative: true,
                                        profileId: profile.id,
                                        createdAt: new Date().toISOString()
                                    });
                                });
                            }

                            if (snapshots.length === 0) continue;

                            // Load existing calibration from Supabase
                            const { data: existingCal, error: fetchError } = await supabase
                                .from('calibrations')
                                .select('*')
                                .eq('profile_id', profile.id)
                                .eq('letter', letter)
                                .single();

                            if (fetchError && fetchError.code !== 'PGRST116') {
                                // PGRST116 = not found, which is ok
                                throw fetchError;
                            }

                            // Merge with existing snapshots
                            let allSnapshots = [...snapshots];
                            if (existingCal && existingCal.pattern_data) {
                                if (existingCal.pattern_data.snapshots) {
                                    // New format - merge
                                    allSnapshots = [...existingCal.pattern_data.snapshots, ...snapshots];
                                } else if (existingCal.pattern_data.pattern) {
                                    // Old format - convert and merge
                                    const oldSnapshots = existingCal.pattern_data.pattern.map(data => ({
                                        data: data,
                                        score: 0,
                                        isNegative: false,
                                        profileId: profile.id,
                                        createdAt: existingCal.created_at
                                    }));
                                    allSnapshots = [...oldSnapshots, ...snapshots];
                                }
                            }

                            // Save to Supabase in new format
                            const patternData = { snapshots: allSnapshots };
                            const { error: saveError } = await supabase
                                .from('calibrations')
                                .upsert({
                                    profile_id: profile.id,
                                    letter: letter,
                                    pattern_data: patternData,
                                    audio_url: existingCal?.audio_url || null,
                                    updated_at: new Date().toISOString()
                                }, {
                                    onConflict: 'profile_id,letter'
                                });

                            if (saveError) throw saveError;

                            totalMigrated++;
                            totalSnapshots += snapshots.length;
                            migrationLog.push(`‚úì ${profile.name}/${letter.toUpperCase()}: ${snapshots.length} snapshot(s)`);

                            detailsDiv.textContent = migrationLog.slice(-5).join('\n'); // Show last 5

                        } catch (e) {
                            console.error(`Error migrating ${profile.name}/${letter}:`, e);
                            migrationLog.push(`‚úó ${profile.name}/${letter.toUpperCase()}: ${e.message}`);
                        }
                    }
                }

                // Migration complete
                if (totalMigrated === 0) {
                    statusDiv.textContent = '‚úÖ No old data found to migrate';
                    detailsDiv.textContent = 'All data is already in the database. You\'re good to go!';
                } else {
                    statusDiv.textContent = `‚úÖ Migration Complete!`;
                    detailsDiv.textContent = `Migrated ${totalSnapshots} snapshot(s) across ${totalMigrated} letter(s)\n\n` +
                        migrationLog.slice(-10).join('\n') +
                        `\n\nüéâ Old data is now in the database and will sync across devices!`;

                    // Reload calibrations to show the migrated data
                    setTimeout(async () => {
                        statusDiv.textContent = 'üîÑ Reloading calibrations...';
                        calibrationData = await loadCalibrationsFromSupabase();
                        updateCalibrationUI();
                        statusDiv.textContent = `‚úÖ Done! ${totalSnapshots} snapshots migrated.`;
                    }, 2000);
                }

            } catch (error) {
                statusDiv.textContent = '‚ùå Migration failed';
                detailsDiv.textContent = `Error: ${error.message}\n\nCheck browser console for details.`;
                console.error('Migration error:', error);
            }
        }

        // Profile management
        let currentProfile = 'Default';

        function loadProfiles() {
            const saved = localStorage.getItem('phonicsProfiles');
            const profiles = saved ? JSON.parse(saved) : ['Default'];

            const select = document.getElementById('profileSelect');
            select.innerHTML = '';

            profiles.forEach(profile => {
                const option = document.createElement('option');
                option.value = profile;
                option.textContent = profile;
                if (profile === currentProfile) {
                    option.selected = true;
                }
                select.appendChild(option);
            });

            return profiles;
        }

        function saveProfiles(profiles) {
            localStorage.setItem('phonicsProfiles', JSON.stringify(profiles));
        }

        async function switchProfile() {
            const select = document.getElementById('profileSelect');
            currentProfile = select.value;
            localStorage.setItem('currentProfile', currentProfile);

            // Clear guest profile ID since we're using a named profile
            localStorage.removeItem('guestProfileId');
            guestProfileId = null;

            // Get or create profile in Supabase by name
            const profile = await getOrCreateProfile(currentProfile);
            if (profile) {
                currentProfileId = profile.id;
                console.log(`‚úÖ Switched to profile: ${currentProfile} (${profile.id.substring(0, 8)}...)`);
            }

            // Load calibration for this profile
            await loadCalibration();
            createCalibrationGrid();
            updateCalibrationStats();
        }

        async function createNewProfile() {
            const name = prompt('Enter profile name (e.g., "Ophelia", "Rey", "Marc"):');
            if (!name || name.trim() === '') return;

            const profiles = loadProfiles();
            if (profiles.includes(name.trim())) {
                alert('Profile already exists!');
                return;
            }

            profiles.push(name.trim());
            saveProfiles(profiles);
            currentProfile = name.trim();
            localStorage.setItem('currentProfile', currentProfile);

            // Clear guest profile ID
            localStorage.removeItem('guestProfileId');
            guestProfileId = null;

            // Create profile in Supabase
            const profile = await getOrCreateProfile(currentProfile);
            if (profile) {
                currentProfileId = profile.id;
                console.log(`‚úÖ Created new profile: ${currentProfile} (${profile.id.substring(0, 8)}...)`);
            }

            // Clear calibration for new profile
            calibrationData = {};

            loadProfiles();
            await loadCalibration();
            createCalibrationGrid();
            updateCalibrationStats();
        }

        async function loadCalibration() {
            // Load ONLY from Supabase (no localStorage fallback)
            if (currentProfileId) {
                const supabaseData = await loadCalibrationsFromSupabase();
                calibrationData = supabaseData;
                updateCalibrationUI();

            } else{
                calibrationData = {};
                console.warn('‚ö†Ô∏è No profile ID - waiting for Supabase profile initialization');
            }

            // Load letter sensitivity settings from localStorage
            const savedSensitivity = localStorage.getItem(`letterSensitivity_${currentProfile}`);
            if (savedSensitivity) {
                letterSensitivity = JSON.parse(savedSensitivity);
            } else {
                // Initialize default sensitivity (1.0 = 100%) for all letters
                letterSensitivity = {};
                PHONEMES.forEach(p => {
                    letterSensitivity[p.letter] = 1.0;
                });
            }
        }

        function createCalibrationGrid() {
            const grid = document.getElementById('calibrationGrid');
            grid.innerHTML = '';

            const groupLabels = {
                'vowels': 'Vowels',
                'easy': 'Easy Consonants',
                'common': 'Common Consonants',
                'advanced': 'Advanced'
            };

            let currentGroup = null;

            PHONEMES.forEach(phoneme => {
                if (phoneme.group !== currentGroup) {
                    currentGroup = phoneme.group;
                    const header = document.createElement('div');
                    header.className = 'calibration-group-header';
                    header.textContent = groupLabels[currentGroup];
                    grid.appendChild(header);
                }

                const card = document.createElement('div');
                card.className = 'phoneme-card';
                card.id = `card-${phoneme.letter}`;

                const isCalibrated = calibrationData[phoneme.letter];
                if (isCalibrated) {
                    card.classList.add('calibrated');
                }

                const sensitivity = letterSensitivity[phoneme.letter] || 1.0;
                // Invert for display: high sensitivity (1.5) = low slider (50) = "Easy"
                const sliderValue = Math.round(200 - (sensitivity * 100));
                const label = sliderValue <= 70 ? 'Easy' : sliderValue >= 130 ? 'Strict' : 'Normal';
                const sensitivityPercent = Math.round(sensitivity * 100);

                // Golden letters when calibrated (removed level progress tracking)
                const isGolden = isCalibrated;
                const letterStyle = isGolden ? 'background: linear-gradient(135deg, #FFD700, #FFA500); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-weight: bold;' : '';

                card.innerHTML = `
                    <div class="phoneme-letter" style="${letterStyle}">${phoneme.letter}</div>
                    <div class="phoneme-hint">${phoneme.hint}</div>
                    ${phoneme.audioUrl ? `<div style="font-size: 30px; cursor: pointer; margin: 5px 0;" onclick="event.stopPropagation(); playPhonemeSound('${phoneme.letter}')" title="Listen to sound">üîä</div>` : ''}
                    <div class="snapshots-container" id="snapshots-${phoneme.letter}"></div>
                    <div class="phoneme-status">${isCalibrated ? '‚úì Calibrated' : 'Click to record'}</div>
                    <div class="sensitivity-control" id="sensitivity-${phoneme.letter}" style="margin-top: 10px; display: none;">
                        <div style="color: #aaa; font-size: 11px; margin-bottom: 8px; display: flex; justify-content: space-between;">
                            <span style="color: #7CB342;">Easy</span>
                            <span id="sens-value-${phoneme.letter}" style="color: #FDD835; font-weight: bold;">${label} (${sensitivityPercent}%)</span>
                            <span style="color: #F44336;">Strict</span>
                        </div>
                        <input type="range" min="50" max="150" value="${sliderValue}"
                               style="width: 100%;"
                               oninput="updateSensitivity('${phoneme.letter}', this.value)"
                               onclick="event.stopPropagation()">
                    </div>
                    <button class="settings-btn" onclick="event.stopPropagation(); toggleSensitivitySlider('${phoneme.letter}')"
                            style="margin-top: 8px; background: #666; color: white; border: none; border-radius: 5px; padding: 5px 10px; cursor: pointer; font-size: 12px;">
                        ‚öôÔ∏è Settings
                    </button>
                `;

                card.onclick = () => openCalibrationModal(phoneme.letter);
                grid.appendChild(card);
            });
        }

        function toggleSensitivitySlider(letter) {
            const slider = document.getElementById(`sensitivity-${letter}`);
            if (slider) {
                slider.style.display = slider.style.display === 'none' ? 'block' : 'none';
            }
        }

        function updateSensitivity(letter, sliderValue) {
            // Invert: slider 50 = sensitivity 1.5 (Easy), slider 150 = sensitivity 0.5 (Strict)
            const sensitivity = (200 - parseInt(sliderValue)) / 100;
            letterSensitivity[letter] = sensitivity;

            // Update display label with percentage
            const valueDisplay = document.getElementById(`sens-value-${letter}`);
            if (valueDisplay) {
                const label = sliderValue <= 70 ? 'Easy' : sliderValue >= 130 ? 'Strict' : 'Normal';
                const sensitivityPercent = Math.round(sensitivity * 100);
                valueDisplay.textContent = `${label} (${sensitivityPercent}%)`;
            }

            // Save to localStorage
            localStorage.setItem(`letterSensitivity_${currentProfile}`, JSON.stringify(letterSensitivity));

            console.log(`‚úÖ Updated ${letter}: slider=${sliderValue}, sensitivity=${sensitivity.toFixed(2)}x (${Math.round(sensitivity * 100)}%), label=${sliderValue <= 70 ? 'Easy' : sliderValue >= 130 ? 'Strict' : 'Normal'}`);
        }

        let capturedSnapshots = [];
        let lastPeakTime = 0;
        const SNAPSHOTS_NEEDED = 5;
        const PEAK_COOLDOWN = 500; // ms between peaks

        async function startCalibrationRecording(letter) {
            if (isRecording) return;

            if (!audioContext) {
                await setupAudio();
            }

            isRecording = true;
            recordingPhoneme = letter;
            capturedSnapshots = [];
            audioChunks = [];
            lastPeakTime = 0;

            // DISABLED: Audio recording takes too much localStorage space
            // if (microphone && microphone.stream) {
            //     mediaRecorder = new MediaRecorder(microphone.stream);
            //     mediaRecorder.ondataavailable = (event) => {
            //         if (event.data.size > 0) {
            //             audioChunks.push(event.data);
            //         }
            //     };
            //     mediaRecorder.start();
            // }

            const card = document.getElementById(`card-${letter}`);
            card.classList.add('recording');
            card.querySelector('.phoneme-status').textContent = `Say "${letter}" - 0/${SNAPSHOTS_NEEDED} captured`;

            // Create snapshot thumbnail canvases
            const snapshotsContainer = document.getElementById(`snapshots-${letter}`);
            snapshotsContainer.innerHTML = '';
            for (let i = 0; i < SNAPSHOTS_NEEDED; i++) {
                const canvas = document.createElement('canvas');
                canvas.className = 'snapshot-thumb';
                canvas.width = 50;
                canvas.height = 40;
                canvas.id = `snapshot-${letter}-${i}`;
                snapshotsContainer.appendChild(canvas);
            }

            // Start listening for peaks
            listenForPeaks(letter);
        }

        function listenForPeaks(letter) {
            if (!isRecording || recordingPhoneme !== letter) {
                if (!isRecording) console.log('Stopped listening: isRecording = false');
                if (recordingPhoneme !== letter) console.log(`Stopped listening: letter mismatch (${recordingPhoneme} vs ${letter})`);
                return;
            }

            analyser.getByteFrequencyData(dataArray);

            // Calculate current volume
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volume = (sum / dataArray.length / 128) * 100;

            // SOLUTION 1: Dynamic volume threshold for nasals
            const volumeThreshold = isNasal(letter) ? 4 : 15;

            // Detect peak (loud moment after cooldown)
            const now = Date.now();
            if (volume > volumeThreshold && (now - lastPeakTime) > PEAK_COOLDOWN) {
                // SNAP! Capture this peak moment
                let snapshot = downsampleFrequencies(dataArray, PATTERN_BINS);

                // SOLUTION 5: Check energy concentration for nasals
                const peakEnergy = Math.max(...snapshot);
                const avgEnergy = snapshot.reduce((a, b) => a + b, 0) / snapshot.length;
                const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;
                const concentrationThreshold = isNasal(letter) ? 1.5 : 2.0;

                // Skip if energy too diffuse (likely background noise)
                if (energyConcentration < concentrationThreshold) {
                    requestAnimationFrame(() => listenForPeaks(letter));
                    return;
                }

                // SOLUTION 3: Pre-amplify nasal sounds before normalization
                if (isNasal(letter)) {
                    snapshot = snapshot.map(v => v * 2.0);
                }

                // Normalize to 0-1 range
                const maxVal = Math.max(...snapshot);
                const normalized = snapshot.map(v => v / maxVal);

                capturedSnapshots.push(normalized);
                const snapshotIndex = capturedSnapshots.length - 1;
                lastPeakTime = now;

                console.log(`Captured snapshot ${capturedSnapshots.length}/${SNAPSHOTS_NEEDED} for letter ${letter}`);

                const card = document.getElementById(`card-${letter}`);
                card.querySelector('.phoneme-status').textContent = `‚úì Captured ${capturedSnapshots.length}/${SNAPSHOTS_NEEDED}`;

                // Draw snapshot thumbnail
                drawSnapshotThumbnail(letter, snapshotIndex, normalized);

                // Visual feedback
                card.style.transform = 'scale(1.05)';
                setTimeout(() => card.style.transform = 'scale(1)', 200);

                // Check if done
                if (capturedSnapshots.length >= SNAPSHOTS_NEEDED) {
                    console.log(`All ${SNAPSHOTS_NEEDED} snapshots captured! Finishing calibration...`);
                    isRecording = false;
                    finishCalibration(letter);
                    return;
                }

                console.log(`Continuing to listen for more snapshots...`);
            }

            // Keep listening
            requestAnimationFrame(() => listenForPeaks(letter));
        }

        function drawSnapshotThumbnail(letter, index, snapshot) {
            const canvas = document.getElementById(`snapshot-${letter}-${index}`);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, width, height);

            // Draw spectrum bars
            const barWidth = width / snapshot.length;
            for (let i = 0; i < snapshot.length; i++) {
                const barHeight = snapshot[i] * height;
                const x = i * barWidth;
                const y = height - barHeight;

                // Green bars
                ctx.fillStyle = '#7CB342';
                ctx.fillRect(x, y, barWidth - 1, barHeight);
            }

            // Mark as captured
            canvas.classList.add('captured');
        }

        function downsampleFrequencies(fullData, targetBins) {
            // Reduce full frequency data to targetBins by averaging
            const pattern = [];
            const binSize = Math.floor(fullData.length / targetBins);

            for (let i = 0; i < targetBins; i++) {
                let sum = 0;
                const start = i * binSize;
                const end = Math.min(start + binSize, fullData.length);

                for (let j = start; j < end; j++) {
                    sum += fullData[j];
                }

                pattern.push(sum / binSize);
            }

            return pattern;
        }

        function finishCalibration(letter) {
            isRecording = false;

            // DISABLED: Audio recording takes too much localStorage space
            // if (mediaRecorder && mediaRecorder.state === 'recording') {
            //     mediaRecorder.stop();
            //     mediaRecorder.onstop = () => {
            //         const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            //         saveAudioRecording(letter, audioBlob);
            //     };
            // }

            if (capturedSnapshots.length < 3) {
                alert('Not enough snapshots captured. Try again.');
                const card = document.getElementById(`card-${letter}`);
                card.classList.remove('recording');
                card.querySelector('.phoneme-status').textContent = 'Click to record';
                recordingPhoneme = null;
                capturedSnapshots = [];
                audioChunks = [];
                return;
            }

            // CLUSTERING: Find the most similar snapshots
            const clusterResult = findBestCluster(capturedSnapshots);

            // AVERAGE the cluster to create baseline
            const baseline = averageSnapshots(clusterResult.cluster);

            // Store as "pattern" (but it's just 1 peak snapshot, wrapped in array for compatibility)
            calibrationData[letter] = {
                patterns: [baseline], // Array of positive examples
                negativePatterns: [], // Patterns to reject
                timestamp: Date.now()
            };

            // NOTE: This old calibration path is legacy - modal calibration saves to Supabase
            // No localStorage saving here

            const card = document.getElementById(`card-${letter}`);
            card.classList.remove('recording');
            card.classList.add('calibrated');
            card.querySelector('.phoneme-status').textContent = '‚úì Calibrated';

            updateCalibrationStats();

            recordingPhoneme = null;
            capturedSnapshots = [];

            console.log(`Calibrated ${letter}: Used ${clusterResult.cluster.length}/${capturedSnapshots.length} snapshots`);
        }

        function findBestCluster(snapshots) {
            // Find the group of most similar snapshots (remove outliers)
            // Returns { cluster: [...snapshots], indices: [...indices] }
            if (snapshots.length <= 3) {
                return {
                    cluster: snapshots,
                    indices: snapshots.map((_, i) => i)
                };
            }

            // Calculate pairwise distances
            const distances = [];
            for (let i = 0; i < snapshots.length; i++) {
                for (let j = i + 1; j < snapshots.length; j++) {
                    const dist = calculateSnapshotDistance(snapshots[i], snapshots[j]);
                    distances.push({ i, j, dist });
                }
            }

            // Sort by distance (most similar first)
            distances.sort((a, b) => a.dist - b.dist);

            // Find the 3 snapshots that are most similar to each other
            // Strategy: Start with the most similar pair, add the closest 3rd
            const pair = distances[0]; // Most similar pair
            const candidates = [pair.i, pair.j];

            // Find closest snapshot to this pair
            let bestThird = null;
            let bestAvgDist = Infinity;

            for (let k = 0; k < snapshots.length; k++) {
                if (candidates.includes(k)) continue;

                const dist1 = calculateSnapshotDistance(snapshots[k], snapshots[candidates[0]]);
                const dist2 = calculateSnapshotDistance(snapshots[k], snapshots[candidates[1]]);
                const avgDist = (dist1 + dist2) / 2;

                if (avgDist < bestAvgDist) {
                    bestAvgDist = avgDist;
                    bestThird = k;
                }
            }

            candidates.push(bestThird);
            return {
                cluster: candidates.map(i => snapshots[i]),
                indices: candidates
            };
        }

        function calculateSnapshotDistance(snap1, snap2) {
            // Simple distance: sum of absolute differences
            let sum = 0;
            const len = Math.min(snap1.length, snap2.length);
            for (let i = 0; i < len; i++) {
                sum += Math.abs(snap1[i] - snap2[i]);
            }
            return sum / len;
        }

        function averageSnapshots(snapshots) {
            // Average all snapshots bin-by-bin
            const numBins = snapshots[0].length;
            const averaged = new Array(numBins).fill(0);

            for (const snapshot of snapshots) {
                for (let i = 0; i < numBins; i++) {
                    averaged[i] += snapshot[i];
                }
            }

            return averaged.map(v => v / snapshots.length);
        }

        function normalizePattern(pattern2D) {
            // Normalize each time slice to 0-1 range
            return pattern2D.map(slice => {
                const max = Math.max(...slice);
                if (max === 0) return slice;
                return slice.map(v => v / max);
            });
        }

        function updateCalibrationStats() {
            const calibrated = Object.keys(calibrationData).length;
            const total = PHONEMES.length;
            const statsEl = document.getElementById('calibrationStats');
            statsEl.textContent = `Calibrated: ${calibrated} / ${total} phonemes`;

            if (calibrated === total) {
                statsEl.innerHTML += '<br><strong style="color: #7CB342;">‚úì All phonemes calibrated! Switch to Play tab.</strong>';
            }
        }

        function updateCalibrationUI() {
            PHONEMES.forEach(phoneme => {
                if (calibrationData[phoneme.letter]) {
                    const card = document.getElementById(`card-${phoneme.letter}`);
                    if (card) {
                        card.classList.add('calibrated');
                        card.querySelector('.phoneme-status').textContent = '‚úì Calibrated';
                    }
                }
            });
            updateCalibrationStats();
        }

        async function resetCalibration() {
            if (!confirm(`Reset all calibration data for ${currentProfile}?\n\nThis will delete all calibrations and audio recordings from the database. This cannot be undone.`)) {
                return;
            }

            try {
                console.log('üîÑ Starting calibration reset...');

                // Delete all calibrations from Supabase
                if (currentProfileId) {
                    const { error: deleteError } = await supabase
                        .from('calibrations')
                        .delete()
                        .eq('profile_id', currentProfileId);

                    if (deleteError) {
                        console.error('‚ùå Error deleting calibrations:', deleteError);
                        alert('Error deleting calibrations from database. Please try again.');
                        return;
                    }

                    console.log('‚úÖ Deleted calibrations from database');

                    // Note: We don't delete audio files from storage because they're expensive to regenerate
                    // and storage is cheap. They'll be orphaned but that's okay.

                    // Clear all calibration extras from localStorage (training patterns)
                    const keysToRemove = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith(`calibration_extras_${currentProfileId}_`)) {
                            keysToRemove.push(key);
                        }
                    }
                    keysToRemove.forEach(key => localStorage.removeItem(key));
                    console.log(`‚úÖ Cleared ${keysToRemove.length} training pattern entries from localStorage`);
                }

                // Clear local calibration data
                calibrationData = {};

                // Clear old localStorage key (legacy)
                const key = `phonicsPatterns_${currentProfile}`;
                localStorage.removeItem(key);

                // Refresh UI
                createCalibrationGrid();
                updateCalibrationStats();

                console.log('‚úÖ Calibration reset complete');
                alert('All calibrations have been reset successfully!');

            } catch (error) {
                console.error('‚ùå Error during reset:', error);
                alert('An error occurred while resetting calibrations. Please check the console for details.');
            }
        }

        function exportCalibration() {
            const dataStr = JSON.stringify(calibrationData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `phonics-patterns-${currentProfile}.json`;
            a.click();
        }

        // ========== CALIBRATION MODAL ==========

        let modalAnimationFrame = null;
        let modalWaveformCanvas = null;
        let modalWaveformCtx = null;
        let modalCurrentLetter = '';
        let modalCapturedSnapshots = [];
        let modalIsListening = false;
        let modalListeningForIndex = -1;
        let modalMediaRecorder = null;
        let modalAudioChunks = [];
        let modalAudioClips = []; // Individual audio clips per snapshot
        let modalCurrentRecordingIndex = -1;

        function openCalibrationModal(letter) {
            modalCurrentLetter = letter;
            modalCapturedSnapshots = [];
            modalAudioClips = []; // Reset audio clips array
            modalIsListening = false;
            modalListeningForIndex = -1;
            modalCurrentRecordingIndex = -1;

            // Set up modal UI
            document.getElementById('modalLetter').textContent = letter;
            document.getElementById('modalStatus').textContent = `Click box 1 to record first sound`;

            // Hide next button
            document.getElementById('modalNextButton').classList.remove('active');

            // Reset and setup capture boxes as CLICKABLE
            for (let i = 0; i < 5; i++) {
                const box = document.getElementById(`modalCaptureBox${i}`);
                box.classList.remove('captured', 'recording', 'ready');
                const canvas = document.getElementById(`modalCaptureCanvas${i}`);
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Make boxes clickable
                box.onclick = () => startCaptureForBox(i);

                // Mark first box as ready
                if (i === 0) {
                    box.classList.add('ready');
                    box.style.cursor = 'pointer';
                } else {
                    box.style.cursor = 'not-allowed';
                }
            }

            // Show the click arrow pointing at box 1
            document.getElementById('clickArrow').classList.add('active');

            // Setup audio if needed (no session-long recording, we'll record per snapshot)
            if (!audioContext) {
                setupAudio().then(() => {
                    document.getElementById('calibrationModal').classList.add('active');
                    startModalVisualization();
                });
            } else {
                document.getElementById('calibrationModal').classList.add('active');
                startModalVisualization();
            }
        }

        function closeCalibrationModal() {
            modalIsListening = false;
            if (modalAnimationFrame) {
                cancelAnimationFrame(modalAnimationFrame);
                modalAnimationFrame = null;
            }
            // Stop audio recording if still active
            if (modalMediaRecorder && modalMediaRecorder.state === 'recording') {
                modalMediaRecorder.stop();
            }
            document.getElementById('clickArrow').classList.remove('active');
            document.getElementById('modalNextButton').classList.remove('active');
            document.getElementById('calibrationModal').classList.remove('active');
        }

        function playModalLetterSound() {
            playPhonemeSound(modalCurrentLetter);
        }

        function startCaptureForBox(index) {
            // Only allow capturing the next uncaptured box
            if (index !== modalCapturedSnapshots.length) {
                return;
            }

            // Already listening
            if (modalIsListening) return;

            // Hide the arrow once user starts interacting
            document.getElementById('clickArrow').classList.remove('active');

            // DON'T start listening yet - wait for delay first!
            modalListeningForIndex = index;
            modalCurrentRecordingIndex = index;

            const box = document.getElementById(`modalCaptureBox${index}`);
            box.classList.remove('ready');
            box.classList.add('recording');
            box.style.cursor = 'wait';

            document.getElementById('modalStatus').textContent = `Recording ${index + 1}/5... Get ready...`;

            // Wait 400ms to avoid click sound, THEN start listening AND recording
            setTimeout(() => {
                modalIsListening = true; // NOW we start listening!
                document.getElementById('modalStatus').textContent = `Recording ${index + 1}/5... Say "${modalCurrentLetter}" NOW!`;

                // Start individual audio recording for this snapshot
                modalAudioChunks = [];
                if (microphone && microphone.stream) {
                    modalMediaRecorder = new MediaRecorder(microphone.stream);
                    modalMediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            modalAudioChunks.push(event.data);
                        }
                    };
                    modalMediaRecorder.start();
                    console.log(`üéôÔ∏è Started recording clip ${index + 1}/5`);
                }
            }, 400);
        }

        function startModalVisualization() {
            let lastPeakTime = 0;
            const PEAK_COOLDOWN = 500;

            function visualize() {
                if (!document.getElementById('calibrationModal').classList.contains('active')) {
                    return;
                }

                modalAnimationFrame = requestAnimationFrame(visualize);

                if (!analyser || !dataArray) return;

                analyser.getByteFrequencyData(dataArray);

                // Draw waveform in modal
                drawModalWaveform();

                // Listen for peak if actively recording
                if (modalIsListening && modalListeningForIndex >= 0) {
                    // Calculate current volume
                    let sum = 0;
                    for (let i = 0; i < dataArray.length; i++) {
                        sum += dataArray[i];
                    }
                    const volume = (sum / dataArray.length / 128) * 100;

                    const volumeThreshold = isNasal(modalCurrentLetter) ? 4 : 15;

                    // Detect peak (after 400ms delay)
                    const now = Date.now();
                    if (volume > volumeThreshold && (now - lastPeakTime) > PEAK_COOLDOWN) {
                        // Capture snapshot
                        let snapshot = downsampleFrequencies(dataArray, PATTERN_BINS);

                        // Check energy concentration
                        const peakEnergy = Math.max(...snapshot);
                        const avgEnergy = snapshot.reduce((a, b) => a + b, 0) / snapshot.length;
                        const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;
                        const concentrationThreshold = isNasal(modalCurrentLetter) ? 1.5 : 2.0;

                        if (energyConcentration < concentrationThreshold) {
                            return; // Skip weak peaks
                        }

                        // Pre-amplify nasals
                        if (isNasal(modalCurrentLetter)) {
                            snapshot = snapshot.map(v => v * 2.0);
                        }

                        // Normalize
                        const maxVal = Math.max(...snapshot);
                        const normalized = snapshot.map(v => v / maxVal);

                        // Capture!
                        modalCapturedSnapshots.push(normalized);
                        lastPeakTime = now;

                        console.log(`üì∏ Captured snapshot ${modalCapturedSnapshots.length}/5`);

                        // Draw in box
                        drawSnapshotInModalBox(modalListeningForIndex, normalized);

                        // Mark box as captured
                        const box = document.getElementById(`modalCaptureBox${modalListeningForIndex}`);
                        box.classList.remove('recording');
                        box.classList.add('captured');
                        box.style.cursor = 'default';

                        // Stop listening (but keep recording for full sound)
                        modalIsListening = false;
                        modalListeningForIndex = -1;

                        // Continue recording for 700ms after peak to capture the full sound
                        setTimeout(() => {
                            if (modalMediaRecorder && modalMediaRecorder.state === 'recording') {
                                modalMediaRecorder.stop();
                                modalMediaRecorder.addEventListener('stop', () => {
                                    const audioBlob = new Blob(modalAudioChunks, { type: 'audio/webm' });
                                    modalAudioClips.push(audioBlob);
                                    const sizeKB = (audioBlob.size / 1024).toFixed(2);
                                    console.log(`üéôÔ∏è Saved audio clip ${modalAudioClips.length}/5 (${sizeKB} KB)`);
                                }, { once: true });
                            }
                        }, 700); // Continue recording for 700ms after peak detected

                        // Update status and enable next box
                        if (modalCapturedSnapshots.length < 5) {
                            const nextBox = document.getElementById(`modalCaptureBox${modalCapturedSnapshots.length}`);
                            nextBox.classList.add('ready');
                            nextBox.style.cursor = 'pointer';
                            document.getElementById('modalStatus').textContent = `‚úì Captured ${modalCapturedSnapshots.length}/5. Click box ${modalCapturedSnapshots.length + 1}`;
                        } else {
                            // All done!
                            document.getElementById('modalStatus').textContent = `‚úì All 5 captured! Saving...`;
                            setTimeout(() => {
                                finishModalCalibration();
                            }, 500);
                        }
                    }
                }
            }
            visualize();
        }

        function drawModalWaveform() {
            if (!modalWaveformCtx || !dataArray) return;

            const width = modalWaveformCanvas.width;
            const height = modalWaveformCanvas.height;

            // Clear with fade
            modalWaveformCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            modalWaveformCtx.fillRect(0, 0, width, height);

            // Draw frequency bars
            const barWidth = width / dataArray.length * 2.5;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * height;
                const hue = (i / dataArray.length) * 120 + 100;
                modalWaveformCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                modalWaveformCtx.fillRect(x, height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        function drawSnapshotInModalBox(index, snapshot) {
            const canvas = document.getElementById(`modalCaptureCanvas${index}`);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const barWidth = canvas.width / snapshot.length;
            for (let j = 0; j < snapshot.length; j++) {
                const barHeight = snapshot[j] * canvas.height;
                const x = j * barWidth;
                const y = canvas.height - barHeight;

                ctx.fillStyle = '#7CB342';
                ctx.fillRect(x, y, barWidth - 1, barHeight);
            }
        }

        async function finishModalCalibration() {
            console.log('Finishing modal calibration...');

            // Use the SAME logic as the original finishCalibration
            const clusterResult = findBestCluster(modalCapturedSnapshots);
            const baseline = averageSnapshots(clusterResult.cluster);

            // Save in the NEW snapshot format with scoring
            const patternData = {
                snapshots: [{
                    data: baseline,
                    score: 0,
                    isNegative: false,
                    profileId: currentProfileId,
                    createdAt: new Date().toISOString()
                }]
            };

            // Select the best audio clip from the cluster
            // Strategy: Use the FIRST clip from the cluster (usually the most representative)
            let bestAudioBlob = null;
            if (modalAudioClips.length > 0 && clusterResult.indices.length > 0) {
                const bestIndex = clusterResult.indices[0]; // First snapshot in best cluster
                if (bestIndex < modalAudioClips.length) {
                    bestAudioBlob = modalAudioClips[bestIndex];
                    const sizeKB = (bestAudioBlob.size / 1024).toFixed(2);
                    console.log(`üéØ Selected best audio clip: snapshot ${bestIndex + 1} (${sizeKB} KB)`);
                }
            }

            // Save to Supabase (with ONLY the best audio clip)
            const audioUrl = await saveCalibrationToSupabase(modalCurrentLetter, patternData, bestAudioBlob);

            // Update local calibrationData with audioUrl for immediate playback
            calibrationData[modalCurrentLetter] = {
                ...patternData,
                audioUrl: audioUrl
            };

            // Update UI
            updateCalibrationUI();

            console.log(`‚úÖ Calibrated ${modalCurrentLetter}: Used ${clusterResult.cluster.length}/${modalCapturedSnapshots.length} snapshots`);

            document.getElementById('modalStatus').innerHTML = '<strong style="color: #7CB342;">üéâ Calibrated!</strong>';

            // Show next button
            document.getElementById('modalNextButton').classList.add('active');
        }

        function goToNextLetter() {
            // Find current letter index in PHONEMES
            const currentIndex = PHONEMES.findIndex(p => p.letter === modalCurrentLetter);

            // Look for next uncalibrated letter
            for (let i = currentIndex + 1; i < PHONEMES.length; i++) {
                const nextLetter = PHONEMES[i].letter;
                if (!calibrationData[nextLetter]) {
                    // Found next uncalibrated letter
                    closeCalibrationModal();
                    setTimeout(() => {
                        openCalibrationModal(nextLetter);
                    }, 300);
                    return;
                }
            }

            // If no uncalibrated letters after current, check from beginning
            for (let i = 0; i < currentIndex; i++) {
                const nextLetter = PHONEMES[i].letter;
                if (!calibrationData[nextLetter]) {
                    closeCalibrationModal();
                    setTimeout(() => {
                        openCalibrationModal(nextLetter);
                    }, 300);
                    return;
                }
            }

            // All letters calibrated!
            closeCalibrationModal();
        }

        // Elimination game mode
        let patternBuffer = [];
        let currentTarget = null;
        let lastRecordedSnapshot = null; // Store snapshot for training buttons
        let lastPrediction = null; // Store last prediction for training buttons

        function pickRandomLetter() {
            // Only pick from letters that are BOTH calibrated AND in current PHONEMES list
            const allowedLetters = PHONEMES.map(p => p.letter);
            const calibratedLetters = Object.keys(calibrationData).filter(letter =>
                allowedLetters.includes(letter)
            );
            if (calibratedLetters.length === 0) return null;
            return calibratedLetters[Math.floor(Math.random() * calibratedLetters.length)];
        }

        function skipLetter() {
            if (isRunning) {
                setNextTarget();
            }
        }

        function tryAgain() {
            // Reset and start listening again for same letter
            document.getElementById('tryAgainBtn').style.display = 'none';
            document.getElementById('tunerBtn').textContent = '‚è∏ Stop Game';
            patternBuffer = [];
            hideTrainingButtons(); // Hide training buttons when starting new attempt
            isRunning = true;
            analyzeTuner();
        }

        // Training correction functions
        function saveCalibrationExtras(letter) {
            if (!currentProfileId) {
                console.error('No profile selected');
                return;
            }

            const localKey = `calibration_extras_${currentProfileId}_${letter}`;
            const calibration = calibrationData[letter];

            // Filter out the original pattern from Supabase (index 0)
            const addedPatterns = calibration.patterns.slice(1);
            const negativePatterns = calibration.negativePatterns || [];

            // Only save if there are additions
            if (addedPatterns.length > 0 || negativePatterns.length > 0) {
                const extras = {
                    patterns: addedPatterns,
                    negativePatterns: negativePatterns
                };
                localStorage.setItem(localKey, JSON.stringify(extras));
                console.log(`üíæ Saved ${addedPatterns.length} positive + ${negativePatterns.length} negative patterns for ${letter}`);
            }
        }

        function addPositivePattern(letter) {
            if (!lastRecordedSnapshot || !calibrationData[letter]) {
                console.error('Cannot add positive pattern: no snapshot or no calibration');
                return;
            }

            // Add snapshot in NEW format
            const newSnapshot = {
                data: lastRecordedSnapshot,
                score: 0,
                isNegative: false,
                profileId: currentProfileId,
                createdAt: new Date().toISOString()
            };

            if (!calibrationData[letter].snapshots) {
                calibrationData[letter].snapshots = [];
            }
            calibrationData[letter].snapshots.push(newSnapshot);

            // Save to Supabase
            debounceSaveScores(letter, currentProfileId);

            // Update visualization
            visualizeStoredPattern(letter);

            // Show feedback
            const feedback = document.getElementById('trainingFeedback');
            const positiveCount = calibrationData[letter].snapshots.filter(s => !s.isNegative).length;
            feedback.textContent = `‚úì Added positive example for '${letter}' (${positiveCount} total)`;
            feedback.style.color = '#4CAF50';

            // Hide training buttons after action
            hideTrainingButtons();

            console.log(`‚úì Added positive pattern to ${letter}:`, lastRecordedSnapshot);
        }

        function addNegativePattern(letter) {
            if (!lastRecordedSnapshot || !calibrationData[letter]) {
                console.error('Cannot add negative pattern: no snapshot or no calibration');
                return;
            }

            // Add snapshot in NEW format
            const newSnapshot = {
                data: lastRecordedSnapshot,
                score: 0,
                isNegative: true,
                profileId: currentProfileId,
                createdAt: new Date().toISOString()
            };

            if (!calibrationData[letter].snapshots) {
                calibrationData[letter].snapshots = [];
            }
            calibrationData[letter].snapshots.push(newSnapshot);

            const negativeCount = calibrationData[letter].snapshots.filter(s => s.isNegative).length;
            console.log(`‚úó Added negative pattern to ${letter} (total: ${negativeCount})`);
            console.log(`  Pattern preview:`, lastRecordedSnapshot.slice(0, 5));

            // Save to Supabase
            debounceSaveScores(letter, currentProfileId);

            // Update visualization
            console.log(`  Calling visualizeStoredPattern for ${letter}...`);
            visualizeStoredPattern(letter);

            // Show feedback
            const feedback = document.getElementById('trainingFeedback');
            feedback.textContent = `‚úì Added negative example for '${letter}' (${negativeCount} total)`;
            feedback.style.color = '#f44336';

            // Hide training buttons after action
            hideTrainingButtons();
        }

        let trainingButtonTimeout = null;

        function showSuccessTrainingButton(prediction, targetLetter) {
            // Show only RED button after successful match (to correct false positives)
            // Hide all buttons first
            document.getElementById('addPositiveBtn').style.display = 'none';
            document.getElementById('addNegativeBtn').style.display = 'none';
            document.getElementById('addCorrectBtn').style.display = 'none';

            // Clear previous feedback
            document.getElementById('trainingFeedback').textContent = '';

            // Show only "Not 'X'" button (where X is the letter that was detected/matched)
            document.getElementById('negativeTarget').textContent = prediction;
            document.getElementById('addNegativeBtn').style.display = 'inline-block';

            // Show the container
            document.getElementById('trainingButtons').style.display = 'block';

            // Auto-hide after 5 seconds
            if (trainingButtonTimeout) clearTimeout(trainingButtonTimeout);
            trainingButtonTimeout = setTimeout(() => {
                hideTrainingButtons();
            }, 5000);
        }

        function showTrainingButtons(prediction, targetLetter) {
            // Clear any pending auto-hide timeout
            if (trainingButtonTimeout) {
                clearTimeout(trainingButtonTimeout);
                trainingButtonTimeout = null;
            }

            // Hide all buttons first
            document.getElementById('addPositiveBtn').style.display = 'none';
            document.getElementById('addNegativeBtn').style.display = 'none';
            document.getElementById('addCorrectBtn').style.display = 'none';

            // Clear previous feedback
            document.getElementById('trainingFeedback').textContent = '';

            // Scenario 1: Wrong prediction (predicted X but wanted Y)
            if (prediction !== targetLetter) {
                // Show "Not 'X'" button (add to negative patterns of predicted letter)
                document.getElementById('negativeTarget').textContent = prediction;
                document.getElementById('addNegativeBtn').style.display = 'inline-block';

                // Show "Was 'Y'" button (add to positive patterns of target letter)
                document.getElementById('correctTarget').textContent = targetLetter;
                document.getElementById('addCorrectBtn').style.display = 'inline-block';
            }
            // Scenario 2: Correct prediction but low score
            else {
                // Show "Add to 'X'" button (add to positive patterns to improve recognition)
                document.getElementById('positiveTarget').textContent = targetLetter;
                document.getElementById('addPositiveBtn').style.display = 'inline-block';
            }

            // Show the container
            document.getElementById('trainingButtons').style.display = 'block';
        }

        function hideTrainingButtons() {
            document.getElementById('trainingButtons').style.display = 'none';
            if (trainingButtonTimeout) {
                clearTimeout(trainingButtonTimeout);
                trainingButtonTimeout = null;
            }
        }

        // Initialize button handlers
        function initTrainingButtons() {
            document.getElementById('addPositiveBtn').onclick = () => {
                addPositivePattern(currentTarget);
            };

            document.getElementById('addNegativeBtn').onclick = () => {
                if (lastPrediction) {
                    addNegativePattern(lastPrediction);
                }
            };

            document.getElementById('addCorrectBtn').onclick = () => {
                addPositivePattern(currentTarget);
            };
        }

        // Sensitivity modal functions
        function openSensitivityModal() {
            if (!currentTarget) return;

            const modal = document.getElementById('sensitivityModal');
            const letterDisplay = document.getElementById('sensitivityLetter');
            const slider = document.getElementById('sensitivitySlider');

            // Get current sensitivity for this letter
            const currentSensitivity = calibrationData[currentTarget]?.sensitivity || 85;

            letterDisplay.textContent = currentTarget;
            slider.value = currentSensitivity;
            updateSensitivityDisplay(currentSensitivity);

            modal.style.display = 'flex';
        }

        function closeSensitivityModal() {
            document.getElementById('sensitivityModal').style.display = 'none';
        }

        function updateSensitivityDisplay(value) {
            document.getElementById('sensitivityValue').textContent = value + '%';
        }

        async function saveSensitivity() {
            if (!currentTarget) {
                console.error('No current target');
                return;
            }

            const slider = document.getElementById('sensitivitySlider');
            const newSensitivity = parseInt(slider.value);

            // Update local calibration data
            if (calibrationData[currentTarget]) {
                const calibrationId = calibrationData[currentTarget].id;

                if (!calibrationId) {
                    console.error('No calibration ID found for letter:', currentTarget);
                    alert('Failed to save sensitivity - calibration not found');
                    return;
                }

                calibrationData[currentTarget].sensitivity = newSensitivity;

                // Update in Supabase using the calibration ID
                try {
                    console.log(`Updating sensitivity for ${currentTarget} (ID: ${calibrationId}) to ${newSensitivity}%`);

                    const { data, error } = await supabase
                        .from('calibrations')
                        .update({ sensitivity: newSensitivity })
                        .eq('id', calibrationId)
                        .select();

                    if (error) {
                        console.error('Supabase error:', error);
                        alert(`Failed to save sensitivity: ${error.message}`);
                        return;
                    }

                    console.log(`‚úÖ Updated sensitivity for ${currentTarget} to ${newSensitivity}%`, data);
                    closeSensitivityModal();
                } catch (err) {
                    console.error('Unexpected error:', err);
                    alert(`Failed to save sensitivity: ${err.message}`);
                }
            } else {
                console.error('Letter not calibrated:', currentTarget);
                alert('Letter not calibrated yet');
            }
        }

        // Manual Recording Modal Functions
        let manualRecordBuffer = [];
        let manualRecordSnapshot = null;
        let manualRecordCanvas = null;
        let manualRecordCtx = null;
        let isManualRecording = false;

        function openManualRecordModal() {
            if (!currentTarget) {
                alert('Please start the game first to select a letter');
                return;
            }

            const modal = document.getElementById('manualRecordModal');
            const letterDisplay = document.getElementById('manualRecordLetter');

            letterDisplay.textContent = currentTarget;
            modal.style.display = 'flex';

            // Initialize canvas
            manualRecordCanvas = document.getElementById('manualRecordCanvas');
            manualRecordCtx = manualRecordCanvas.getContext('2d');
            manualRecordCanvas.width = manualRecordCanvas.offsetWidth || 400;
            manualRecordCanvas.height = 80;

            // Clear canvas
            manualRecordCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            manualRecordCtx.fillRect(0, 0, manualRecordCanvas.width, manualRecordCanvas.height);

            // Reset state
            manualRecordBuffer = [];
            manualRecordSnapshot = null;
            document.getElementById('manualRecordStatus').textContent = 'Ready to record';
            document.getElementById('manualRecordStartBtn').style.display = 'inline-block';
            document.getElementById('manualRecordRedoBtn').style.display = 'none';
            document.getElementById('manualRecordAcceptBtn').style.display = 'none';
        }

        function closeManualRecordModal() {
            const modal = document.getElementById('manualRecordModal');
            modal.style.display = 'none';
            isManualRecording = false;
            manualRecordBuffer = [];
            manualRecordSnapshot = null;
        }

        function startManualRecord() {
            // Start listening for audio
            isManualRecording = true;
            manualRecordBuffer = [];
            document.getElementById('manualRecordStatus').textContent = 'üé§ Recording... (say the sound now)';
            document.getElementById('manualRecordStartBtn').style.display = 'none';

            // Capture for 2 seconds
            const captureFrames = [];
            const captureInterval = setInterval(() => {
                if (!isManualRecording) {
                    clearInterval(captureInterval);
                    return;
                }

                // Get current frequency data
                analyser.getByteFrequencyData(dataArray);
                const pattern = downsampleFrequencies(dataArray, PATTERN_BINS);
                captureFrames.push(pattern);
            }, 33); // ~30fps

            setTimeout(() => {
                clearInterval(captureInterval);
                if (!isManualRecording) return;

                isManualRecording = false;

                if (captureFrames.length === 0) {
                    document.getElementById('manualRecordStatus').textContent = '‚ùå No sound detected, try again';
                    document.getElementById('manualRecordStartBtn').style.display = 'inline-block';
                    return;
                }

                // Find peak moment
                const energies = captureFrames.map(frame => frame.reduce((a, b) => a + b, 0));
                const peakIdx = energies.indexOf(Math.max(...energies));
                let snapshot = captureFrames[peakIdx];

                // Normalize to 0-1 range
                const maxVal = Math.max(...snapshot);
                if (maxVal > 0) {
                    snapshot = snapshot.map(v => v / maxVal);
                }

                manualRecordSnapshot = snapshot;

                // Visualize the captured snapshot
                drawDownsampledPattern(manualRecordCtx, manualRecordCanvas, snapshot);

                document.getElementById('manualRecordStatus').textContent = '‚úì Captured! Accept or redo?';
                document.getElementById('manualRecordRedoBtn').style.display = 'inline-block';
                document.getElementById('manualRecordAcceptBtn').style.display = 'inline-block';

                console.log('‚úì Manual snapshot captured:', snapshot);
            }, 2000);
        }

        function redoManualRecord() {
            // Reset and allow re-recording
            manualRecordSnapshot = null;
            document.getElementById('manualRecordStatus').textContent = 'Ready to record';
            document.getElementById('manualRecordStartBtn').style.display = 'inline-block';
            document.getElementById('manualRecordRedoBtn').style.display = 'none';
            document.getElementById('manualRecordAcceptBtn').style.display = 'none';

            // Clear canvas
            manualRecordCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            manualRecordCtx.fillRect(0, 0, manualRecordCanvas.width, manualRecordCanvas.height);
        }

        function acceptManualRecord() {
            if (!manualRecordSnapshot || !currentTarget) {
                console.error('No snapshot or no target letter');
                return;
            }

            // Add to positive patterns
            if (!calibrationData[currentTarget]) {
                alert('Letter not calibrated yet. Please calibrate first.');
                closeManualRecordModal();
                return;
            }

            calibrationData[currentTarget].patterns.push(manualRecordSnapshot);

            // Save to localStorage
            saveCalibrationExtras(currentTarget);

            // Update visualization
            visualizeStoredPattern(currentTarget);

            console.log(`‚úì Added manual recording to ${currentTarget}. Total patterns: ${calibrationData[currentTarget].patterns.length}`);

            // Close modal with success message
            document.getElementById('manualRecordStatus').textContent = '‚úÖ Example added successfully!';
            setTimeout(() => {
                closeManualRecordModal();
            }, 1500);
        }

        // Continuous play mode
        let continuousPlayEnabled = localStorage.getItem('continuousPlayMode') === 'true';

        function toggleContinuousPlay() {
            const checkbox = document.getElementById('continuousPlayMode');
            continuousPlayEnabled = checkbox.checked;
            localStorage.setItem('continuousPlayMode', continuousPlayEnabled);
            console.log('Continuous play:', continuousPlayEnabled ? 'ON' : 'OFF');
            updateToggleUI();
        }

        function updateToggleUI() {
            const slider = document.getElementById('toggleSlider');
            const bg = document.getElementById('toggleBg');
            if (slider && bg) {
                if (continuousPlayEnabled) {
                    slider.style.transform = 'translateX(20px)';
                    bg.style.background = '#7CB342';
                } else {
                    slider.style.transform = 'translateX(0)';
                    bg.style.background = 'rgba(255,255,255,0.2)';
                }
            }
        }

        // Initialize checkbox state on page load
        setTimeout(() => {
            const checkbox = document.getElementById('continuousPlayMode');
            if (checkbox) {
                checkbox.checked = continuousPlayEnabled;
                updateToggleUI();
            }
        }, 100);

        async function setNextTarget() {
            // Use adaptive selection if session is active, otherwise use random
            if (currentSession) {
                currentTarget = await selectNextLetter();
            } else {
                currentTarget = pickRandomLetter();
            }

            if (currentTarget) {
                document.getElementById('targetLetter').textContent = currentTarget;
                document.getElementById('status').textContent = `Say: ${currentTarget}`;
                document.getElementById('tryAgainBtn').style.display = 'none';
                patternBuffer = [];
                listenClickedThisRound = false; // Reset LISTEN tracking for this letter
                hideTrainingButtons(); // Hide training buttons when starting new letter

                // SCORING: Start new scoring round for negative snapshot tracking
                startNewScoringRound(currentTarget);

                // Visualize stored calibration pattern
                visualizeStoredPattern(currentTarget);
            }

            // Update progress tracker
            updateLetterProgressTracker();
        }

        let listenClickedThisRound = false; // Track if LISTEN was clicked for current letter
        let isMuted = false; // Track microphone mute state

        function toggleMute() {
            const btn = document.getElementById('muteBtn');
            isMuted = !isMuted;

            if (isMuted) {
                btn.textContent = 'üîá Unmute';
                btn.style.background = '#f44336'; // Red when muted
                document.getElementById('status').textContent = 'üîá Microphone muted - Click Unmute to continue';
                console.log('üîá Microphone muted');
            } else {
                btn.textContent = 'üé§ Mute';
                btn.style.background = '#666'; // Gray when active
                document.getElementById('status').textContent = 'Microphone active';
                console.log('üé§ Microphone unmuted');
            }
        }

        async function toggleTuner() {
            const btn = document.getElementById('tunerBtn');

            // If button says "Next Letter", just advance to next
            if (btn.textContent === '‚ñ∂ Next Letter') {
                btn.textContent = '‚è∏ Stop Game';
                isRunning = true;
                await setNextTarget(); // Changed to await since it's now async
                analyzeTuner();
                return;
            }

            if (isRunning) {
                isRunning = false;
                btn.textContent = '‚ñ∂ Start Game';
                document.getElementById('status').textContent = 'Stopped';
                document.getElementById('targetLetter').textContent = '?';
                document.getElementById('sensitivityBtn').style.display = 'none'; // Hide settings button
                document.getElementById('thresholdMeter').style.display = 'none'; // Hide threshold meter
                document.getElementById('muteBtn').style.display = 'none'; // Hide mute button
                isMuted = false; // Reset mute state
            } else {
                if (Object.keys(calibrationData).length === 0) {
                    alert('Please calibrate at least one phoneme first!');
                    return;
                }
                if (!audioContext) {
                    await setupAudio();
                }

                // Initialize adaptive learning session
                if (currentProfileId) {
                    initializeSession(currentProfileId);
                    console.log('‚ñ∂ Play started with adaptive learning');
                }

                isRunning = true;
                btn.textContent = '‚è∏ Stop Game';
                await setNextTarget(); // Changed to await since it's now async
                updateLetterProgressTracker();
                document.getElementById('sensitivityBtn').style.display = 'inline-block'; // Show settings button
                document.getElementById('thresholdMeter').style.display = 'block'; // Show threshold meter
                document.getElementById('muteBtn').style.display = 'inline-block'; // Show mute button
                document.getElementById('muteBtn').textContent = 'üé§ Mute'; // Reset button text
                document.getElementById('muteBtn').style.background = '#666'; // Reset button color
                analyzeTuner();
            }
        }

        let analyzerRunning = false;
        let analyzerHeartbeat = 0;

        function updateThresholdMeter(volume, volumeThreshold, concentration, concentrationThreshold) {
            // Update volume meter
            const volumeMeterValue = document.getElementById('volumeMeterValue');
            const volumeMeterThreshold = document.getElementById('volumeMeterThreshold');
            const volumeMeterFill = document.getElementById('volumeMeterFill');
            const volumeThresholdMarker = document.getElementById('volumeThresholdMarker');

            if (volumeMeterValue && volumeMeterFill) {
                volumeMeterValue.textContent = Math.round(volume);
                volumeMeterThreshold.textContent = volumeThreshold;

                // Calculate fill percentage (max out at 1000% of threshold for visualization)
                const maxVolume = volumeThreshold * 10;
                const volumePercent = Math.min(100, (volume / maxVolume) * 100);
                volumeMeterFill.style.width = volumePercent + '%';

                // Color coding: red below, yellow near, green above threshold
                if (volume >= volumeThreshold) {
                    volumeMeterFill.style.background = '#4CAF50'; // Green
                } else if (volume >= volumeThreshold * 0.8) {
                    volumeMeterFill.style.background = '#FDD835'; // Yellow
                } else {
                    volumeMeterFill.style.background = '#f44336'; // Red
                }

                // Position threshold marker
                const thresholdPercent = (volumeThreshold / maxVolume) * 100;
                volumeThresholdMarker.style.left = thresholdPercent + '%';
            }

            // Update energy concentration meter
            const concentrationMeterValue = document.getElementById('concentrationMeterValue');
            const concentrationMeterThreshold = document.getElementById('concentrationMeterThreshold');
            const concentrationMeterFill = document.getElementById('concentrationMeterFill');
            const concentrationThresholdMarker = document.getElementById('concentrationThresholdMarker');

            if (concentrationMeterValue && concentrationMeterFill) {
                concentrationMeterValue.textContent = concentration.toFixed(1);
                concentrationMeterThreshold.textContent = concentrationThreshold.toFixed(1);

                // Calculate fill percentage (max out at 1000% of threshold for visualization)
                const maxConcentration = concentrationThreshold * 10;
                const concentrationPercent = Math.min(100, (concentration / maxConcentration) * 100);
                concentrationMeterFill.style.width = concentrationPercent + '%';

                // Color coding: red below, yellow near, green above threshold
                if (concentration >= concentrationThreshold) {
                    concentrationMeterFill.style.background = '#4CAF50'; // Green
                } else if (concentration >= concentrationThreshold * 0.8) {
                    concentrationMeterFill.style.background = '#FDD835'; // Yellow
                } else {
                    concentrationMeterFill.style.background = '#f44336'; // Red
                }

                // Position threshold marker
                const thresholdPercent = (concentrationThreshold / maxConcentration) * 100;
                concentrationThresholdMarker.style.left = thresholdPercent + '%';
            }
        }

        function analyzeTuner() {
            if (!isRunning) {
                if (analyzerRunning) {
                    console.log('‚è∏ Analyzer stopped - isRunning is false');
                    analyzerRunning = false;
                    analyzerHeartbeat = 0;
                }
                return;
            }

            if (!analyzerRunning) {
                console.log('‚ñ∂ Analyzer started - listening to microphone');
                analyzerRunning = true;
                analyzerHeartbeat = 0;
            }

            // Heartbeat: Log state every 180 frames (~3 seconds at 60fps)
            analyzerHeartbeat++;
            if (analyzerHeartbeat % 180 === 0) {
                console.log(`üíì Analyzer active: target=${currentTarget}, isRunning=${isRunning}`);
            }

            requestAnimationFrame(analyzeTuner);

            analyser.getByteFrequencyData(dataArray);

            // Draw spectrum
            drawSpectrum();

            // Calculate volume
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volume = (sum / dataArray.length / 128) * 100;
            document.getElementById('volume').textContent = Math.round(volume) + '%';

            // ALWAYS add current frame to buffer (sliding window)
            const pattern = downsampleFrequencies(dataArray, PATTERN_BINS);
            patternBuffer.push(pattern);

            // Keep buffer at PATTERN_LENGTH
            if (patternBuffer.length > PATTERN_LENGTH) {
                patternBuffer.shift();
            }

            // DEBUG: Show buffer status only when NOT ready
            if (currentTarget && patternBuffer.length < PATTERN_LENGTH) {
                document.getElementById('status').textContent = `Buffer: ${patternBuffer.length}/${PATTERN_LENGTH} frames (keep talking...)`;
            }

            // Check energy concentration (speech vs background noise)
            const peakEnergy = Math.max(...pattern);
            const avgEnergy = pattern.reduce((a, b) => a + b, 0) / pattern.length;
            const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;

            // Skip detection if playing back a recording
            if (isPlayingRecording) {
                return;
            }

            // Skip detection if microphone is muted
            if (isMuted) {
                return;
            }

            // Dynamic thresholds: volume stays constant, only concentration adjusts per letter type
            const FRICATIVES = ['f', 's', 'v', 'z', 'h'];
            const LIQUIDS = ['l', 'r'];
            const isCurrentNasal = currentTarget && isNasal(currentTarget);
            const isFricative = currentTarget && FRICATIVES.includes(currentTarget);
            const isLiquid = currentTarget && LIQUIDS.includes(currentTarget);

            const volumeThreshold = 15; // Standard volume threshold for all letters
            let concentrationThreshold = 2.0;

            if (isCurrentNasal || isLiquid) {
                concentrationThreshold = 1.5; // Lower concentration for nasals/liquids (m, n, l, r)
            } else if (isFricative) {
                concentrationThreshold = 1.8; // Lower concentration for fricatives (f, s, v, z, h)
            }

            // Update threshold meter in real-time
            updateThresholdMeter(volume, volumeThreshold, energyConcentration, concentrationThreshold);

            // Try to match against TARGET letter only
            // Debug: Log when detection conditions aren't met
            if (currentTarget && patternBuffer.length === PATTERN_LENGTH && volume > 5) {
                // Only log if there's some volume (avoid spam from silence)
                if (!(volume > volumeThreshold && energyConcentration > concentrationThreshold)) {
                    console.log(`‚ö†Ô∏è Sound detected but thresholds not met: vol=${volume.toFixed(1)} (need ${volumeThreshold}), concentration=${energyConcentration.toFixed(1)} (need ${concentrationThreshold})`);
                }
            }

            if (patternBuffer.length === PATTERN_LENGTH && volume > volumeThreshold && energyConcentration > concentrationThreshold && currentTarget) {

                // S11-Snapshot detection for ALL letters
                const results = testAllPlosiveStrategies(patternBuffer, currentTarget);

                const result = results[0]; // Only S11-Snapshot now
                const score = Math.max(0, Math.min(100, result.score || 0));
                const targetScore = Math.max(0, Math.min(100, result.targetScore || 0));
                const prediction = result.predictedLetter || '?';
                const isCorrect = prediction === currentTarget;

                // TRAINING: Capture current snapshot for training buttons
                const energies = patternBuffer.map(frame => frame.reduce((a, b) => a + b, 0));
                const peakIdx = energies.indexOf(Math.max(...energies));
                let snapshot = patternBuffer[peakIdx];
                // Normalize to 0-1 range
                const maxVal = Math.max(...snapshot);
                if (maxVal > 0) {
                    snapshot = snapshot.map(v => v / maxVal);
                }
                lastRecordedSnapshot = snapshot;
                lastPrediction = prediction;

                // Show simplified status
                const barCount = Math.max(0, Math.floor(score / 10));
                const bar = '‚ñà'.repeat(barCount);
                const statusText = `üéØ S11-Snapshot: ${isCorrect ? '‚úì' : '‚úó'} Predicted: ${prediction} | Score: ${Math.round(score)}% ${bar}\nTarget ${currentTarget}: ${Math.round(targetScore)}%`;

                document.getElementById('status').textContent = statusText;
                document.getElementById('matchScore').textContent = Math.round(score) + '%';
                document.getElementById('confidenceFill').style.width = score + '%';

                // Visualize current recording pattern
                visualizeCurrentPattern(patternBuffer);

                // Highlight matched pattern (if additional patterns exist)
                if (window.lastMatchInfo && window.lastMatchInfo.target === currentTarget) {
                    const matchInfo = window.lastMatchInfo;
                    // Skip index 0 (main calibration pattern shown above)
                    // Additional patterns start at index 1
                    if (matchInfo.index > 0) {
                        const additionalIndex = matchInfo.index - 1;
                        highlightMatchedPattern(matchInfo.type, additionalIndex);
                    }
                }

                // Success if S11 predicts correctly AND score > 80%
                if (isCorrect && score > 80) {
                    console.log(`üéâ SUCCESS DETECTED! Letter: ${currentTarget}, Score: ${Math.round(score)}%`);
                    celebrateMatch();

                    // SCORING: Increment score for winning positive snapshot
                    console.log('üîç Checking score increment conditions:', {
                        hasLastMatchInfo: !!window.lastMatchInfo,
                        hasPositiveSnapshot: !!(window.lastMatchInfo?.positiveSnapshot),
                        matchType: window.lastMatchInfo?.matchType,
                        currentTarget: currentTarget
                    });
                    if (window.lastMatchInfo && window.lastMatchInfo.positiveSnapshot && window.lastMatchInfo.matchType === 'accepted') {
                        console.log('‚úÖ All conditions met, calling incrementSnapshotScore');
                        incrementSnapshotScore(currentTarget, window.lastMatchInfo.positiveSnapshot);
                    } else {
                        console.log('‚ùå Score increment conditions NOT met');
                    }

                    // Record attempt in adaptive learning session
                    if (currentSession) {
                        recordAttempt(currentTarget, true, listenClickedThisRound, score);
                    }

                    // TRAINING: Show RED button for 5 seconds (to correct false positives)
                    // Always show, even with continuous play (user has 5 seconds to click)
                    showSuccessTrainingButton(prediction, currentTarget);

                    // Show success message
                    document.getElementById('status').textContent = `‚úì MATCH! ${Math.round(score)}%\n\n` + statusText;
                    // Stop analyzing so results stay visible
                    console.log(`‚è∏ STOPPING GAME (isRunning was: ${isRunning})`);
                    isRunning = false;
                    console.log(`‚è∏ isRunning is now: ${isRunning}`);
                    document.getElementById('tunerBtn').textContent = '‚ñ∂ Next Letter';
                    document.getElementById('tryAgainBtn').style.display = 'inline-block';

                    // Auto-advance if continuous play is enabled
                    console.log(`üîÑ Continuous play enabled: ${continuousPlayEnabled}`);
                    if (continuousPlayEnabled) {
                        document.getElementById('tryAgainBtn').style.display = 'none'; // Hide Try Again in continuous mode
                        console.log('‚ñ∂ Auto-advancing in 1.5 seconds...');
                        setTimeout(async () => {
                            isRunning = true;
                            document.getElementById('tunerBtn').textContent = '‚è∏ Stop Game';
                            await setNextTarget();
                            analyzeTuner();
                        }, 1500); // 1.5 second delay to show success feedback
                    } else {
                        console.log('‚è∏ Waiting for user to click "Next Letter" button');
                    }
                } else {
                    // TRAINING: Show training buttons on failure (wrong prediction or low score)
                    showTrainingButtons(prediction, currentTarget);
                }

                if (false) {
                    // REGULAR DETECTION: Use pattern matching for non-plosives
                    const score = matchTargetPattern(patternBuffer, currentTarget);

                    // Also check BEST match among all letters
                    const allScores = Object.keys(calibrationData).map(letter => {
                        const normalized = normalizePattern(patternBuffer);
                        const storedPattern = calibrationData[letter].pattern;
                        const similarity = calculatePatternSimilarity(normalized, storedPattern);
                        return { letter, score: similarity * 100 };
                    });

                    allScores.sort((a, b) => b.score - a.score);
                    const bestMatch = allScores[0];

                    document.getElementById('matchScore').textContent = Math.round(score) + '%';
                    document.getElementById('confidenceFill').style.width = score + '%';
                    document.getElementById('status').textContent = `Best match: ${bestMatch.letter} (${Math.round(bestMatch.score)}%)`;

                    // Success! Pattern matched AND it's the best match
                    if (score > 85 && bestMatch.letter === currentTarget) {
                        celebrateMatch();

                        // Record attempt in adaptive learning session
                        if (currentSession) {
                            recordAttempt(currentTarget, true, listenClickedThisRound, score);
                        }

                        document.getElementById('status').textContent = `‚úì PERFECT MATCH! (Try Again or Next Letter)\nBest match: ${bestMatch.letter} (${Math.round(bestMatch.score)}%)`;
                        // Stop analyzing so results stay visible
                        isRunning = false;
                        document.getElementById('tunerBtn').textContent = '‚ñ∂ Next Letter';
                        document.getElementById('tryAgainBtn').style.display = 'inline-block';
                    }
                }
            }
        }

        function matchTargetPattern(currentPattern, targetLetter) {
            if (!calibrationData[targetLetter]) return 0;

            // Normalize current pattern
            const normalized = normalizePattern(currentPattern);
            const storedPattern = calibrationData[targetLetter].pattern;

            // Calculate correlation
            const score = calculatePatternSimilarity(normalized, storedPattern);

            // Convert to percentage
            return Math.min(100, score * 100);
        }

        function celebrateMatch() {
            const targetEl = document.getElementById('targetLetter');

            // Play success sound
            if (audioContext) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.4);
            }

            // Exciting animation sequence
            targetEl.style.transition = 'all 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55)';

            // Bounce and color sequence
            targetEl.style.transform = 'scale(1.5) rotate(5deg)';
            targetEl.style.color = '#FDD835';

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.3) rotate(-5deg)';
                targetEl.style.color = '#7CB342';
            }, 150);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.6) rotate(0deg)';
                targetEl.style.color = '#00BCD4';
            }, 300);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.2)';
                targetEl.style.color = '#FF5722';
            }, 450);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.4)';
                targetEl.style.color = '#9C27B0';
            }, 600);

            setTimeout(() => {
                targetEl.style.transition = 'all 0.3s ease-out';
                targetEl.style.transform = 'scale(1)';
                targetEl.style.color = '#FDD835';
            }, 800);

            // Create confetti particles
            createConfetti(targetEl);
        }

        function createConfetti(centerEl) {
            const container = centerEl.parentElement;
            const rect = centerEl.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const colors = ['#FDD835', '#7CB342', '#00BCD4', '#FF5722', '#9C27B0'];

            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.style.position = 'fixed';
                particle.style.left = centerX + 'px';
                particle.style.top = centerY + 'px';
                particle.style.width = '10px';
                particle.style.height = '10px';
                particle.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                particle.style.pointerEvents = 'none';
                particle.style.zIndex = '9999';

                document.body.appendChild(particle);

                const angle = (Math.PI * 2 * i) / 20;
                const velocity = 100 + Math.random() * 100;
                const vx = Math.cos(angle) * velocity;
                const vy = Math.sin(angle) * velocity;

                let x = 0, y = 0, time = 0;
                const gravity = 500;

                const animate = () => {
                    time += 0.016; // ~60fps
                    x = vx * time;
                    y = vy * time + 0.5 * gravity * time * time;

                    particle.style.transform = `translate(${x}px, ${y}px) rotate(${time * 360}deg)`;
                    particle.style.opacity = Math.max(0, 1 - time * 1.5);

                    if (time < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        particle.remove();
                    }
                };

                requestAnimationFrame(animate);
            }
        }

        // ========== EXPERIMENTAL PLOSIVE DETECTION STRATEGIES ==========

        function testAllPlosiveStrategies(patternBuffer, targetLetter) {
            if (!calibrationData[targetLetter]) return [{ strategy: 'none', score: 0, predictedLetter: '?' }];

            const results = [];
            const strategyFunctions = [
                { name: 'S11-Snapshot', fn: strategy11_simpleSnapshot }
            ];

            // For each strategy, test against ALL calibrated letters
            strategyFunctions.forEach(({ name, fn }) => {
                let bestLetter = null;
                let bestScore = 0;
                let targetScore = 0;

                // Test this strategy against all calibrated letters
                Object.keys(calibrationData).forEach(letter => {
                    const score = fn(patternBuffer, letter);
                    if (score > bestScore) {
                        bestScore = score;
                        bestLetter = letter;
                    }
                    if (letter === targetLetter) {
                        targetScore = score;
                    }
                });

                results.push({
                    strategy: name,
                    score: bestScore,
                    targetScore: targetScore,
                    predictedLetter: bestLetter || '?'
                });
            });

            // Sort by score (highest first)
            results.sort((a, b) => b.score - a.score);

            return results;
        }

        // Strategy 1: Focus on frames around peak energy
        function strategy1_burstWindow(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const peakIdx = energies.indexOf(Math.max(...energies));

            const burstWindow = buffer.slice(Math.max(0, peakIdx - 5), peakIdx + 5);
            return matchTargetPattern(burstWindow, target);
        }

        // Strategy 2: Use only first 10 frames
        function strategy2_shortWindow(buffer, target) {
            const shortBuffer = buffer.slice(0, 10);
            return matchTargetPattern(shortBuffer, target);
        }

        // Strategy 3: Compare peak frequency and amplitude
        function strategy3_peakEnergy(buffer, target) {
            const currentPeak = Math.max(...buffer.flat());
            const currentPeakFreq = buffer[0].indexOf(Math.max(...buffer[0]));

            const calibPattern = calibrationData[target].pattern;
            const calibPeak = Math.max(...calibPattern.flat());
            const calibPeakFreq = calibPattern[0].indexOf(Math.max(...calibPattern[0]));

            const peakSimilarity = 1 - Math.abs(currentPeak - calibPeak);
            const freqSimilarity = 1 - Math.abs(currentPeakFreq - calibPeakFreq) / PATTERN_BINS;

            return ((peakSimilarity + freqSimilarity) / 2) * 100;
        }

        // Strategy 4: Compare attack speed (volume rise rate)
        function strategy4_attackSpeed(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));

            let maxRise = 0;
            for (let i = 1; i < energies.length; i++) {
                const rise = energies[i] - energies[i - 1];
                if (rise > maxRise) maxRise = rise;
            }

            // Compare with calibration (would need to store this)
            // For now, just use pattern matching on energy envelope
            const normalized = normalizePattern(buffer);
            const stored = calibrationData[target].pattern;
            return calculatePatternSimilarity(normalized, stored) * 100;
        }

        // Strategy 5: Match derivatives (rate of change)
        function strategy5_derivative(buffer, target) {
            const derivatives = [];
            for (let i = 1; i < buffer.length; i++) {
                const diff = buffer[i].map((val, idx) => val - buffer[i - 1][idx]);
                derivatives.push(diff);
            }

            return matchTargetPattern(derivatives, target);
        }

        // Strategy 6: Simple burst detection + frequency check
        function strategy6_dualThreshold(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const maxEnergy = Math.max(...energies);
            const avgEnergy = energies.reduce((a, b) => a + b, 0) / energies.length;

            const isBurst = maxEnergy > avgEnergy * 2;

            if (!isBurst) return 0;

            return matchTargetPattern(buffer, target);
        }

        // Strategy 7: Average multiple high-energy frames
        function strategy7_multipleFrames(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const threshold = Math.max(...energies) * 0.7;

            const highEnergyFrames = buffer.filter((frame, idx) => energies[idx] > threshold);

            if (highEnergyFrames.length === 0) return 0;

            return matchTargetPattern(highEnergyFrames, target);
        }

        // Strategy 8: Measure quiet-to-loud ratio
        function strategy8_silenceRatio(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const avgEnergy = energies.reduce((a, b) => a + b, 0) / energies.length;

            const quietFrames = energies.filter(e => e < avgEnergy * 0.5).length;
            const silenceRatio = quietFrames / energies.length;

            // Plosives should have high silence ratio
            const expectedRatio = 0.6; // 60% quiet
            const ratioScore = 1 - Math.abs(silenceRatio - expectedRatio);

            const patternScore = matchTargetPattern(buffer, target) / 100;

            return ((ratioScore + patternScore) / 2) * 100;
        }

        // Strategy 10: Only match first 5 frames (immediate burst)
        function strategy10_firstFrames(buffer, target) {
            const firstFrames = buffer.slice(0, 5);
            return matchTargetPattern(firstFrames, target);
        }

        // Strategy 11: Simple Snapshot Comparison (peak moment bar heights)
        // UPDATED: Works with new cross-profile snapshot pooling system
        function strategy11_simpleSnapshot(buffer, target) {
            if (!calibrationData[target] || !calibrationData[target].snapshots) return 0;

            // Find peak moment in current buffer (highest energy frame)
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const currentPeakIdx = energies.indexOf(Math.max(...energies));
            let currentSnapshot = buffer[currentPeakIdx];

            // Normalize current snapshot to 0-1 range (same as calibration data)
            const maxCurrent = Math.max(...currentSnapshot);
            if (maxCurrent > 0) {
                currentSnapshot = currentSnapshot.map(v => v / maxCurrent);
            }

            const snapshots = calibrationData[target].snapshots;
            let bestPositiveScore = 0;
            let bestPositiveSnapshot = null;
            let bestNegativeScore = 0;
            let bestNegativeSnapshot = null;

            // Test against ALL snapshots (both positive and negative)
            snapshots.forEach((snapshot) => {
                if (!snapshot || !snapshot.data) return;

                // Calculate simple distance (sum of absolute differences)
                let totalDistance = 0;
                const minLength = Math.min(currentSnapshot.length, snapshot.data.length);

                for (let i = 0; i < minLength; i++) {
                    totalDistance += Math.abs(currentSnapshot[i] - snapshot.data[i]);
                }

                // Convert distance to similarity score (0-100)
                const avgDistance = totalDistance / minLength;
                const similarity = Math.max(0, 100 - (avgDistance * 100));

                // Track best positive and negative separately
                if (snapshot.isNegative) {
                    if (similarity > bestNegativeScore) {
                        bestNegativeScore = similarity;
                        bestNegativeSnapshot = snapshot;
                    }
                } else {
                    if (similarity > bestPositiveScore) {
                        bestPositiveScore = similarity;
                        bestPositiveSnapshot = snapshot;
                    }
                }
            });

            // Store match info globally for highlighting AND score tracking
            window.lastMatchInfo = {
                target: target,
                positiveSnapshot: bestPositiveSnapshot,
                positiveScore: bestPositiveScore,
                negativeSnapshot: bestNegativeSnapshot,
                negativeScore: bestNegativeScore
            };

            // Reject only if negative is SIGNIFICANTLY stronger (5% margin)
            const NEGATIVE_MARGIN = 5;

            if (bestNegativeScore > bestPositiveScore + NEGATIVE_MARGIN) {
                const diff = bestNegativeScore - bestPositiveScore;
                console.log(`‚ùå REJECTED: Negative (${bestNegativeScore.toFixed(1)}%) beats positive (${bestPositiveScore.toFixed(1)}%) by ${diff.toFixed(1)}%`);
                window.lastMatchInfo.matchType = 'rejected';

                // SCORING: Award point to negative snapshot (max 1 per round)
                if (bestNegativeSnapshot && canAwardNegativePoint(bestNegativeSnapshot)) {
                    // Only award if the positive match would have been strong enough (>80%) without the negative
                    if (bestPositiveScore > 80) {
                        incrementSnapshotScore(target, bestNegativeSnapshot);
                        markNegativeSnapshotAwarded(bestNegativeSnapshot);
                    }
                }

                return 0; // Reject completely
            }

            // ACCEPTED: Positive match wins
            if (bestNegativeScore > 0) {
                const diff = bestPositiveScore - bestNegativeScore;
                console.log(`‚úÖ ACCEPTED: Positive (${bestPositiveScore.toFixed(1)}%) beats negative (${bestNegativeScore.toFixed(1)}%) by ${diff.toFixed(1)}%`);
            } else {
                console.log(`‚úÖ ACCEPTED: Positive match (${bestPositiveScore.toFixed(1)}%), no negatives`);
            }

            window.lastMatchInfo.matchType = 'accepted';
            return bestPositiveScore;
        }

        function calculatePatternSimilarity(pattern1, pattern2) {
            // Use correlation coefficient to measure similarity
            let sumProduct = 0;
            let sum1Sq = 0;
            let sum2Sq = 0;
            let count = 0;

            const minLength = Math.min(pattern1.length, pattern2.length);

            for (let t = 0; t < minLength; t++) {
                const slice1 = pattern1[t];
                const slice2 = pattern2[t];
                const minBins = Math.min(slice1.length, slice2.length);

                for (let f = 0; f < minBins; f++) {
                    sumProduct += slice1[f] * slice2[f];
                    sum1Sq += slice1[f] * slice1[f];
                    sum2Sq += slice2[f] * slice2[f];
                    count++;
                }
            }

            const denominator = Math.sqrt(sum1Sq * sum2Sq);
            if (denominator === 0) return 0;

            return sumProduct / denominator; // Correlation coefficient
        }

        function drawSpectrum() {
            const width = canvas.width;
            const height = canvas.height;

            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            canvasCtx.fillRect(0, 0, width, height);

            const barWidth = width / dataArray.length * 2.5;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * height;
                const hue = (i / dataArray.length) * 120 + 100;
                canvasCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                canvasCtx.fillRect(x, height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        // Draw downsampled pattern (64 bins) on a canvas
        function drawDownsampledPattern(ctx, canvas, pattern) {
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, width, height);

            if (!pattern || pattern.length === 0) return;

            // Draw bars
            const barWidth = width / pattern.length;
            pattern.forEach((value, i) => {
                const barHeight = value * height;
                const hue = (i / pattern.length) * 120 + 100;
                ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                ctx.fillRect(i * barWidth, height - barHeight, barWidth - 1, barHeight);
            });
        }

        // Visualize stored calibration pattern for current target letter
        function visualizeStoredPattern(letter) {
            if (!storedPatternCanvas || !storedPatternCtx) {
                console.log('‚ö†Ô∏è Pattern canvases not initialized yet');
                return;
            }

            if (!calibrationData[letter]) {
                // Clear canvas if no calibration
                storedPatternCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                storedPatternCtx.fillRect(0, 0, storedPatternCanvas.width, storedPatternCanvas.height);
                console.log(`‚ö†Ô∏è No calibration data for letter: ${letter}`);
                document.getElementById('patternCount').textContent = '-';
                return;
            }

            // Get stored snapshots (NEW FORMAT: snapshots array with .data property)
            const snapshots = calibrationData[letter].snapshots || [];

            if (snapshots.length === 0) {
                console.log(`‚ö†Ô∏è No snapshots for letter: ${letter}`);
                storedPatternCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                storedPatternCtx.fillRect(0, 0, storedPatternCanvas.width, storedPatternCanvas.height);
                document.getElementById('patternCount').textContent = '-';
                return;
            }

            // Get first positive snapshot for visualization
            const firstPositive = snapshots.find(s => !s.isNegative);
            if (!firstPositive || !firstPositive.data) {
                console.log(`‚ö†Ô∏è No valid positive snapshot for letter: ${letter}`);
                return;
            }

            const storedPattern = firstPositive.data;

            // Normalize pattern for visualization
            const max = Math.max(...storedPattern);
            const normalized = max > 0 ? storedPattern.map(v => v / max) : storedPattern;

            drawDownsampledPattern(storedPatternCtx, storedPatternCanvas, normalized);

            // Update pattern count display
            const posCount = snapshots.filter(s => !s.isNegative).length;
            const negCount = snapshots.filter(s => s.isNegative).length;
            const countText = `${posCount} positive${negCount > 0 ? `, ${negCount} negative` : ''}`;
            document.getElementById('patternCount').textContent = countText;

            console.log(`‚úÖ Visualized stored pattern for ${letter} (${countText})`);

            // Also visualize additional training patterns
            visualizeAdditionalPatterns(letter);
        }

        // Visualize current recording pattern
        function visualizeCurrentPattern(buffer) {
            if (!currentPatternCanvas || !currentPatternCtx) {
                return; // Silently fail if not initialized
            }

            if (!buffer || buffer.length === 0) {
                // Clear canvas if no data
                currentPatternCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                currentPatternCtx.fillRect(0, 0, currentPatternCanvas.width, currentPatternCanvas.height);
                return;
            }

            // Use the most recent frame from buffer
            const currentPattern = buffer[buffer.length - 1];

            // Normalize pattern for visualization
            const max = Math.max(...currentPattern);
            const normalized = max > 0 ? currentPattern.map(v => v / max) : currentPattern;

            drawDownsampledPattern(currentPatternCtx, currentPatternCanvas, normalized);
        }

        // Visualize additional training patterns (positive and negative)
        let lastMatchedPatternIndex = null;
        let lastMatchedPatternType = null;

        function visualizeAdditionalPatterns(letter) {
            try {
                const container = document.getElementById('additionalPatternsContainer');
                const grid = document.getElementById('additionalPatternsGrid');

                console.log(`üìä visualizeAdditionalPatterns called for ${letter}`);
                console.log(`  Container exists: ${!!container}, Grid exists: ${!!grid}`);

                if (!container || !grid) {
                    console.log('‚ö†Ô∏è Additional patterns container/grid not found');
                    return;
                }

                // Get all snapshots from calibrationData (NEW FORMAT)
                const snapshots = calibrationData[letter]?.snapshots || [];

                console.log(`  Found ${snapshots.length} total snapshots for ${letter}`);

                // If no snapshots, hide container
                if (snapshots.length === 0) {
                    console.log(`  No snapshots to display, hiding container`);
                    container.style.display = 'none';
                    return;
                }

                // Show container and clear grid
                container.style.display = 'block';
                grid.innerHTML = '';
                console.log(`  Container displayed, grid cleared`);

                // Separate positive and negative snapshots
                const positiveSnapshots = snapshots.filter(s => !s.isNegative);
                const negativeSnapshots = snapshots.filter(s => s.isNegative);

                // Sort by score (highest first)
                positiveSnapshots.sort((a, b) => (b.score || 0) - (a.score || 0));
                negativeSnapshots.sort((a, b) => (b.score || 0) - (a.score || 0));

                console.log(`  ${positiveSnapshots.length} positive, ${negativeSnapshots.length} negative (sorted by score)`);

                // Add positive snapshots
                positiveSnapshots.forEach((snapshot, index) => {
                    try {
                        const card = createPatternCard(snapshot.data, 'positive', index, letter, snapshot.score, snapshot.profileId);
                        grid.appendChild(card);
                        console.log(`  ‚úÖ Added positive snapshot card #${index + 1} (score: ${snapshot.score})`);
                    } catch (e) {
                        console.error(`  ‚ùå Error creating positive snapshot #${index + 1}:`, e);
                    }
                });

                // Add negative snapshots
                negativeSnapshots.forEach((snapshot, index) => {
                    try {
                        const card = createPatternCard(snapshot.data, 'negative', index, letter, snapshot.score, snapshot.profileId);
                        grid.appendChild(card);
                        console.log(`  ‚úÖ Added negative snapshot card #${index + 1} (score: ${snapshot.score})`);
                    } catch (e) {
                        console.error(`‚ùå Error creating negative snapshot #${index + 1}:`, e);
                    }
                });

                console.log(`‚úÖ Visualized ${snapshots.length} total snapshots`);
            } catch (error) {
                console.error('‚ùå Error in visualizeAdditionalPatterns:', error);
            }
        }

        function createPatternCard(pattern, type, index, letter, score = 0, profileId = null) {
            const card = document.createElement('div');
            const bgColor = type === 'positive' ? 'rgba(76,175,80,0.1)' : 'rgba(244,67,54,0.1)';
            const borderColor = type === 'positive' ? '#4CAF50' : '#f44336';
            const icon = type === 'positive' ? '‚úì' : '‚úó';

            card.id = `pattern-${type}-${index}`;
            card.style.cssText = `
                background: ${bgColor};
                padding: 10px;
                border-radius: 8px;
                border: 2px solid ${borderColor};
                transition: all 0.3s ease;
            `;

            const label = document.createElement('div');
            label.style.cssText = `
                color: ${borderColor};
                font-size: 10px;
                margin-bottom: 5px;
                text-align: center;
                font-weight: bold;
            `;
            label.textContent = `${icon} ${type.toUpperCase()} #${index + 1}`;

            // Add score and profile info
            const info = document.createElement('div');
            info.style.cssText = `
                color: #aaa;
                font-size: 9px;
                margin-bottom: 5px;
                text-align: center;
            `;
            const profileName = profileId ? profileId.substring(0, 8) : 'Unknown';
            const scoreValue = score || 0;
            info.textContent = `‚úì ${scoreValue} matches | Profile: ${profileName}`;

            const canvas = document.createElement('canvas');
            canvas.style.cssText = 'width: 100%; height: 50px; background: rgba(0,0,0,0.3); border-radius: 5px;';
            canvas.width = 200;
            canvas.height = 50;

            card.appendChild(label);
            card.appendChild(info);
            card.appendChild(canvas);

            // Draw pattern on canvas
            const ctx = canvas.getContext('2d');
            const max = Math.max(...pattern);
            const normalized = max > 0 ? pattern.map(v => v / max) : pattern;
            drawDownsampledPattern(ctx, canvas, normalized);

            return card;
        }

        function highlightMatchedPattern(type, index) {
            // Remove previous highlight
            if (lastMatchedPatternIndex !== null && lastMatchedPatternType !== null) {
                const prevCard = document.getElementById(`pattern-${lastMatchedPatternType}-${lastMatchedPatternIndex}`);
                if (prevCard) {
                    const borderColor = lastMatchedPatternType === 'positive' ? '#4CAF50' : '#f44336';
                    prevCard.style.border = `2px solid ${borderColor}`;
                    prevCard.style.boxShadow = 'none';
                    prevCard.style.transform = 'scale(1)';
                }
            }

            // Add new highlight
            const card = document.getElementById(`pattern-${type}-${index}`);
            if (card) {
                const glowColor = type === 'positive' ? '#4CAF50' : '#f44336';
                card.style.border = `3px solid ${glowColor}`;
                card.style.boxShadow = `0 0 20px ${glowColor}`;
                card.style.transform = 'scale(1.05)';

                lastMatchedPatternIndex = index;
                lastMatchedPatternType = type;
            }
        }

        // DEPRECATED: Audio is now stored in Supabase Storage
        // These functions are kept for backwards compatibility but are no longer used
        function saveAudioRecording(letter, audioBlob) {
            console.warn('‚ö†Ô∏è saveAudioRecording is deprecated - audio now saved to Supabase Storage');
        }

        function loadAudioRecordings() {
            console.warn('‚ö†Ô∏è loadAudioRecordings is deprecated - audio loaded from Supabase');
            audioRecordings = {}; // Keep empty for legacy code compatibility
        }

        let isPlayingRecording = false;
        let currentPhonemeAudio = null;

        function playPhonemeSound(letter) {
            const phoneme = PHONEMES.find(p => p.letter === letter);
            if (!phoneme || !phoneme.audioUrl) return;

            if (currentPhonemeAudio) {
                currentPhonemeAudio.pause();
                currentPhonemeAudio.currentTime = 0;
            }

            currentPhonemeAudio = new Audio(phoneme.audioUrl);
            currentPhonemeAudio.play().catch(err => {
                console.error('Audio playback failed:', err);
            });
        }

        function playCalibrationRecording() {
            if (!currentTarget) {
                alert('No letter selected. Start the game first!');
                return;
            }

            // Get audio URL from Supabase calibration data
            const calibration = calibrationData[currentTarget];
            if (!calibration || !calibration.audioUrl) {
                alert(`No recording found for ${currentTarget}. Please calibrate this letter first.`);
                return;
            }

            // Track LISTEN button click for adaptive learning
            listenClickedThisRound = true;
            console.log(`üîä LISTEN clicked for ${currentTarget}`);

            isPlayingRecording = true;
            const audio = new Audio(calibration.audioUrl);

            audio.onended = () => {
                isPlayingRecording = false;
            };

            audio.onerror = () => {
                isPlayingRecording = false;
                alert('Error playing audio from Supabase Storage');
            };

            audio.play();
        }

        async function setupAudio() {
            try {
                const setupStart = Date.now();
                console.log('üé§ Requesting microphone access...');

                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const micTime = Date.now() - setupStart;
                console.log(`‚è±Ô∏è Microphone permission granted in ${micTime}ms`);

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.stream = stream;

                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.5;

                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);

                microphone.connect(analyser);

                const totalTime = Date.now() - setupStart;
                console.log(`‚úÖ Audio setup complete in ${totalTime}ms`);

            } catch (err) {
                alert('Microphone access denied!');
                console.error('Audio setup error:', err);
            }
        }

        async function switchTab(tabName) {
            console.log(`üîÑ switchTab called with: "${tabName}"`);

            // Flush pending scores before switching tabs
            await flushAllPendingScores();

            // ===== STOP ALL RUNNING GAMES/ANIMATIONS BEFORE SWITCHING =====

            // Stop Play tab if running
            if (isRunning) {
                console.log('üõë Stopping Play...');
                isRunning = false;
                const tunerBtn = document.getElementById('tunerBtn');
                if (tunerBtn) tunerBtn.textContent = '‚ñ∂ Start Game';
            }

            // Stop Progressive Game (falling letters) if running
            if (progressGame && progressGame.running) {
                console.log('üõë Stopping Progressive Game...');
                progressGame.running = false;
                if (progressGame.animationFrame) {
                    cancelAnimationFrame(progressGame.animationFrame);
                    progressGame.animationFrame = null;
                }
                if (progressGame.audioAnalysisFrame) {
                    cancelAnimationFrame(progressGame.audioAnalysisFrame);
                    progressGame.audioAnalysisFrame = null;
                }
                const progressBtn = document.getElementById('progressGameBtn');
                if (progressBtn) progressBtn.textContent = '‚ñ∂ Start Game';
            }

            console.log('‚úì All games stopped');

            // Remove active from all tabs and content
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            // Find and activate the clicked tab button
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                if (tab.onclick && tab.onclick.toString().includes(`'${tabName}'`)) {
                    tab.classList.add('active');
                    console.log(`‚úì Activated tab button for: ${tabName}`);
                }
            });

            // Show the tab content
            const tabContent = document.getElementById(tabName);
            console.log(`üìã Found tab content element:`, tabContent);

            if (tabContent) {
                tabContent.classList.add('active');
                console.log(`‚úì Added 'active' class to #${tabName}`);
                console.log(`üìä Element display after:`, window.getComputedStyle(tabContent).display);

                // Initialize pattern canvases when switching to Play tab
                if (tabName === 'tuner') {
                    initializePatternCanvases();
                }

                // Update stats display when switching to Stats tab
                if (tabName === 'stats') {
                    // Load session if not already loaded
                    if (!currentSession && currentProfileId) {
                        initializeSession(currentProfileId);
                    }
                    updateAdaptiveStatsDisplay();
                }
            } else {
                console.error(`‚ùå Could not find element with id="${tabName}"`);
            }
        }

        // ========== ADAPTIVE STATS DISPLAY ==========

        async function updateAdaptiveStatsDisplay() {
            // Always load proficiency pools (permanent data, not session-specific)
            const calibratedLetters = Object.keys(calibrationData);
            const proficiencyMap = await loadProficiencyMap(currentProfileId);
            const pools = groupLettersByProficiency(proficiencyMap, calibratedLetters);

            document.getElementById('statsMastered').textContent = pools.mastered.length.toString();
            document.getElementById('statsKnown').textContent = pools.known.length.toString();
            document.getElementById('statsSometimes').textContent = pools.sometimes.length.toString();
            document.getElementById('statsUnknown').textContent = pools.unknown.length.toString();

            // Session-specific stats (only show if session is active)
            if (!currentSession) {
                document.getElementById('statsPhase').textContent = 'Not Started';
                document.getElementById('statsAttempts').textContent = '0';
                document.getElementById('statsNewLetters').textContent = 'None';
                document.getElementById('statsGraduated').textContent = 'None';
                document.getElementById('statsStreak').textContent = '0';
                return;
            }

            // Determine current phase
            const attemptCount = currentSession.attempts.length;
            let phase = 'Not Started';
            if (attemptCount > 0) {
                if (attemptCount < SESSION_CONFIG.WARMUP_COUNT) {
                    phase = `Warmup (${attemptCount}/${SESSION_CONFIG.WARMUP_COUNT})`;
                } else {
                    // Check if in rapid reinforcement
                    const lastAttempt = currentSession.attempts[currentSession.attempts.length - 1];
                    if (lastAttempt?.clickedListen) {
                        const stats = currentSession.letterStats.get(lastAttempt.letter);
                        if (stats && stats.listen_clicks === 1 && stats.total_attempts <= SESSION_CONFIG.RAPID_REP_COUNT) {
                            phase = `Rapid Rep (${stats.total_attempts}/${SESSION_CONFIG.RAPID_REP_COUNT})`;
                        } else {
                            phase = 'Mixed Practice';
                        }
                    } else {
                        phase = 'Mixed Practice';
                    }
                }
            }

            document.getElementById('statsPhase').textContent = phase;
            document.getElementById('statsAttempts').textContent = attemptCount.toString();

            // Session info
            const newLetters = currentSession.newLettersIntroduced.length > 0
                ? currentSession.newLettersIntroduced.join(', ')
                : 'None';
            document.getElementById('statsNewLetters').textContent = newLetters;

            const graduated = currentSession.lettersGraduated.length > 0
                ? currentSession.lettersGraduated.join(', ')
                : 'None';
            document.getElementById('statsGraduated').textContent = graduated;

            // Calculate current streak
            let streak = 0;
            if (currentTarget) {
                const stats = currentSession.letterStats.get(currentTarget);
                if (stats) {
                    streak = stats.consecutive_success_no_listen || 0;
                }
            }
            document.getElementById('statsStreak').textContent = streak.toString();
        }

        // ===================================
        // PARTICLE SYSTEM FOR GAME EFFECTS
        // ===================================

        class Particle {
            constructor(x, y, color, size = null, vx = null, vy = null) {
                this.x = x;
                this.y = y;
                this.vx = vx !== null ? vx : (Math.random() - 0.5) * 10;
                this.vy = vy !== null ? vy : (Math.random() - 0.5) * 10;
                this.life = 1.0;
                this.color = color;
                this.size = size !== null ? size : (Math.random() * 6 + 3);
                this.gravity = 0.4;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.vx *= 0.98; // Air resistance
                this.life -= 0.02;
                this.rotation += this.rotationSpeed;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                ctx.restore();
            }
        }

        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            explode(x, y, colors, count = 30, speedMultiplier = 1) {
                for (let i = 0; i < count; i++) {
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    const angle = (Math.PI * 2 * i) / count;
                    const speed = (3 + Math.random() * 4) * speedMultiplier;
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    this.particles.push(new Particle(x, y, color, null, vx, vy));
                }
            }

            confetti(x, y, count = 50) {
                const colors = ['#FF6B6B', '#FDD835', '#4CAF50', '#2196F3', '#9C27B0', '#FF9800'];
                for (let i = 0; i < count; i++) {
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    const vx = (Math.random() - 0.5) * 15;
                    const vy = -Math.random() * 12 - 5; // Shoot upward
                    this.particles.push(new Particle(x, y, color, Math.random() * 8 + 4, vx, vy));
                }
            }

            sparkle(x, y, color, count = 15) {
                for (let i = 0; i < count; i++) {
                    const vx = (Math.random() - 0.5) * 6;
                    const vy = (Math.random() - 0.5) * 6;
                    this.particles.push(new Particle(x, y, color, Math.random() * 4 + 2, vx, vy));
                }
            }

            update() {
                this.particles.forEach(p => p.update());
                this.particles = this.particles.filter(p => p.life > 0);
            }

            draw(ctx) {
                this.particles.forEach(p => p.draw(ctx));
                ctx.globalAlpha = 1.0; // Reset alpha
            }
        }

        // ===================================
        // GAME MODE CONFIGURATIONS
        // ===================================

        const GAME_MODES = {
            1: { // Chill Mode
                name: "üê¢ Chill Mode",
                description: "Slow & relaxing - perfect for learning",
                speed: 1,
                spawnDelay: 3500,
                particleCount: 20,
                particleColors: ['#A5D6A7', '#C5E1A5', '#E6EE9C', '#FFF9C4'],
                particleSpeed: 0.7,
                screenShake: false,
                confettiOnMastery: false
            },
            2: { // Classic Mode
                name: "‚≠ê Classic Mode",
                description: "Default speed & effects",
                speed: 2,
                spawnDelay: 2500,
                particleCount: 30,
                particleColors: ['#7CB342', '#FDD835', '#FFEB3B', '#CDDC39'],
                particleSpeed: 1,
                screenShake: false,
                confettiOnMastery: false
            },
            3: { // Arcade Mode
                name: "üöÄ Arcade Mode",
                description: "Fast & exciting!",
                speed: 3.5,
                spawnDelay: 1800,
                particleCount: 50,
                particleColors: ['#FF6B6B', '#FDD835', '#4CAF50', '#2196F3'],
                particleSpeed: 1.4,
                screenShake: true,
                confettiOnMastery: true
            },
            4: { // Chaos Mode
                name: "üí• Chaos Mode",
                description: "SUPER FAST - for speed demons!",
                speed: 5,
                spawnDelay: 1200,
                particleCount: 80,
                particleColors: ['#F44336', '#E91E63', '#9C27B0', '#FF5722', '#FFEB3B'],
                particleSpeed: 2,
                screenShake: true,
                confettiOnMastery: true
            },
            5: { // Rainbow Mode
                name: "üåà Rainbow Mode",
                description: "Maximum visual satisfaction!",
                speed: 2.5,
                spawnDelay: 2200,
                particleCount: 60,
                particleColors: ['#FF6B6B', '#FF9800', '#FDD835', '#4CAF50', '#2196F3', '#9C27B0'],
                particleSpeed: 1.2,
                screenShake: false,
                confettiOnMastery: true
            }
        };

        let currentGameMode = 2; // Default to Classic

        function setGameMode(modeNumber) {
            currentGameMode = modeNumber;
            const mode = GAME_MODES[modeNumber];
            document.getElementById('currentModeDesc').textContent = `Current: ${mode.name} - ${mode.description}`;

            // If game is running, apply new settings immediately
            if (progressGame.running) {
                progressGame.spawnDelay = mode.spawnDelay;
            }

            console.log(`üéÆ Switched to ${mode.name}`);
        }

        // ===================================
        // PROGRESSIVE LEARNING GAME
        // ===================================

        // Particle system instance
        const particleSystem = new ParticleSystem();

        // Game state
        let progressGame = {
            running: false,
            currentLevel: 1,  // 1 = Listen+Hit, 2 = Listen+Choose, 3 = Say+Hit
            currentBatch: 0,  // Which batch of letters (0 = vowels, 1-4 = consonant groups)
            currentLetterIndex: 0,
            batches: [
                ['A', 'E', 'I', 'O', 'U'],  // Batch 0: Vowels
                ['B', 'C', 'D', 'F', 'G'],  // Batch 1: Consonants 1
                ['H', 'J', 'K', 'L', 'M'],  // Batch 2: Consonants 2
                ['N', 'P', 'Q', 'R', 'S'],  // Batch 3: Consonants 3
                ['T', 'V', 'W', 'X', 'Y', 'Z']  // Batch 4: Consonants 4
            ],
            letterProgress: {},  // {A: {level1: 5, level2: 3, level3: 0}, ...}
            hitsNeeded: 8,  // Number of successful hits to master a letter at current level
            score: 0,
            fallingLetters: [],
            canvas: null,
            ctx: null,
            animationFrame: null,
            lastSpawnTime: 0,
            spawnDelay: 2000,  // ms between spawns
            audioAnalysisFrame: null,
            patternBuffer: [],
            shakeIntensity: 0,  // Screen shake effect intensity
            // Auto-calibration state
            calibrationMode: false,
            calibrationRecordings: [],
            calibrationAudioClips: [],
            calibrationCount: 0,
            calibrationTarget: 5,
            currentRecorder: null
        };

        // Helper to get current batch letters
        function getCurrentBatchLetters() {
            return progressGame.batches[progressGame.currentBatch];
        }

        // Helper to get all alphabet letters
        function getAllLetters() {
            return progressGame.batches.flat();
        }

        // Initialize progress from localStorage
        function loadProgressGameData() {
            const saved = localStorage.getItem('progressGameData');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    progressGame.currentLevel = data.currentLevel || 1;
                    progressGame.currentBatch = data.currentBatch || 0;
                    progressGame.currentLetterIndex = data.currentLetterIndex || 0;
                    progressGame.letterProgress = data.letterProgress || {};
                    progressGame.score = data.score || 0;
                } catch (e) {
                    console.error('Error loading progress:', e);
                    initializeLetterProgress();
                }
            } else {
                initializeLetterProgress();
            }
            updateProgressUI();
        }

        function initializeLetterProgress() {
            progressGame.letterProgress = {};
            getAllLetters().forEach(letter => {
                progressGame.letterProgress[letter] = { level1: 0, level2: 0, level3: 0 };
            });
        }

        function saveProgressGameData() {
            const data = {
                currentLevel: progressGame.currentLevel,
                currentBatch: progressGame.currentBatch,
                currentLetterIndex: progressGame.currentLetterIndex,
                letterProgress: progressGame.letterProgress,
                score: progressGame.score
            };
            localStorage.setItem('progressGameData', JSON.stringify(data));
        }

        function toggleProgressGame() {
            if (progressGame.running) {
                stopProgressGame();
            } else {
                startProgressGame();
            }
        }

        async function startProgressGame() {
            if (!audioContext) {
                console.log('üé§ Setting up audio for the first time...');
                await setupAudio();
            }

            // Verify audio is working
            if (!analyser || !microphone) {
                console.error('‚ùå Audio not set up properly!');
                alert('Microphone not ready. Please allow microphone access and try again.');
                return;
            }

            console.log('‚úÖ Audio context ready:', audioContext.state);
            console.log('‚úÖ Analyser:', analyser);
            console.log('‚úÖ Microphone:', microphone);

            progressGame.running = true;
            progressGame.canvas = document.getElementById('progressGameCanvas');
            progressGame.ctx = progressGame.canvas.getContext('2d');
            progressGame.canvas.width = 500;
            progressGame.canvas.height = 600;

            document.getElementById('progressGameBtn').textContent = '‚è∏ Pause';
            updateProgressInstructions();
            updateProgressUI();

            // Check if current letter needs calibration
            const currentBatchLetters = getCurrentBatchLetters();
            const currentLetter = currentBatchLetters[progressGame.currentLetterIndex];
            const isCalibrated = calibrationData[currentLetter] !== undefined;

            if (!isCalibrated) {
                // Enter auto-calibration mode (voice-triggered)
                progressGame.calibrationMode = true;
                progressGame.calibrationRecordings = [];
                progressGame.calibrationAudioClips = [];
                progressGame.calibrationCount = 0;
                progressGame.currentRecorder = null;

                document.getElementById('progressStatus').textContent =
                    `üé§ Say "${currentLetter}" when you see it! (${progressGame.calibrationCount}/${progressGame.calibrationTarget})`;

                // Show skip button
                document.getElementById('skipCalibrationBtn').style.display = 'inline-block';
            } else {
                progressGame.calibrationMode = false;
                // Hide skip button
                document.getElementById('skipCalibrationBtn').style.display = 'none';
            }

            // Always start normal game mode (no overlay)
            progressGame.canvas.addEventListener('click', handleCanvasClick);
            gameLoop();

            // Start audio analysis for Level 3 OR for auto-calibration
            if (progressGame.currentLevel === 3 || progressGame.calibrationMode) {
                analyzeProgressAudio();
                // Show volume meter
                document.getElementById('volumeMeter').style.display = 'block';
            } else {
                // Hide volume meter
                document.getElementById('volumeMeter').style.display = 'none';
            }
        }

        function stopProgressGame() {
            progressGame.running = false;
            document.getElementById('progressGameBtn').textContent = '‚ñ∂ Start Game';

            if (progressGame.animationFrame) {
                cancelAnimationFrame(progressGame.animationFrame);
            }
            if (progressGame.audioAnalysisFrame) {
                cancelAnimationFrame(progressGame.audioAnalysisFrame);
            }

            // Stop any active recording
            if (progressGame.currentRecorder && progressGame.currentRecorder.state === 'recording') {
                progressGame.currentRecorder.stop();
                progressGame.currentRecorder = null;
            }

            progressGame.canvas.removeEventListener('click', handleCanvasClick);
            progressGame.fallingLetters = [];

            // Hide volume meter and skip button
            document.getElementById('volumeMeter').style.display = 'none';
            document.getElementById('skipCalibrationBtn').style.display = 'none';
        }

        function skipCalibration() {
            console.log('‚è≠ Skipping calibration - using clicks only');

            // Exit calibration mode
            progressGame.calibrationMode = false;
            progressGame.calibrationRecordings = [];
            progressGame.calibrationAudioClips = [];
            progressGame.calibrationCount = 0;

            // Hide skip button
            document.getElementById('skipCalibrationBtn').style.display = 'none';

            // Hide volume meter
            document.getElementById('volumeMeter').style.display = 'none';

            // Update status
            document.getElementById('progressStatus').textContent = 'üñ± Calibration skipped! Click letters to pop them.';

            // Stop audio analysis
            if (progressGame.audioAnalysisFrame) {
                cancelAnimationFrame(progressGame.audioAnalysisFrame);
                progressGame.audioAnalysisFrame = null;
            }

            updateProgressInstructions();
        }

        function resetProgressGame() {
            if (confirm('Are you sure you want to reset all progress? This cannot be undone.')) {
                localStorage.removeItem('progressGameData');
                progressGame.currentLevel = 1;
                progressGame.currentLetterIndex = 0;
                progressGame.score = 0;
                initializeLetterProgress();
                updateProgressUI();
                document.getElementById('progressStatus').textContent = 'Progress reset! Click Start to begin.';
            }
        }
        // ===================================
        // AUTO-CALIBRATION FUNCTIONS
        // ===================================

        function startVoiceRecording() {
            if (progressGame.currentRecorder) return; // Already recording

            const stream = microphone.mediaStream;
            const recorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
            const audioChunks = [];

            recorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };

            recorder.onstop = () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                progressGame.calibrationAudioClips.push(audioBlob);
                progressGame.currentRecorder = null;
            };

            recorder.start();
            progressGame.currentRecorder = recorder;
            console.log('üé§ Started recording for auto-calibration');
        }

        function stopVoiceRecording() {
            if (progressGame.currentRecorder && progressGame.currentRecorder.state === 'recording') {
                progressGame.currentRecorder.stop();
                console.log('üõë Stopped recording');
            }
        }

        async function finishAutoCalibration(letter) {
            document.getElementById('progressStatus').textContent = '‚ú® Processing your voice...';

            try {
                // Run clustering on patterns
                const cluster = findBestCluster(progressGame.calibrationRecordings);
                const baseline = averageSnapshots(cluster.cluster);

                // Find index of first pattern in cluster
                const bestIndex = cluster.indices[0];
                const bestAudioClip = progressGame.calibrationAudioClips[bestIndex];

                // Save to Supabase
                const success = await saveAutoCalibration(letter, baseline, bestAudioClip);

                if (success) {
                    document.getElementById('progressStatus').textContent = `‚úÖ Voice calibrated for ${letter}! Now tap to play!`;

                    // Update local calibration data
                    calibrationData[letter] = {
                        pattern: [baseline],
                        timestamp: Date.now()
                    };

                    // Switch to normal tap mode
                    progressGame.calibrationMode = false;
                    progressGame.calibrationRecordings = [];
                    progressGame.calibrationAudioClips = [];
                    progressGame.calibrationCount = 0;

                    // Continue game normally
                    updateProgressInstructions();
                } else {
                    document.getElementById('progressStatus').textContent = '‚ùå Save failed. Retrying...';
                    // Reset to try again
                    progressGame.calibrationRecordings = [];
                    progressGame.calibrationAudioClips = [];
                    progressGame.calibrationCount = 0;
                }
            } catch (error) {
                console.error('Auto-calibration error:', error);
                document.getElementById('progressStatus').textContent = '‚ùå Error occurred. Please try again.';
                // Reset to try again
                progressGame.calibrationRecordings = [];
                progressGame.calibrationAudioClips = [];
                progressGame.calibrationCount = 0;
            }
        }

        async function saveAutoCalibration(letter, baseline, audioBlob) {
            try {
                // Upload audio to Supabase Storage
                const filename = `${currentProfileId}/${letter}_${Date.now()}.webm`;
                const { data: uploadData, error: uploadError } = await supabase.storage
                    .from('calibration_audio')
                    .upload(filename, audioBlob, {
                        contentType: 'audio/webm',
                        upsert: false
                    });

                if (uploadError) throw uploadError;

                const audioUrl = `${SUPABASE_URL}/storage/v1/object/public/calibration_audio/${filename}`;

                // Save calibration to database
                const { data, error } = await supabase
                    .from('calibrations')
                    .upsert({
                        profile_id: currentProfileId,
                        letter: letter,
                        pattern: baseline,
                        audio_url: audioUrl,
                        calibration_method: 'auto',
                        updated_at: new Date().toISOString()
                    }, {
                        onConflict: 'profile_id,letter'
                    });

                if (error) throw error;

                console.log(`‚úÖ Auto-calibrated ${letter}`);
                return true;
            } catch (error) {
                console.error(`‚ùå Failed to save auto-calibration for ${letter}:`, error);
                return false;
            }
        }

        function gameLoop() {
            if (!progressGame.running) return;

            const now = Date.now();
            const { ctx, canvas } = progressGame;
            const mode = GAME_MODES[currentGameMode];

            // Apply screen shake if enabled
            let shakeX = 0, shakeY = 0;
            if (progressGame.shakeIntensity > 0) {
                shakeX = (Math.random() - 0.5) * progressGame.shakeIntensity;
                shakeY = (Math.random() - 0.5) * progressGame.shakeIntensity;
                progressGame.shakeIntensity *= 0.9; // Decay
                if (progressGame.shakeIntensity < 0.1) progressGame.shakeIntensity = 0;
            }

            ctx.save();
            ctx.translate(shakeX, shakeY);

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Spawn new letter if needed
            if (now - progressGame.lastSpawnTime > progressGame.spawnDelay) {
                spawnFallingLetter();
                progressGame.lastSpawnTime = now;
            }

            // Update and draw falling letters
            progressGame.fallingLetters = progressGame.fallingLetters.filter(letter => {
                letter.y += letter.speed;

                // Remove if off screen
                if (letter.y > canvas.height + 50) {
                    return false;
                }

                // Draw letter
                ctx.save();
                ctx.font = 'bold 80px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Highlight correct letter in Level 2
                if (progressGame.currentLevel === 2 && letter.isTarget) {
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#F44336';
                    ctx.fillStyle = '#FDD835';
                } else {
                    ctx.fillStyle = '#FDD835';
                }

                ctx.fillText(letter.letter, letter.x, letter.y);
                ctx.restore();

                return true;
            });

            // Update and draw particles
            particleSystem.update();
            particleSystem.draw(ctx);

            ctx.restore(); // Restore from screen shake transform

            progressGame.animationFrame = requestAnimationFrame(gameLoop);
        }

        function spawnFallingLetter() {
            const currentBatchLetters = getCurrentBatchLetters();
            const currentLetter = currentBatchLetters[progressGame.currentLetterIndex];
            const mode = GAME_MODES[currentGameMode];

            if (progressGame.currentLevel === 1) {
                // Level 1: Spawn only current letter
                const x = Math.random() * (progressGame.canvas.width - 100) + 50;
                const letter = {
                    letter: currentLetter,
                    x: x,
                    y: -50,
                    speed: mode.speed,
                    isTarget: true
                };
                progressGame.fallingLetters.push(letter);

                // Play audio for the letter
                playLetterAudio(currentLetter);

            } else if (progressGame.currentLevel === 2) {
                // Level 2: Spawn 2-3 letters, only one is correct
                const numLetters = Math.random() > 0.5 ? 3 : 2;
                const targetIndex = Math.floor(Math.random() * numLetters);

                // Get previously mastered letters from current batch for distractors
                const masteredLetters = currentBatchLetters.slice(0, progressGame.currentLetterIndex + 1);
                const availableLetters = masteredLetters.filter(l => l !== currentLetter);

                for (let i = 0; i < numLetters; i++) {
                    const isTarget = i === targetIndex;
                    const letterToSpawn = isTarget ? currentLetter :
                        availableLetters[Math.floor(Math.random() * availableLetters.length)] || currentLetter;

                    const x = (i + 1) * (progressGame.canvas.width / (numLetters + 1));
                    const letter = {
                        letter: letterToSpawn,
                        x: x,
                        y: -50 - (i * 100),  // Stagger vertically
                        speed: mode.speed,
                        isTarget: isTarget
                    };
                    progressGame.fallingLetters.push(letter);
                }

                // Play audio for the TARGET letter only
                playLetterAudio(currentLetter);

            } else if (progressGame.currentLevel === 3) {
                // Level 3: Spawn single letter, no audio (must say it)
                const x = Math.random() * (progressGame.canvas.width - 100) + 50;
                const letter = {
                    letter: currentLetter,
                    x: x,
                    y: -50,
                    speed: mode.speed,
                    isTarget: true
                };
                progressGame.fallingLetters.push(letter);
            }
        }

        function playLetterAudio(letter) {
            const phoneme = PHONEMES.find(p => p.letter === letter);
            if (phoneme && phoneme.audioUrl) {
                const audio = new Audio(phoneme.audioUrl);
                audio.volume = 0.7;
                audio.play().catch(e => console.log('Audio play failed:', e));
            }
        }

        function handleCanvasClick(event) {
            if (!progressGame.running) return;

            // In calibration mode, ignore clicks (voice-triggered only)
            if (progressGame.calibrationMode) return;

            const rect = progressGame.canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            // Scale to canvas coordinates
            const scaleX = progressGame.canvas.width / rect.width;
            const scaleY = progressGame.canvas.height / rect.height;
            const x = clickX * scaleX;
            const y = clickY * scaleY;

            // Check if clicked on any letter
            for (let i = progressGame.fallingLetters.length - 1; i >= 0; i--) {
                const letter = progressGame.fallingLetters[i];
                const dx = x - letter.x;
                const dy = y - letter.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 50) {  // Hit radius
                    handleLetterHit(letter, i);
                    break;
                }
            }
        }

        function handleLetterHit(letter, index) {
            const currentBatchLetters = getCurrentBatchLetters();
            const currentLetter = currentBatchLetters[progressGame.currentLetterIndex];
            const isCorrect = (progressGame.currentLevel === 2) ? letter.isTarget : (letter.letter === currentLetter);

            if (isCorrect) {
                // Remove the letter
                progressGame.fallingLetters.splice(index, 1);

                // Create explosion effect
                createProgressExplosion(letter.x, letter.y);

                // Update progress
                const levelKey = `level${progressGame.currentLevel}`;
                progressGame.letterProgress[currentLetter][levelKey]++;
                progressGame.score += 10;

                // Check if letter is mastered at this level
                if (progressGame.letterProgress[currentLetter][levelKey] >= progressGame.hitsNeeded) {
                    letterMasteredAtLevel(currentLetter);
                }

                updateProgressUI();
                saveProgressGameData();
            } else {
                // Wrong letter clicked
                document.getElementById('progressStatus').textContent = `‚ùå That's ${letter.letter}, not ${currentLetter}!`;
                setTimeout(() => updateProgressInstructions(), 1500);
            }
        }

        function createProgressExplosion(x, y) {
            const mode = GAME_MODES[currentGameMode];

            // Create particle explosion based on current mode
            particleSystem.explode(x, y, mode.particleColors, mode.particleCount, mode.particleSpeed);

            // Apply screen shake if mode has it enabled
            if (mode.screenShake) {
                progressGame.shakeIntensity = 15;
            }
        }

        function letterMasteredAtLevel(letter) {
            const levelKey = `level${progressGame.currentLevel}`;
            const currentBatchLetters = getCurrentBatchLetters();
            const batchNames = ['Vowels (A,E,I,O,U)', 'Consonants 1 (B,C,D,F,G)', 'Consonants 2 (H,J,K,L,M)',
                               'Consonants 3 (N,P,Q,R,S)', 'Consonants 4 (T,V,W,X,Y,Z)'];
            const mode = GAME_MODES[currentGameMode];

            document.getElementById('progressStatus').textContent =
                `üéâ ${letter} mastered at Level ${progressGame.currentLevel}!`;

            // Show confetti if mode enables it
            if (mode.confettiOnMastery) {
                particleSystem.confetti(progressGame.canvas.width / 2, progressGame.canvas.height / 2, 80);
            }

            // Move to next letter in current batch
            progressGame.currentLetterIndex++;

            if (progressGame.currentLetterIndex >= currentBatchLetters.length) {
                // All letters in batch done at this level
                if (progressGame.currentLevel < 3) {
                    // Move to next level with same batch
                    progressGame.currentLevel++;
                    progressGame.currentLetterIndex = 0;
                    document.getElementById('progressStatus').textContent =
                        `üèÜ ${batchNames[progressGame.currentBatch]} - Level ${progressGame.currentLevel - 1} Complete! Moving to Level ${progressGame.currentLevel}!`;

                    // Start voice analysis for Level 3
                    if (progressGame.currentLevel === 3 && !progressGame.audioAnalysisFrame) {
                        analyzeProgressAudio();
                    }
                } else {
                    // Level 3 complete for this batch!
                    if (progressGame.currentBatch < progressGame.batches.length - 1) {
                        // Move to next batch
                        progressGame.currentBatch++;
                        progressGame.currentLevel = 1;
                        progressGame.currentLetterIndex = 0;
                        document.getElementById('progressStatus').textContent =
                            `üéä ${batchNames[progressGame.currentBatch - 1]} COMPLETE! Unlocking ${batchNames[progressGame.currentBatch]}!`;
                    } else {
                        // ALL BATCHES COMPLETE!
                        stopProgressGame();
                        document.getElementById('progressStatus').textContent =
                            `üéä CONGRATULATIONS! You've mastered ALL 26 letters at ALL 3 levels! üéä`;
                        return;
                    }
                }
            }

            updateProgressInstructions();
            updateProgressUI();
            saveProgressGameData();
        }

        function updateProgressInstructions() {
            const currentBatchLetters = getCurrentBatchLetters();
            const currentLetter = currentBatchLetters[progressGame.currentLetterIndex];
            const batchNames = ['Vowels', 'Consonants 1', 'Consonants 2', 'Consonants 3', 'Consonants 4'];

            if (progressGame.currentLevel === 1) {
                document.getElementById('progressGameTitle').textContent = `üéÆ Level 1: Listen & Hit - ${batchNames[progressGame.currentBatch]}`;
                document.getElementById('progressGameInstructions').textContent =
                    `Listen to the sound and TAP the letter ${currentLetter} when it falls!`;
                document.getElementById('progressStatus').textContent =
                    `üéß Listen for "${currentLetter}" and tap it!`;
            } else if (progressGame.currentLevel === 2) {
                document.getElementById('progressGameTitle').textContent = `üéØ Level 2: Listen & Choose - ${batchNames[progressGame.currentBatch]}`;
                document.getElementById('progressGameInstructions').textContent =
                    `Multiple letters fall - TAP the one that matches the sound you hear!`;
                document.getElementById('progressStatus').textContent =
                    `üéß Which letter makes the sound? Tap ${currentLetter}!`;
            } else if (progressGame.currentLevel === 3) {
                document.getElementById('progressGameTitle').textContent = `üé§ Level 3: Say & Hit - ${batchNames[progressGame.currentBatch]}`;
                document.getElementById('progressGameInstructions').textContent =
                    `SAY the letter sound out loud, then TAP it!`;
                document.getElementById('progressStatus').textContent =
                    `üé§ Say "${currentLetter}" and tap it!`;
            }
        }

        function updateProgressUI() {
            // Exit early if Progressive Game DOM elements don't exist (happens when Game tab uses Tuner layout)
            if (!document.getElementById('currentLevel') || !document.getElementById('progressLetterGrid')) {
                return;
            }

            const currentBatchLetters = getCurrentBatchLetters();
            const allLetters = getAllLetters();

            document.getElementById('currentLevel').textContent = progressGame.currentLevel;
            document.getElementById('currentLetterDisplay').textContent =
                currentBatchLetters[progressGame.currentLetterIndex] || '‚úì';
            document.getElementById('progressScore').textContent = progressGame.score;

            // Count mastered letters across all batches
            let level1Count = 0, level2Count = 0, level3Count = 0;
            allLetters.forEach(letter => {
                const progress = progressGame.letterProgress[letter];
                if (progress) {
                    if (progress.level1 >= progressGame.hitsNeeded) level1Count++;
                    if (progress.level2 >= progressGame.hitsNeeded) level2Count++;
                    if (progress.level3 >= progressGame.hitsNeeded) level3Count++;
                }
            });

            document.getElementById('lettersMastered').textContent = level1Count + level2Count + level3Count;
            document.getElementById('level1Progress').textContent = `${level1Count}/26`;
            document.getElementById('level2Progress').textContent = `${level2Count}/26`;
            document.getElementById('level3Progress').textContent = `${level3Count}/26`;

            // Update letter grid - show all letters
            const grid = document.getElementById('progressLetterGrid');
            grid.innerHTML = '';
            allLetters.forEach(letter => {
                const badge = document.createElement('div');
                badge.className = 'progress-letter-badge';
                badge.textContent = letter;

                const progress = progressGame.letterProgress[letter];
                if (progress) {
                    if (progress.level3 >= progressGame.hitsNeeded) {
                        badge.classList.add('level3');
                    } else if (progress.level2 >= progressGame.hitsNeeded) {
                        badge.classList.add('level2');
                    } else if (progress.level1 >= progressGame.hitsNeeded) {
                        badge.classList.add('level1');
                    }
                }

                grid.appendChild(badge);
            });
        }

        // COPIED FROM TUNER - PROVEN TO WORK!
        function analyzeProgressAudio() {
            // Run for Level 3 OR calibration mode
            if (!progressGame.running || (progressGame.currentLevel !== 3 && !progressGame.calibrationMode)) {
                return;
            }

            if (!analyser || !dataArray) {
                console.error('‚ùå No analyser or dataArray!');
                return;
            }

            analyser.getByteFrequencyData(dataArray);

            // Calculate volume (same as Tuner)
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volumePercent = (sum / dataArray.length / 128) * 100;
            const volume = Math.max(...dataArray); // Peak volume for detection

            // Update volume meter
            const volumeBar = document.getElementById('volumeBar');
            const micStatus = document.getElementById('micStatus');
            const volumeDebug = document.getElementById('volumeDebug');

            if (volumeBar) {
                volumeBar.style.width = volumePercent + '%';
            }

            if (volumeDebug) {
                volumeDebug.textContent = `Volume: ${Math.round(volume)}/255 (${Math.round(volumePercent)}%)`;
            }

            // Update mic status indicator
            if (micStatus) {
                if (volume > 80) {
                    micStatus.textContent = '‚óè VOICE DETECTED';
                    micStatus.style.color = '#F44336';
                } else if (volume > 40) {
                    micStatus.textContent = '‚óè SPEAKING';
                    micStatus.style.color = '#FDD835';
                } else if (volume > 10) {
                    micStatus.textContent = '‚óè AMBIENT';
                    micStatus.style.color = '#2196F3';
                } else {
                    micStatus.textContent = '‚óè LISTENING';
                    micStatus.style.color = '#4CAF50';
                }
            }

            // ALWAYS add current frame to buffer (sliding window) - SAME AS TUNER
            const pattern = downsampleFrequencies(dataArray, PATTERN_BINS);
            progressGame.patternBuffer.push(pattern);

            // Keep buffer at PATTERN_LENGTH
            if (progressGame.patternBuffer.length > PATTERN_LENGTH) {
                progressGame.patternBuffer.shift();
            }

            // Check energy concentration (speech vs background noise)
            const peakEnergy = Math.max(...pattern);
            const avgEnergy = pattern.reduce((a, b) => a + b, 0) / pattern.length;
            const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;

            const currentBatchLetters = getCurrentBatchLetters();
            const currentLetter = currentBatchLetters[progressGame.currentLetterIndex];

            // Dynamic thresholds (COPIED FROM TUNER)
            const FRICATIVES = ['f', 's', 'v', 'z', 'h'];
            const LIQUIDS = ['l', 'r'];
            const isCurrentNasal = currentLetter && isNasal(currentLetter);
            const isFricative = currentLetter && FRICATIVES.includes(currentLetter);
            const isLiquid = currentLetter && LIQUIDS.includes(currentLetter);

            let volumeThreshold = 15;
            let concentrationThreshold = 2.0;

            if (isCurrentNasal || isLiquid) {
                volumeThreshold = 4;
                concentrationThreshold = 1.5;
            } else if (isFricative) {
                volumeThreshold = 10;
                concentrationThreshold = 1.8;
            }

            // ===== AUTO-CALIBRATION MODE (voice-triggered explosions) =====
            if (progressGame.calibrationMode && currentLetter) {
                // Use Tuner's detection logic!
                if (progressGame.patternBuffer.length === PATTERN_LENGTH &&
                    volume > volumeThreshold &&
                    energyConcentration > concentrationThreshold &&
                    !progressGame.currentRecorder) {

                    // Voice detected! Start recording
                    const pattern = extractPattern(dataArray);
                    progressGame.calibrationRecordings.push(pattern);

                    startVoiceRecording();

                    // Find closest letter and trigger explosion
                    let closestLetter = null;
                    let closestIndex = -1;
                    let minDist = Infinity;

                    progressGame.fallingLetters.forEach((letter, index) => {
                        if (letter.letter === currentLetter) {
                            const centerDist = Math.abs(letter.y - progressGame.canvas.height / 2);
                            if (centerDist < minDist) {
                                minDist = centerDist;
                                closestLetter = letter;
                                closestIndex = index;
                            }
                        }
                    });

                    if (closestLetter && closestIndex !== -1) {
                        // Remove the letter
                        progressGame.fallingLetters.splice(closestIndex, 1);

                        // Create explosion effect
                        createProgressExplosion(closestLetter.x, closestLetter.y);

                        // Continue recording for 700ms, then stop
                        setTimeout(() => {
                            stopVoiceRecording();

                            progressGame.calibrationCount++;
                            console.log(`‚úÖ Recorded ${progressGame.calibrationCount}/${progressGame.calibrationTarget}`);

                            document.getElementById('progressStatus').textContent =
                                `üé§ Great! Say "${currentLetter}" again! (${progressGame.calibrationCount}/${progressGame.calibrationTarget})`;

                            if (progressGame.calibrationCount >= progressGame.calibrationTarget) {
                                // Done! Process calibrations
                                setTimeout(() => finishAutoCalibration(currentLetter), 500);
                            }
                        }, 700);
                    }
                }
            }
            // ===== LEVEL 3 MODE (normal voice recognition) - COPIED FROM TUNER =====
            else if (progressGame.currentLevel === 3 && currentLetter && !progressGame.calibrationMode) {
                // Same detection logic as Tuner!
                if (progressGame.patternBuffer.length === PATTERN_LENGTH &&
                    volume > volumeThreshold &&
                    energyConcentration > concentrationThreshold) {

                    // Run S11-Snapshot detection (same as Tuner)
                    const results = testAllPlosiveStrategies(progressGame.patternBuffer, currentLetter);
                    const result = results[0];
                    const score = Math.max(0, Math.min(100, result.score || 0));
                    const prediction = result.predictedLetter || '?';
                    const isCorrect = prediction === currentLetter;

                    // Success if predicted correctly AND score > 80%
                    if (isCorrect && score > 80) {
                        console.log(`üéØ MATCH! ${currentLetter} detected with ${Math.round(score)}% confidence`);

                        // Find closest falling letter
                        let closestLetter = null;
                        let closestIndex = -1;
                        let minDist = Infinity;

                        progressGame.fallingLetters.forEach((letter, index) => {
                            if (letter.letter === currentLetter) {
                                const centerDist = Math.abs(letter.y - progressGame.canvas.height / 2);
                                if (centerDist < minDist) {
                                    minDist = centerDist;
                                    closestLetter = letter;
                                    closestIndex = index;
                                }
                            }
                        });

                        if (closestLetter && closestIndex !== -1) {
                            // Remove letter and trigger explosion!
                            progressGame.fallingLetters.splice(closestIndex, 1);
                            createProgressExplosion(closestLetter.x, closestLetter.y);

                            // Update progress (same as clicking)
                            const levelKey = `level${progressGame.currentLevel}`;
                            progressGame.letterProgress[currentLetter][levelKey]++;
                            progressGame.score += 10;

                            // Check if letter is mastered
                            if (progressGame.letterProgress[currentLetter][levelKey] >= progressGame.hitsNeeded) {
                                letterMasteredAtLevel(currentLetter);
                            }

                            updateProgressUI();
                            saveProgressGameData();
                        }

                        // Clear buffer after successful match
                        progressGame.patternBuffer = [];
                    }
                }
            }

            progressGame.audioAnalysisFrame = requestAnimationFrame(analyzeProgressAudio);
        }

        // Initialize on load
        loadProgressGameData();

        // ============================================
        // MAIN INITIALIZATION
        // ============================================
        (async () => {
            // Set up auth state listener
            handleAuthStateChange();

            // Check if user is authenticated
            const { data: { session } } = await supabase.auth.getSession();

            if (session?.user) {
                // Authenticated user - load their profiles
                console.log('‚úÖ Authenticated user:', session.user.email);
                await loadUserProfiles(session.user.id);
            } else {
                // Guest user - check for named profile first, then guest profile
                const savedProfileName = localStorage.getItem('currentProfile');

                if (savedProfileName && savedProfileName !== 'Default') {
                    // Has a saved named profile - load it
                    console.log('üìù Loading named profile:', savedProfileName);
                    currentProfile = savedProfileName;

                    const profile = await getOrCreateProfile(savedProfileName);
                    if (profile) {
                        currentProfileId = profile.id;
                        console.log(`‚úÖ Loaded profile: ${savedProfileName} (${profile.id.substring(0, 8)}...)`);
                    }
                } else {
                    // No named profile - use anonymous guest system
                    console.log('üìù Guest mode - creating anonymous profile');

                    // Check if we have a saved guest profile ID
                    const savedGuestId = localStorage.getItem('guestProfileId');
                    console.log('üîç Checking localStorage for guestProfileId:', savedGuestId);

                    if (savedGuestId) {
                        // Try to load existing guest profile
                        console.log('‚úì Found saved guest profile, attempting to load:', savedGuestId);
                        try {
                            const { data: existingProfile, error } = await supabase
                                .from('profiles')
                                .select('*')
                                .eq('id', savedGuestId)
                                .is('user_id', null)
                                .single();

                            if (error) {
                                console.error('‚ùå Error loading guest profile:', error);
                                throw error;
                            }

                            if (existingProfile) {
                                currentProfileId = existingProfile.id;
                                guestProfileId = existingProfile.id;
                                console.log('‚úÖ Loaded existing guest profile:', existingProfile.id);
                            } else {
                                console.log('‚ö†Ô∏è Profile not found, creating new');
                                await createAnonymousProfile();
                            }
                        } catch (error) {
                            console.error('‚ö†Ô∏è Failed to load guest profile, creating new:', error.message);
                            await createAnonymousProfile();
                        }
                    } else {
                        // No saved profile - create new anonymous profile
                        console.log('üÜï No saved profile, creating new');
                        await createAnonymousProfile();
                    }
                }
            }

            // Load calibration data
            await loadCalibration();

            // Load profile dropdown
            loadProfiles();

            // Create calibration grid
            createCalibrationGrid();
            updateCalibrationStats();

            // Initialize training correction buttons
            initTrainingButtons();
        })();

        async function createAnonymousProfile() {
            try {
                const { data: newProfile, error } = await supabase
                    .from('profiles')
                    .insert([{
                        name: `Guest_${Date.now()}`,
                        user_id: null  // Explicitly anonymous
                    }])
                    .select()
                    .single();

                if (error) throw error;

                currentProfileId = newProfile.id;
                guestProfileId = newProfile.id;

                // Save to localStorage
                localStorage.setItem('guestProfileId', newProfile.id);

                console.log('‚úÖ Created anonymous profile:', newProfile.id);
            } catch (error) {
                console.error('‚ùå Error creating anonymous profile:', error);
            }
        }

        // Initialize Lucide icons when DOM is loaded
        if (typeof lucide !== 'undefined') {
            setTimeout(() => {
                lucide.createIcons();
            }, 100);
        }

        // Flush pending scores before page unload
        window.addEventListener('beforeunload', (event) => {
            if (pendingSaves.size > 0) {
                console.log('‚ö†Ô∏è Page unloading with pending saves, flushing...');
                // Use sendBeacon for reliable save on page unload
                flushAllPendingScores();
            }
        });

    </script>
</body>
</html>
