<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phonics Pattern Matcher</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
            color: white;
        }
        h1 {
            font-size: 48px;
            margin: 20px 0;
            text-shadow: 0 0 20px rgba(124, 179, 66, 0.8);
        }
        .subtitle {
            font-size: 16px;
            color: #ddd;
            margin-bottom: 20px;
        }
        .container {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 30px;
            padding: 40px;
            width: 900px;
            max-width: 95vw;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }
        .tab {
            padding: 15px 30px;
            background: transparent;
            border: none;
            color: #aaa;
            font-size: 18px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        .tab.active {
            color: #FDD835;
            border-bottom-color: #FDD835;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        /* Calibration */
        .calibration-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .phoneme-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
        }
        .phoneme-card:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        .phoneme-card.recording {
            border-color: #F44336;
            background: rgba(244, 67, 54, 0.2);
            animation: pulse 1s infinite;
        }
        .phoneme-card.calibrated {
            border-color: #7CB342;
            background: rgba(124, 179, 66, 0.2);
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }
        .phoneme-letter {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .phoneme-hint {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 5px;
        }
        .phoneme-status {
            font-size: 12px;
            margin-top: 10px;
        }

        /* Snapshot thumbnails */
        .snapshots-container {
            display: flex;
            gap: 4px;
            margin-top: 10px;
            justify-content: center;
            min-height: 40px;
        }
        .snapshot-thumb {
            width: 50px;
            height: 40px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            border: 1px solid rgba(124, 179, 66, 0.3);
        }
        .snapshot-thumb.captured {
            border-color: #7CB342;
        }

        /* Pattern visualization */
        .pattern-preview {
            width: 100%;
            height: 60px;
            margin-top: 10px;
            border-radius: 5px;
            overflow: hidden;
        }

        /* Tuner */
        #detectedLetter {
            text-align: center;
            font-size: 180px;
            font-weight: bold;
            color: #7CB342;
            margin: 30px 0;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 10px 30px rgba(124, 179, 66, 0.5);
            transition: all 0.15s;
        }
        #detectedLetter.active {
            transform: scale(1.1);
            color: #FDD835;
            text-shadow: 0 0 50px rgba(253, 216, 53, 0.8);
        }
        .confidence-bar {
            width: 100%;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }
        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #7CB342, #FDD835);
            width: 0%;
            transition: width 0.1s;
        }
        #spectrumCanvas {
            width: 100%;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 20px 0;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            font-size: 14px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #FDD835;
        }
        .btn {
            padding: 12px 30px;
            background: #7CB342;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn:hover {
            background: #689F38;
        }
        .actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        .info-box {
            background: rgba(124, 179, 66, 0.1);
            border-left: 4px solid #7CB342;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            font-size: 14px;
            line-height: 1.6;
        }
        #status {
            text-align: center;
            font-size: 14px;
            color: #999;
            margin: 15px 0;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        .level1-letter {
            text-align: center;
            font-size: 180px;
            font-weight: bold;
            color: #FDD835;
            margin: 30px 0;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 10px 30px rgba(253, 216, 53, 0.5);
        }
        .level1-instruction {
            text-align: center;
            font-size: 24px;
            color: #ddd;
            margin: 20px 0;
            min-height: 40px;
        }
    </style>
</head>
<body>
    <h1>üé∏ Phonics Pattern Matcher</h1>
    <div class="subtitle">Waveform pattern matching - captures the actual sound "fingerprint"</div>

    <!-- Profile Selector -->
    <div style="text-align: center; margin: 20px 0; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 10px;">
        <label style="color: #aaa; margin-right: 10px;">üë§ Profile:</label>
        <select id="profileSelect" onchange="switchProfile()" style="padding: 8px 15px; font-size: 16px; border-radius: 5px; background: #2a2a2a; color: white; border: 1px solid #555;">
        </select>
        <button onclick="createNewProfile()" style="margin-left: 10px; padding: 8px 15px; background: #7CB342; color: white; border: none; border-radius: 5px; cursor: pointer;">‚ûï New Profile</button>
    </div>

    <div class="container">
        <div class="tabs">
            <button class="tab active" onclick="switchTab('calibrate')">üìä Calibrate</button>
            <button class="tab" onclick="switchTab('level1')">üéì Level 1</button>
            <button class="tab" onclick="switchTab('tuner')">üéØ Tuner</button>
            <button class="tab" onclick="switchTab('game')">üéÆ Game</button>
        </div>

        <!-- Calibration Tab -->
        <div id="calibrate" class="tab-content active">
            <div class="info-box">
                <strong>Pattern-Based Calibration</strong><br>
                Say each phoneme 3-4 times while recording. The system captures the actual waveform pattern (like a fingerprint).<br>
                This preserves the SHAPE of the sound, not just statistics.
            </div>

            <div class="calibration-grid" id="calibrationGrid"></div>

            <div id="calibrationPauseArea" style="text-align: center; margin: 20px 0; min-height: 60px; display: none;">
                <div style="font-size: 18px; color: #FDD835; margin-bottom: 10px;">Great! Take a breath...</div>
                <button class="btn" onclick="continueCalibration()" style="background: #7CB342; font-size: 18px;">‚úì Ready for next one</button>
            </div>

            <div class="actions">
                <button class="btn" onclick="resetCalibration()">üîÑ Reset All</button>
                <button class="btn" onclick="exportCalibration()">üíæ Export Calibration</button>
            </div>

            <div id="calibrationStats" style="margin-top: 20px; text-align: center; color: #aaa;"></div>
        </div>

        <!-- Level 1 Tab -->
        <div id="level1" class="tab-content">
            <div class="info-box">
                <strong>üéì Level 1: Listen & Learn</strong><br>
                Learn the vowels A, E, I, O, U by listening and practicing!
            </div>

            <div class="level1-instruction" id="level1Instruction">
                Click START to begin!
            </div>

            <div class="level1-letter" id="level1Letter">?</div>

            <div class="confidence-bar">
                <div class="confidence-fill" id="level1ConfidenceFill"></div>
            </div>

            <div class="stats">
                <div class="stat-item">
                    <div>Progress</div>
                    <div class="stat-value" id="level1Progress">0/5</div>
                </div>
                <div class="stat-item">
                    <div>Mode</div>
                    <div class="stat-value" id="level1Mode">Listen</div>
                </div>
            </div>

            <canvas id="level1SpectrumCanvas" style="width: 100%; height: 120px; background: rgba(0, 0, 0, 0.3); border-radius: 10px; margin: 20px 0;"></canvas>

            <div id="level1Status" style="font-family: monospace; font-size: 11px; white-space: pre-wrap; line-height: 1.4; text-align: center; margin: 20px 0;">Ready to start</div>

            <div class="actions">
                <button class="btn" id="level1Btn" onclick="toggleLevel1()">‚ñ∂ Start Level 1</button>
            </div>
        </div>

        <!-- Tuner Tab (Flashcard Mode) -->
        <div id="tuner" class="tab-content">
            <div style="text-align: center; margin-bottom: 20px; color: #ddd; font-size: 18px;">
                <strong>Flashcard Practice</strong>
            </div>

            <div style="text-align: center; margin-bottom: 15px;">
                <div id="masteryProgress" style="color: #7CB342; font-size: 16px; margin-bottom: 10px;">
                    Mastered: <span id="masteredCount">0</span>/26 letters
                    <span id="unlockStatus" style="margin-left: 15px; color: #FDD835; display: none;">üéâ Game Unlocked!</span>
                </div>
                <div style="color: #aaa; font-size: 14px;">
                    Goal: Say each letter without clicking LISTEN to unlock the game!
                </div>
            </div>

            <div id="targetLetter" style="text-align: center; font-size: 180px; font-weight: bold; color: #FDD835; margin: 20px 0; text-shadow: 0 10px 30px rgba(253, 216, 53, 0.5); transition: all 0.3s;">?</div>

            <div style="text-align: center; margin: 20px 0;">
                <button class="btn" onclick="playLetterSound()" style="background: #00BCD4; font-size: 20px; padding: 15px 40px;">
                    üîä LISTEN
                </button>
                <div id="listenCount" style="margin-top: 10px; color: #aaa; font-size: 14px;">
                    Listened: <span id="currentLetterListens">0</span> times for this letter
                </div>
            </div>

            <div class="confidence-bar">
                <div class="confidence-fill" id="confidenceFill"></div>
            </div>

            <div class="stats">
                <div class="stat-item">
                    <div>Match Score</div>
                    <div class="stat-value" id="matchScore">0%</div>
                </div>
                <div class="stat-item">
                    <div>Volume</div>
                    <div class="stat-value" id="volume">0%</div>
                </div>
            </div>

            <canvas id="spectrumCanvas"></canvas>

            <div id="status" style="font-family: monospace; font-size: 11px; white-space: pre-wrap; line-height: 1.4;">Click Start to begin</div>

            <div class="actions">
                <button class="btn" id="tunerBtn" onclick="toggleTuner()">‚ñ∂ Start Game</button>
                <button class="btn" onclick="tryAgain()" style="background: #7CB342; display: none;" id="tryAgainBtn">üîÑ Try Again</button>
                <button class="btn" onclick="skipLetter()" style="background: #999;">Skip</button>
            </div>

            <div class="actions" style="margin-top: 15px;">
                <button class="btn" onclick="viewStats()" style="background: #5E35B1;">üìä View Stats (<span id="trialsCount">0</span> trials)</button>
                <button class="btn" onclick="exportResults()" style="background: #00897B;">üíæ Export Results</button>
            </div>
        </div>

        <!-- Game Tab -->
        <div id="game" class="tab-content">
            <div class="info-box">
                <strong>üéÆ Letter Defender</strong><br>
                Letters fall from the top - say the letter closest to the bottom before it hits!<br>
                3 lives ‚Ä¢ Speed increases every 10 matches ‚Ä¢ 80% accuracy required
            </div>

            <div style="text-align: center; margin: 20px 0;">
                <div style="display: inline-block; margin: 0 20px;">
                    <div style="color: #aaa; font-size: 14px;">Score</div>
                    <div style="color: #FDD835; font-size: 36px; font-weight: bold;" id="gameScore">0</div>
                </div>
                <div style="display: inline-block; margin: 0 20px;">
                    <div style="color: #aaa; font-size: 14px;">Lives</div>
                    <div style="color: #F44336; font-size: 36px; font-weight: bold;" id="gameLives">3</div>
                </div>
                <div style="display: inline-block; margin: 0 20px;">
                    <div style="color: #aaa; font-size: 14px;">Speed</div>
                    <div style="color: #7CB342; font-size: 36px; font-weight: bold;" id="gameSpeed">1x</div>
                </div>
            </div>

            <canvas id="gameCanvas" style="width: 400px; height: 700px; background: rgba(0,0,0,0.3); border-radius: 10px; display: block; margin: 0 auto;"></canvas>

            <div style="margin-top: 20px;">
                <div style="display: flex; gap: 20px; align-items: center; margin-bottom: 15px;">
                    <div style="flex: 1;">
                        <div style="color: #aaa; font-size: 12px; margin-bottom: 5px;">Voice Detection</div>
                        <div class="confidence-bar">
                            <div class="confidence-fill" id="gameVolumeFill"></div>
                        </div>
                    </div>
                    <div style="text-align: center; min-width: 80px;">
                        <div style="color: #aaa; font-size: 12px;">Volume</div>
                        <div style="color: #FDD835; font-size: 24px; font-weight: bold;" id="gameVolume">0%</div>
                    </div>
                </div>
                <canvas id="gameSpectrumCanvas" style="width: 100%; height: 100px; background: rgba(0,0,0,0.3); border-radius: 10px; display: block;"></canvas>
            </div>

            <div style="text-align: center; margin-top: 20px; font-family: monospace; color: #ddd; min-height: 40px;" id="gameStatus">Click Start to begin</div>

            <div class="actions">
                <button class="btn" id="gameBtn" onclick="toggleGame()">‚ñ∂ Start Game</button>
                <button class="btn" onclick="restartGame()" style="background: #F44336;">üîÑ Restart</button>
            </div>
        </div>
    </div>

    <script>
        let audioContext;
        let analyser;
        let microphone;
        let mediaRecorder;
        let audioChunks = [];
        let dataArray;
        let isRunning = false;
        let isRecording = false;
        let recordingPhoneme = null;
        let recordedPatterns = [];
        let calibrationData = {};
        let audioRecordings = {};
        let isPausedBetweenSnapshots = false;

        // Flashcard tracking
        let attemptHistory = {}; // { letter: [{ timestamp, listenedFirst: bool, success: bool }] }
        let listenClicksThisAttempt = 0;
        let masteredLetters = new Set(); // Letters that can be said without LISTEN

        const canvas = document.getElementById('spectrumCanvas');
        const canvasCtx = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = 240;

        // Full phoneme list - All 26 letters in alphabetical order
        const PHONEMES = [
            { letter: 'A', hint: 'Say: aaa (like "apple")', type: 'vowel', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-a.mp3' },
            { letter: 'B', hint: 'Repeat: buh, buh', type: 'plosive', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-b.mp3' },
            { letter: 'C', hint: 'Repeat: cuh, cuh (like "cat")', type: 'plosive', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-c.mp3' },
            { letter: 'D', hint: 'Repeat: duh, duh (like "dog")', type: 'plosive', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-d.mp3' },
            { letter: 'E', hint: 'Say: eee (like "egg")', type: 'vowel', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-e.mp3' },
            { letter: 'F', hint: 'Say: fff (like "fan")', type: 'fricative', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-f.mp3' },
            { letter: 'G', hint: 'Repeat: guh, guh (like "go")', type: 'plosive', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-g.mp3' },
            { letter: 'H', hint: 'Say: hhh (like "hat")', type: 'fricative', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-h.mp3' },
            { letter: 'I', hint: 'Say: iii (like "igloo")', type: 'vowel', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-i.mp3' },
            { letter: 'J', hint: 'Say: juh (like "jump")', type: 'affricate', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-j.mp3' },
            { letter: 'K', hint: 'Repeat: kuh, kuh', type: 'plosive', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-k.mp3' },
            { letter: 'L', hint: 'Say: lll (like "lion")', type: 'liquid', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-l.mp3' },
            { letter: 'M', hint: 'Say: mmm (hum)', type: 'nasal', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-m.mp3' },
            { letter: 'N', hint: 'Say: nnn (like "no")', type: 'nasal', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-n.mp3' },
            { letter: 'O', hint: 'Say: ooo (like "octopus")', type: 'vowel', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-o-sh.mp3' },
            { letter: 'P', hint: 'Repeat: puh, puh', type: 'plosive', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-p-2.mp3' },
            { letter: 'Q', hint: 'Say: kwuh (like "queen")', type: 'affricate', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-q.mp3' },
            { letter: 'R', hint: 'Say: rrr (like "run")', type: 'liquid', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-r.mp3' },
            { letter: 'S', hint: 'Say: sss (like "snake")', type: 'fricative', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-z.mp3' },
            { letter: 'T', hint: 'Repeat: tuh, tuh', type: 'plosive', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-t.mp3' },
            { letter: 'U', hint: 'Say: uuu (like "umbrella")', type: 'vowel', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-u-sh.mp3' },
            { letter: 'V', hint: 'Say: vvv (like "van")', type: 'fricative', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-v.mp3' },
            { letter: 'W', hint: 'Say: www (like "water")', type: 'semivowel', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-w.mp3' },
            { letter: 'X', hint: 'Say: ks (like "fox")', type: 'affricate', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-x.mp3' },
            { letter: 'Y', hint: 'Say: yuh (like "yes")', type: 'semivowel', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/btalpha-i-long.mp3' },
            { letter: 'Z', hint: 'Say: zzz (like "zoo")', type: 'fricative', audioUrl: 'https://www.soundcityreading.net/uploads/3/7/6/1/37611941/alphasounds-z.mp3' }
        ];

        const PLOSIVES = ['B', 'C', 'D', 'G', 'K', 'P', 'T'];
        const NASALS = ['M', 'N'];

        function isPlosive(letter) {
            return PLOSIVES.includes(letter);
        }

        function isNasal(letter) {
            return NASALS.includes(letter);
        }

        // Pattern matching parameters
        const PATTERN_LENGTH = 30; // Number of frequency snapshots
        const PATTERN_BINS = 64;   // Number of frequency bins per snapshot

        // Profile management
        let currentProfile = 'Default';

        function loadProfiles() {
            const saved = localStorage.getItem('phonicsProfiles');
            const profiles = saved ? JSON.parse(saved) : ['Default'];

            const select = document.getElementById('profileSelect');
            select.innerHTML = '';

            profiles.forEach(profile => {
                const option = document.createElement('option');
                option.value = profile;
                option.textContent = profile;
                if (profile === currentProfile) {
                    option.selected = true;
                }
                select.appendChild(option);
            });

            return profiles;
        }

        function saveProfiles(profiles) {
            localStorage.setItem('phonicsProfiles', JSON.stringify(profiles));
        }

        function switchProfile() {
            const select = document.getElementById('profileSelect');
            currentProfile = select.value;
            localStorage.setItem('currentProfile', currentProfile);

            // Load calibration for this profile
            loadCalibration();
            loadAudioRecordings();
            loadAttemptHistory();
            createCalibrationGrid();
            updateMasteryUI();
        }

        function createNewProfile() {
            const name = prompt('Enter profile name (e.g., "Emma", "Sofia"):');
            if (!name || name.trim() === '') return;

            const profiles = loadProfiles();
            if (profiles.includes(name.trim())) {
                alert('Profile already exists!');
                return;
            }

            profiles.push(name.trim());
            saveProfiles(profiles);
            currentProfile = name.trim();
            localStorage.setItem('currentProfile', currentProfile);

            // Clear calibration for new profile
            calibrationData = {};
            audioRecordings = {};
            attemptHistory = {};
            masteredLetters = new Set();
            saveCalibration();
            saveAttemptHistory();

            loadProfiles();
            createCalibrationGrid();
            updateMasteryUI();
        }

        function loadCalibration() {
            const key = `phonicsPatterns_${currentProfile}`;
            const saved = localStorage.getItem(key);
            if (saved) {
                calibrationData = JSON.parse(saved);
                updateCalibrationUI();
            } else {
                calibrationData = {};
            }
        }

        function saveCalibration() {
            const key = `phonicsPatterns_${currentProfile}`;
            localStorage.setItem(key, JSON.stringify(calibrationData));
        }

        function createCalibrationGrid() {
            const grid = document.getElementById('calibrationGrid');
            grid.innerHTML = '';

            PHONEMES.forEach(phoneme => {
                const card = document.createElement('div');
                card.className = 'phoneme-card';
                card.id = `card-${phoneme.letter}`;

                const isCalibrated = calibrationData[phoneme.letter];
                if (isCalibrated) {
                    card.classList.add('calibrated');
                }

                card.innerHTML = `
                    <div class="phoneme-letter">${phoneme.letter}</div>
                    <div class="phoneme-hint">${phoneme.hint}</div>
                    ${phoneme.audioUrl ? `<div style="font-size: 30px; cursor: pointer; margin: 5px 0;" onclick="event.stopPropagation(); playPhonemeSound('${phoneme.letter}')" title="Listen to sound">üîä</div>` : ''}
                    <div class="snapshots-container" id="snapshots-${phoneme.letter}"></div>
                    <div class="phoneme-status">${isCalibrated ? '‚úì Calibrated' : 'Click to record'}</div>
                `;

                card.onclick = () => startCalibrationRecording(phoneme.letter);
                grid.appendChild(card);
            });
        }

        let capturedSnapshots = [];
        let lastPeakTime = 0;
        const SNAPSHOTS_NEEDED = 5;
        const PEAK_COOLDOWN = 500; // ms between peaks

        async function startCalibrationRecording(letter) {
            if (isRecording) return;

            if (!audioContext) {
                await setupAudio();
            }

            isRecording = true;
            recordingPhoneme = letter;
            capturedSnapshots = [];
            audioChunks = [];
            lastPeakTime = 0;

            if (microphone && microphone.stream) {
                mediaRecorder = new MediaRecorder(microphone.stream);
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                mediaRecorder.start();
            }

            const card = document.getElementById(`card-${letter}`);
            card.classList.add('recording');
            card.querySelector('.phoneme-status').textContent = `Say "${letter}" - 0/${SNAPSHOTS_NEEDED} captured`;

            // Create snapshot thumbnail canvases
            const snapshotsContainer = document.getElementById(`snapshots-${letter}`);
            snapshotsContainer.innerHTML = '';
            for (let i = 0; i < SNAPSHOTS_NEEDED; i++) {
                const canvas = document.createElement('canvas');
                canvas.className = 'snapshot-thumb';
                canvas.width = 50;
                canvas.height = 40;
                canvas.id = `snapshot-${letter}-${i}`;
                snapshotsContainer.appendChild(canvas);
            }

            // Start listening for peaks
            listenForPeaks(letter);
        }

        function listenForPeaks(letter) {
            if (!isRecording || recordingPhoneme !== letter || isPausedBetweenSnapshots) return;

            analyser.getByteFrequencyData(dataArray);

            // Calculate current volume
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volume = (sum / dataArray.length / 128) * 100;

            // SOLUTION 1: Dynamic volume threshold for nasals
            const volumeThreshold = isNasal(letter) ? 8 : 15;

            // Detect peak (loud moment after cooldown)
            const now = Date.now();
            if (volume > volumeThreshold && (now - lastPeakTime) > PEAK_COOLDOWN) {
                // SNAP! Capture this peak moment
                let snapshot = downsampleFrequencies(dataArray, PATTERN_BINS);

                // SOLUTION 5: Check energy concentration for nasals
                const peakEnergy = Math.max(...snapshot);
                const avgEnergy = snapshot.reduce((a, b) => a + b, 0) / snapshot.length;
                const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;
                const concentrationThreshold = isNasal(letter) ? 1.5 : 2.0;

                // Skip if energy too diffuse (likely background noise)
                if (energyConcentration < concentrationThreshold) {
                    requestAnimationFrame(() => listenForPeaks(letter));
                    return;
                }

                // SOLUTION 3: Pre-amplify nasal sounds before normalization
                if (isNasal(letter)) {
                    snapshot = snapshot.map(v => v * 2.0);
                }

                // Normalize to 0-1 range
                const maxVal = Math.max(...snapshot);
                const normalized = snapshot.map(v => v / maxVal);

                capturedSnapshots.push(normalized);
                const snapshotIndex = capturedSnapshots.length - 1;
                lastPeakTime = now;

                const card = document.getElementById(`card-${letter}`);
                card.querySelector('.phoneme-status').textContent = `‚úì Captured ${capturedSnapshots.length}/${SNAPSHOTS_NEEDED}`;

                // Draw snapshot thumbnail
                drawSnapshotThumbnail(letter, snapshotIndex, normalized);

                // Visual feedback
                card.style.transform = 'scale(1.05)';
                setTimeout(() => card.style.transform = 'scale(1)', 200);

                // Check if done
                if (capturedSnapshots.length >= SNAPSHOTS_NEEDED) {
                    isRecording = false;
                    finishCalibration(letter);
                    return;
                }

                // PAUSE after capturing snapshot - show continue button
                isPausedBetweenSnapshots = true;
                const pauseArea = document.getElementById('calibrationPauseArea');
                pauseArea.style.display = 'block';
                return;
            }

            // Keep listening
            requestAnimationFrame(() => listenForPeaks(letter));
        }

        function continueCalibration() {
            isPausedBetweenSnapshots = false;
            const pauseArea = document.getElementById('calibrationPauseArea');
            pauseArea.style.display = 'none';

            // Resume listening for the current letter
            if (recordingPhoneme) {
                listenForPeaks(recordingPhoneme);
            }
        }

        function drawSnapshotThumbnail(letter, index, snapshot) {
            const canvas = document.getElementById(`snapshot-${letter}-${index}`);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, width, height);

            // Draw spectrum bars
            const barWidth = width / snapshot.length;
            for (let i = 0; i < snapshot.length; i++) {
                const barHeight = snapshot[i] * height;
                const x = i * barWidth;
                const y = height - barHeight;

                // Green bars
                ctx.fillStyle = '#7CB342';
                ctx.fillRect(x, y, barWidth - 1, barHeight);
            }

            // Mark as captured
            canvas.classList.add('captured');
        }

        function downsampleFrequencies(fullData, targetBins) {
            // Reduce full frequency data to targetBins by averaging
            const pattern = [];
            const binSize = Math.floor(fullData.length / targetBins);

            for (let i = 0; i < targetBins; i++) {
                let sum = 0;
                const start = i * binSize;
                const end = Math.min(start + binSize, fullData.length);

                for (let j = start; j < end; j++) {
                    sum += fullData[j];
                }

                pattern.push(sum / binSize);
            }

            return pattern;
        }

        function finishCalibration(letter) {
            isRecording = false;
            isPausedBetweenSnapshots = false;
            document.getElementById('calibrationPauseArea').style.display = 'none';

            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    saveAudioRecording(letter, audioBlob);
                };
            }

            if (capturedSnapshots.length < 3) {
                alert('Not enough snapshots captured. Try again.');
                const card = document.getElementById(`card-${letter}`);
                card.classList.remove('recording');
                card.querySelector('.phoneme-status').textContent = 'Click to record';
                recordingPhoneme = null;
                capturedSnapshots = [];
                audioChunks = [];
                return;
            }

            // CLUSTERING: Find the most similar snapshots
            const cluster = findBestCluster(capturedSnapshots);

            // AVERAGE the cluster to create baseline
            const baseline = averageSnapshots(cluster);

            // Store as "pattern" (but it's just 1 peak snapshot, wrapped in array for compatibility)
            calibrationData[letter] = {
                pattern: [baseline], // Wrap in array for compatibility with existing code
                timestamp: Date.now()
            };

            saveCalibration();

            const card = document.getElementById(`card-${letter}`);
            card.classList.remove('recording');
            card.classList.add('calibrated');
            card.querySelector('.phoneme-status').textContent = '‚úì Calibrated';

            updateCalibrationStats();

            recordingPhoneme = null;
            capturedSnapshots = [];

            console.log(`Calibrated ${letter}: Used ${cluster.length}/${capturedSnapshots.length} snapshots`);
        }

        function findBestCluster(snapshots) {
            // Find the group of most similar snapshots (remove outliers)
            if (snapshots.length <= 3) return snapshots;

            // Calculate pairwise distances
            const distances = [];
            for (let i = 0; i < snapshots.length; i++) {
                for (let j = i + 1; j < snapshots.length; j++) {
                    const dist = calculateSnapshotDistance(snapshots[i], snapshots[j]);
                    distances.push({ i, j, dist });
                }
            }

            // Sort by distance (most similar first)
            distances.sort((a, b) => a.dist - b.dist);

            // Find the 3 snapshots that are most similar to each other
            // Strategy: Start with the most similar pair, add the closest 3rd
            const pair = distances[0]; // Most similar pair
            const candidates = [pair.i, pair.j];

            // Find closest snapshot to this pair
            let bestThird = null;
            let bestAvgDist = Infinity;

            for (let k = 0; k < snapshots.length; k++) {
                if (candidates.includes(k)) continue;

                const dist1 = calculateSnapshotDistance(snapshots[k], snapshots[candidates[0]]);
                const dist2 = calculateSnapshotDistance(snapshots[k], snapshots[candidates[1]]);
                const avgDist = (dist1 + dist2) / 2;

                if (avgDist < bestAvgDist) {
                    bestAvgDist = avgDist;
                    bestThird = k;
                }
            }

            candidates.push(bestThird);
            return candidates.map(i => snapshots[i]);
        }

        function calculateSnapshotDistance(snap1, snap2) {
            // Simple distance: sum of absolute differences
            let sum = 0;
            const len = Math.min(snap1.length, snap2.length);
            for (let i = 0; i < len; i++) {
                sum += Math.abs(snap1[i] - snap2[i]);
            }
            return sum / len;
        }

        function averageSnapshots(snapshots) {
            // Average all snapshots bin-by-bin
            const numBins = snapshots[0].length;
            const averaged = new Array(numBins).fill(0);

            for (const snapshot of snapshots) {
                for (let i = 0; i < numBins; i++) {
                    averaged[i] += snapshot[i];
                }
            }

            return averaged.map(v => v / snapshots.length);
        }

        function normalizePattern(pattern2D) {
            // Normalize each time slice to 0-1 range
            return pattern2D.map(slice => {
                const max = Math.max(...slice);
                if (max === 0) return slice;
                return slice.map(v => v / max);
            });
        }

        function updateCalibrationStats() {
            const calibrated = Object.keys(calibrationData).length;
            const total = PHONEMES.length;
            const statsEl = document.getElementById('calibrationStats');
            statsEl.textContent = `Calibrated: ${calibrated} / ${total} phonemes`;

            if (calibrated === total) {
                statsEl.innerHTML += '<br><strong style="color: #7CB342;">‚úì All phonemes calibrated! Switch to Tuner tab.</strong>';
            }
        }

        function updateCalibrationUI() {
            PHONEMES.forEach(phoneme => {
                if (calibrationData[phoneme.letter]) {
                    const card = document.getElementById(`card-${phoneme.letter}`);
                    if (card) {
                        card.classList.add('calibrated');
                        card.querySelector('.phoneme-status').textContent = '‚úì Calibrated';
                    }
                }
            });
            updateCalibrationStats();
        }

        function resetCalibration() {
            if (confirm(`Reset all calibration data for ${currentProfile}?`)) {
                calibrationData = {};
                const key = `phonicsPatterns_${currentProfile}`;
                localStorage.removeItem(key);
                createCalibrationGrid();
                updateCalibrationStats();
            }
        }

        function exportCalibration() {
            const dataStr = JSON.stringify(calibrationData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `phonics-patterns-${currentProfile}.json`;
            a.click();
        }

        // Elimination game mode
        let patternBuffer = [];
        let currentTarget = null;
        let experimentResults = []; // Track all trials for analysis
        let alphabetModeEnabled = false;
        let currentAlphabetIndex = 0;

        function toggleAlphabetMode() {
            alphabetModeEnabled = document.getElementById('alphabetMode').checked;
            currentAlphabetIndex = 0;
            updateAlphabetProgress();
        }

        function updateAlphabetProgress() {
            const progressEl = document.getElementById('alphabetProgress');
            if (alphabetModeEnabled && currentTarget) {
                progressEl.style.display = 'inline';
                const letterIndex = PHONEMES.findIndex(p => p.letter === currentTarget) + 1;
                progressEl.textContent = `Letter ${letterIndex}/26: ${currentTarget}`;
            } else {
                progressEl.style.display = 'none';
            }
        }

        function pickRandomLetter() {
            // Only pick from letters that are BOTH calibrated AND in current PHONEMES list
            const allowedLetters = PHONEMES.map(p => p.letter);
            const calibratedLetters = Object.keys(calibrationData).filter(letter =>
                allowedLetters.includes(letter)
            );
            if (calibratedLetters.length === 0) return null;
            return calibratedLetters[Math.floor(Math.random() * calibratedLetters.length)];
        }

        function pickNextAlphabetLetter() {
            const allLetters = PHONEMES.map(p => p.letter);
            const calibratedLetters = Object.keys(calibrationData);

            // Start from current index and find next calibrated letter
            let attempts = 0;
            while (attempts < 26) {
                const letter = allLetters[currentAlphabetIndex];
                currentAlphabetIndex = (currentAlphabetIndex + 1) % 26;

                if (calibratedLetters.includes(letter)) {
                    return letter;
                }
                attempts++;
            }

            return null;
        }

        function skipLetter() {
            if (isRunning) {
                setNextTarget();
            }
        }

        function tryAgain() {
            // Reset and start listening again for same letter
            document.getElementById('tryAgainBtn').style.display = 'none';
            document.getElementById('tunerBtn').textContent = '‚è∏ Stop Game';
            patternBuffer = [];
            isRunning = true;
            analyzeTuner();
        }

        function setNextTarget() {
            // Pick letter adaptively based on struggle (letters needing more LISTEN clicks appear more often)
            currentTarget = pickAdaptiveLetter();

            if (currentTarget) {
                document.getElementById('targetLetter').textContent = currentTarget;
                document.getElementById('status').textContent = `Say: ${currentTarget}`;
                document.getElementById('tryAgainBtn').style.display = 'none';
                patternBuffer = [];

                // Reset listen counter for new letter
                listenClicksThisAttempt = 0;
                document.getElementById('currentLetterListens').textContent = '0';

                updateMasteryUI();
            }
        }

        function pickAdaptiveLetter() {
            const calibratedLetters = Object.keys(calibrationData);
            if (calibratedLetters.length === 0) return null;

            // Calculate struggle score for each letter (higher = needs more practice)
            const letterScores = calibratedLetters.map(letter => {
                const history = attemptHistory[letter] || [];

                // Only look at last 10 attempts for this letter
                const recentAttempts = history.slice(-10);

                // Calculate average listen clicks needed
                const avgListens = recentAttempts.length > 0
                    ? recentAttempts.reduce((sum, a) => sum + (a.listenedFirst ? 1 : 0), 0) / recentAttempts.length
                    : 0.5; // Default for new letters

                // Letters that need more LISTEN = higher score
                return { letter, score: avgListens };
            });

            // Use weighted random selection (struggling letters more likely)
            // Add 0.1 to all scores so even mastered letters can appear occasionally
            const totalWeight = letterScores.reduce((sum, ls) => sum + ls.score + 0.1, 0);
            let random = Math.random() * totalWeight;

            for (const ls of letterScores) {
                random -= (ls.score + 0.1);
                if (random <= 0) {
                    return ls.letter;
                }
            }

            // Fallback
            return calibratedLetters[0];
        }

        function recordAttempt(letter, success, listenedFirst) {
            if (!attemptHistory[letter]) {
                attemptHistory[letter] = [];
            }

            attemptHistory[letter].push({
                timestamp: Date.now(),
                listenedFirst: listenedFirst,
                success: success
            });

            // Keep only last 200 attempts total (across all letters)
            const allAttempts = Object.values(attemptHistory).flat();
            if (allAttempts.length > 200) {
                // Remove oldest attempts
                for (const letter in attemptHistory) {
                    if (attemptHistory[letter].length > 0) {
                        attemptHistory[letter].shift();
                        break;
                    }
                }
            }

            // Update mastery: letter is mastered if last 3 successful attempts had no LISTEN
            checkMastery(letter);

            // Save to localStorage
            saveAttemptHistory();
        }

        function checkMastery(letter) {
            const history = attemptHistory[letter] || [];
            const successfulAttempts = history.filter(a => a.success && !a.listenedFirst);

            // Letter is mastered if last 3 successful attempts didn't use LISTEN
            const recentSuccesses = successfulAttempts.slice(-3);
            if (recentSuccesses.length >= 3) {
                masteredLetters.add(letter);
            }
        }

        function updateMasteryUI() {
            const masteredCount = masteredLetters.size;
            document.getElementById('masteredCount').textContent = masteredCount;

            // Show unlock status if all 26 letters mastered
            const unlockStatus = document.getElementById('unlockStatus');
            if (masteredCount >= 26) {
                unlockStatus.style.display = 'inline';
            } else {
                unlockStatus.style.display = 'none';
            }
        }

        function saveAttemptHistory() {
            const data = {
                attemptHistory: attemptHistory,
                masteredLetters: Array.from(masteredLetters)
            };
            localStorage.setItem(`flashcardData_${currentProfile}`, JSON.stringify(data));
        }

        function loadAttemptHistory() {
            const saved = localStorage.getItem(`flashcardData_${currentProfile}`);
            if (saved) {
                const data = JSON.parse(saved);
                attemptHistory = data.attemptHistory || {};
                masteredLetters = new Set(data.masteredLetters || []);
            } else {
                attemptHistory = {};
                masteredLetters = new Set();
            }
        }

        async function toggleTuner() {
            const btn = document.getElementById('tunerBtn');

            // If button says "Next Letter", just advance to next
            if (btn.textContent === '‚ñ∂ Next Letter') {
                btn.textContent = '‚è∏ Stop Game';
                isRunning = true;
                setNextTarget();
                analyzeTuner();
                return;
            }

            if (isRunning) {
                isRunning = false;
                btn.textContent = '‚ñ∂ Start Game';
                document.getElementById('status').textContent = 'Stopped';
                document.getElementById('targetLetter').textContent = '?';
            } else {
                if (Object.keys(calibrationData).length === 0) {
                    alert('Please calibrate at least one phoneme first!');
                    return;
                }
                if (!audioContext) {
                    await setupAudio();
                }
                isRunning = true;
                btn.textContent = '‚è∏ Stop Game';
                setNextTarget();
                analyzeTuner();
            }
        }

        function analyzeTuner() {
            if (!isRunning) return;
            requestAnimationFrame(analyzeTuner);

            analyser.getByteFrequencyData(dataArray);

            // Draw spectrum
            drawSpectrum();

            // Calculate volume
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volume = (sum / dataArray.length / 128) * 100;
            document.getElementById('volume').textContent = Math.round(volume) + '%';

            // ALWAYS add current frame to buffer (sliding window)
            const pattern = downsampleFrequencies(dataArray, PATTERN_BINS);
            patternBuffer.push(pattern);

            // Keep buffer at PATTERN_LENGTH
            if (patternBuffer.length > PATTERN_LENGTH) {
                patternBuffer.shift();
            }

            // DEBUG: Show buffer status only when NOT ready
            if (currentTarget && patternBuffer.length < PATTERN_LENGTH) {
                document.getElementById('status').textContent = `Buffer: ${patternBuffer.length}/${PATTERN_LENGTH} frames (keep talking...)`;
            }

            // Check energy concentration (speech vs background noise)
            const peakEnergy = Math.max(...pattern);
            const avgEnergy = pattern.reduce((a, b) => a + b, 0) / pattern.length;
            const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;

            // Skip detection if playing back a recording
            if (isPlayingRecording) {
                return;
            }

            // Dynamic thresholds for nasals (same as game mode)
            const FRICATIVES = ['F', 'S', 'V', 'Z', 'H'];
            const LIQUIDS = ['L', 'R'];
            const isCurrentNasal = currentTarget && isNasal(currentTarget);
            const isFricative = currentTarget && FRICATIVES.includes(currentTarget);
            const isLiquid = currentTarget && LIQUIDS.includes(currentTarget);

            let volumeThreshold = 15;
            let concentrationThreshold = 2.0;

            if (isCurrentNasal || isLiquid) {
                volumeThreshold = 8;
                concentrationThreshold = 1.5;
            } else if (isFricative) {
                volumeThreshold = 10;
                concentrationThreshold = 1.8;
            }

            // Try to match against TARGET letter only
            if (patternBuffer.length === PATTERN_LENGTH && volume > volumeThreshold && energyConcentration > concentrationThreshold && currentTarget) {

                // S11-Snapshot detection for ALL letters
                const results = testAllPlosiveStrategies(patternBuffer, currentTarget);

                const result = results[0]; // Only S11-Snapshot now
                const score = Math.max(0, Math.min(100, result.score || 0));
                const targetScore = Math.max(0, Math.min(100, result.targetScore || 0));
                const prediction = result.predictedLetter || '?';
                const isCorrect = prediction === currentTarget;

                // Show simplified status
                const barCount = Math.max(0, Math.floor(score / 10));
                const bar = '‚ñà'.repeat(barCount);
                const statusText = `üéØ S11-Snapshot: ${isCorrect ? '‚úì' : '‚úó'} Predicted: ${prediction} | Score: ${Math.round(score)}% ${bar}\nTarget ${currentTarget}: ${Math.round(targetScore)}%`;

                document.getElementById('status').textContent = statusText;
                document.getElementById('matchScore').textContent = Math.round(score) + '%';
                document.getElementById('confidenceFill').style.width = score + '%';

                // Success if S11 predicts correctly AND score > 80%
                if (isCorrect && score > 80) {
                    celebrateMatch();

                    // Record this attempt for flashcard tracking
                    const listenedFirst = listenClicksThisAttempt > 0;
                    recordAttempt(currentTarget, true, listenedFirst);

                    // Log this trial for analysis
                    experimentResults.push({
                        target: currentTarget,
                        timestamp: Date.now(),
                        strategies: results
                    });

                    // Prepend success message to experimental results
                    const trialsCount = experimentResults.length;
                    document.getElementById('trialsCount').textContent = trialsCount;

                    // Show different message based on whether LISTEN was used
                    const successMsg = listenedFirst
                        ? `‚úì MATCH! Great job! (used LISTEN ${listenClicksThisAttempt}x)`
                        : `‚úì PERFECT! Said it without LISTEN! üåü`;

                    document.getElementById('status').textContent = `${successMsg} ${Math.round(score)}% - Trial #${trialsCount}\n\n` + statusText;

                    // Stop analyzing so results stay visible
                    isRunning = false;
                    document.getElementById('tunerBtn').textContent = '‚ñ∂ Next Letter';
                    document.getElementById('tryAgainBtn').style.display = 'inline-block';
                }

                if (false) {
                    // REGULAR DETECTION: Use pattern matching for non-plosives
                    const score = matchTargetPattern(patternBuffer, currentTarget);

                    // Also check BEST match among all letters
                    const allScores = Object.keys(calibrationData).map(letter => {
                        const normalized = normalizePattern(patternBuffer);
                        const storedPattern = calibrationData[letter].pattern;
                        const similarity = calculatePatternSimilarity(normalized, storedPattern);
                        return { letter, score: similarity * 100 };
                    });

                    allScores.sort((a, b) => b.score - a.score);
                    const bestMatch = allScores[0];

                    document.getElementById('matchScore').textContent = Math.round(score) + '%';
                    document.getElementById('confidenceFill').style.width = score + '%';
                    document.getElementById('status').textContent = `Best match: ${bestMatch.letter} (${Math.round(bestMatch.score)}%)`;

                    // Success! Pattern matched AND it's the best match
                    if (score > 85 && bestMatch.letter === currentTarget) {
                        celebrateMatch();
                        document.getElementById('status').textContent = `‚úì PERFECT MATCH! (Try Again or Next Letter)\nBest match: ${bestMatch.letter} (${Math.round(bestMatch.score)}%)`;
                        // Stop analyzing so results stay visible
                        isRunning = false;
                        document.getElementById('tunerBtn').textContent = '‚ñ∂ Next Letter';
                        document.getElementById('tryAgainBtn').style.display = 'inline-block';
                    }
                }
            }
        }

        function matchTargetPattern(currentPattern, targetLetter) {
            if (!calibrationData[targetLetter]) return 0;

            // Normalize current pattern
            const normalized = normalizePattern(currentPattern);
            const storedPattern = calibrationData[targetLetter].pattern;

            // Calculate correlation
            const score = calculatePatternSimilarity(normalized, storedPattern);

            // Convert to percentage
            return Math.min(100, score * 100);
        }

        function celebrateMatch() {
            const targetEl = document.getElementById('targetLetter');

            // Play success sound
            if (audioContext) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.4);
            }

            // Exciting animation sequence
            targetEl.style.transition = 'all 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55)';

            // Bounce and color sequence
            targetEl.style.transform = 'scale(1.5) rotate(5deg)';
            targetEl.style.color = '#FDD835';

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.3) rotate(-5deg)';
                targetEl.style.color = '#7CB342';
            }, 150);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.6) rotate(0deg)';
                targetEl.style.color = '#00BCD4';
            }, 300);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.2)';
                targetEl.style.color = '#FF5722';
            }, 450);

            setTimeout(() => {
                targetEl.style.transform = 'scale(1.4)';
                targetEl.style.color = '#9C27B0';
            }, 600);

            setTimeout(() => {
                targetEl.style.transition = 'all 0.3s ease-out';
                targetEl.style.transform = 'scale(1)';
                targetEl.style.color = '#FDD835';
            }, 800);

            // Create confetti particles
            createConfetti(targetEl);
        }

        function createConfetti(centerEl) {
            const container = centerEl.parentElement;
            const rect = centerEl.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const colors = ['#FDD835', '#7CB342', '#00BCD4', '#FF5722', '#9C27B0'];

            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.style.position = 'fixed';
                particle.style.left = centerX + 'px';
                particle.style.top = centerY + 'px';
                particle.style.width = '10px';
                particle.style.height = '10px';
                particle.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                particle.style.pointerEvents = 'none';
                particle.style.zIndex = '9999';

                document.body.appendChild(particle);

                const angle = (Math.PI * 2 * i) / 20;
                const velocity = 100 + Math.random() * 100;
                const vx = Math.cos(angle) * velocity;
                const vy = Math.sin(angle) * velocity;

                let x = 0, y = 0, time = 0;
                const gravity = 500;

                const animate = () => {
                    time += 0.016; // ~60fps
                    x = vx * time;
                    y = vy * time + 0.5 * gravity * time * time;

                    particle.style.transform = `translate(${x}px, ${y}px) rotate(${time * 360}deg)`;
                    particle.style.opacity = Math.max(0, 1 - time * 1.5);

                    if (time < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        particle.remove();
                    }
                };

                requestAnimationFrame(animate);
            }
        }

        // ========== EXPERIMENTAL PLOSIVE DETECTION STRATEGIES ==========

        function testAllPlosiveStrategies(patternBuffer, targetLetter) {
            if (!calibrationData[targetLetter]) return [{ strategy: 'none', score: 0, predictedLetter: '?' }];

            const results = [];
            const strategyFunctions = [
                { name: 'S11-Snapshot', fn: strategy11_simpleSnapshot }
            ];

            // For each strategy, test against ALL calibrated letters
            strategyFunctions.forEach(({ name, fn }) => {
                let bestLetter = null;
                let bestScore = 0;
                let targetScore = 0;

                // Test this strategy against all calibrated letters
                Object.keys(calibrationData).forEach(letter => {
                    const score = fn(patternBuffer, letter);
                    if (score > bestScore) {
                        bestScore = score;
                        bestLetter = letter;
                    }
                    if (letter === targetLetter) {
                        targetScore = score;
                    }
                });

                results.push({
                    strategy: name,
                    score: bestScore,
                    targetScore: targetScore,
                    predictedLetter: bestLetter || '?'
                });
            });

            // Sort by score (highest first)
            results.sort((a, b) => b.score - a.score);

            return results;
        }

        // Strategy 1: Focus on frames around peak energy
        function strategy1_burstWindow(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const peakIdx = energies.indexOf(Math.max(...energies));

            const burstWindow = buffer.slice(Math.max(0, peakIdx - 5), peakIdx + 5);
            return matchTargetPattern(burstWindow, target);
        }

        // Strategy 2: Use only first 10 frames
        function strategy2_shortWindow(buffer, target) {
            const shortBuffer = buffer.slice(0, 10);
            return matchTargetPattern(shortBuffer, target);
        }

        // Strategy 3: Compare peak frequency and amplitude
        function strategy3_peakEnergy(buffer, target) {
            const currentPeak = Math.max(...buffer.flat());
            const currentPeakFreq = buffer[0].indexOf(Math.max(...buffer[0]));

            const calibPattern = calibrationData[target].pattern;
            const calibPeak = Math.max(...calibPattern.flat());
            const calibPeakFreq = calibPattern[0].indexOf(Math.max(...calibPattern[0]));

            const peakSimilarity = 1 - Math.abs(currentPeak - calibPeak);
            const freqSimilarity = 1 - Math.abs(currentPeakFreq - calibPeakFreq) / PATTERN_BINS;

            return ((peakSimilarity + freqSimilarity) / 2) * 100;
        }

        // Strategy 4: Compare attack speed (volume rise rate)
        function strategy4_attackSpeed(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));

            let maxRise = 0;
            for (let i = 1; i < energies.length; i++) {
                const rise = energies[i] - energies[i - 1];
                if (rise > maxRise) maxRise = rise;
            }

            // Compare with calibration (would need to store this)
            // For now, just use pattern matching on energy envelope
            const normalized = normalizePattern(buffer);
            const stored = calibrationData[target].pattern;
            return calculatePatternSimilarity(normalized, stored) * 100;
        }

        // Strategy 5: Match derivatives (rate of change)
        function strategy5_derivative(buffer, target) {
            const derivatives = [];
            for (let i = 1; i < buffer.length; i++) {
                const diff = buffer[i].map((val, idx) => val - buffer[i - 1][idx]);
                derivatives.push(diff);
            }

            return matchTargetPattern(derivatives, target);
        }

        // Strategy 6: Simple burst detection + frequency check
        function strategy6_dualThreshold(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const maxEnergy = Math.max(...energies);
            const avgEnergy = energies.reduce((a, b) => a + b, 0) / energies.length;

            const isBurst = maxEnergy > avgEnergy * 2;

            if (!isBurst) return 0;

            return matchTargetPattern(buffer, target);
        }

        // Strategy 7: Average multiple high-energy frames
        function strategy7_multipleFrames(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const threshold = Math.max(...energies) * 0.7;

            const highEnergyFrames = buffer.filter((frame, idx) => energies[idx] > threshold);

            if (highEnergyFrames.length === 0) return 0;

            return matchTargetPattern(highEnergyFrames, target);
        }

        // Strategy 8: Measure quiet-to-loud ratio
        function strategy8_silenceRatio(buffer, target) {
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const avgEnergy = energies.reduce((a, b) => a + b, 0) / energies.length;

            const quietFrames = energies.filter(e => e < avgEnergy * 0.5).length;
            const silenceRatio = quietFrames / energies.length;

            // Plosives should have high silence ratio
            const expectedRatio = 0.6; // 60% quiet
            const ratioScore = 1 - Math.abs(silenceRatio - expectedRatio);

            const patternScore = matchTargetPattern(buffer, target) / 100;

            return ((ratioScore + patternScore) / 2) * 100;
        }

        // Strategy 10: Only match first 5 frames (immediate burst)
        function strategy10_firstFrames(buffer, target) {
            const firstFrames = buffer.slice(0, 5);
            return matchTargetPattern(firstFrames, target);
        }

        // Strategy 11: Simple Snapshot Comparison (peak moment bar heights)
        function strategy11_simpleSnapshot(buffer, target) {
            if (!calibrationData[target]) return 0;

            // Find peak moment in current buffer (highest energy frame)
            const energies = buffer.map(frame => frame.reduce((a, b) => a + b, 0));
            const currentPeakIdx = energies.indexOf(Math.max(...energies));
            let currentSnapshot = buffer[currentPeakIdx];

            // Normalize current snapshot to 0-1 range (same as calibration data)
            const maxCurrent = Math.max(...currentSnapshot);
            if (maxCurrent > 0) {
                currentSnapshot = currentSnapshot.map(v => v / maxCurrent);
            }

            // Get stored baseline snapshot (already averaged and normalized)
            const storedSnapshot = calibrationData[target].pattern[0]; // It's a single snapshot now

            // Calculate simple distance (sum of absolute differences)
            let totalDistance = 0;
            const minLength = Math.min(currentSnapshot.length, storedSnapshot.length);

            for (let i = 0; i < minLength; i++) {
                totalDistance += Math.abs(currentSnapshot[i] - storedSnapshot[i]);
            }

            // Convert distance to similarity score (0-100)
            // Max possible avgDistance is 1.0 (completely different patterns)
            const avgDistance = totalDistance / minLength;
            const similarity = Math.max(0, 100 - (avgDistance * 100));

            return similarity;
        }

        function calculatePatternSimilarity(pattern1, pattern2) {
            // Use correlation coefficient to measure similarity
            let sumProduct = 0;
            let sum1Sq = 0;
            let sum2Sq = 0;
            let count = 0;

            const minLength = Math.min(pattern1.length, pattern2.length);

            for (let t = 0; t < minLength; t++) {
                const slice1 = pattern1[t];
                const slice2 = pattern2[t];
                const minBins = Math.min(slice1.length, slice2.length);

                for (let f = 0; f < minBins; f++) {
                    sumProduct += slice1[f] * slice2[f];
                    sum1Sq += slice1[f] * slice1[f];
                    sum2Sq += slice2[f] * slice2[f];
                    count++;
                }
            }

            const denominator = Math.sqrt(sum1Sq * sum2Sq);
            if (denominator === 0) return 0;

            return sumProduct / denominator; // Correlation coefficient
        }

        function drawSpectrum() {
            const width = canvas.width;
            const height = canvas.height;

            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            canvasCtx.fillRect(0, 0, width, height);

            const barWidth = width / dataArray.length * 2.5;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * height;
                const hue = (i / dataArray.length) * 120 + 100;
                canvasCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                canvasCtx.fillRect(x, height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        function saveAudioRecording(letter, audioBlob) {
            const reader = new FileReader();
            reader.onloadend = () => {
                const base64Audio = reader.result;
                audioRecordings[letter] = base64Audio;
                const key = `phonicsAudio_${currentProfile}`;
                localStorage.setItem(key, JSON.stringify(audioRecordings));
                console.log(`Saved audio recording for ${letter}`);
            };
            reader.readAsDataURL(audioBlob);
        }

        function loadAudioRecordings() {
            const key = `phonicsAudio_${currentProfile}`;
            const saved = localStorage.getItem(key);
            if (saved) {
                audioRecordings = JSON.parse(saved);
            } else {
                audioRecordings = {};
            }
        }

        let isPlayingRecording = false;
        let currentPhonemeAudio = null;

        function playPhonemeSound(letter) {
            const phoneme = PHONEMES.find(p => p.letter === letter);
            if (!phoneme || !phoneme.audioUrl) return;

            if (currentPhonemeAudio) {
                currentPhonemeAudio.pause();
                currentPhonemeAudio.currentTime = 0;
            }

            currentPhonemeAudio = new Audio(phoneme.audioUrl);
            currentPhonemeAudio.play().catch(err => {
                console.error('Audio playback failed:', err);
            });
        }

        function playLetterSound() {
            if (!currentTarget) {
                alert('No letter selected. Start practice first!');
                return;
            }

            // Play the sound
            playPhonemeSound(currentTarget);

            // Track that we clicked LISTEN for this attempt
            listenClicksThisAttempt++;
            document.getElementById('currentLetterListens').textContent = listenClicksThisAttempt;
        }

        function playCalibrationRecording() {
            if (!currentTarget) {
                alert('No letter selected. Start the tuner first!');
                return;
            }

            if (!audioRecordings[currentTarget]) {
                alert(`No recording found for ${currentTarget}. Please calibrate this letter first.`);
                return;
            }

            isPlayingRecording = true;
            const audio = new Audio(audioRecordings[currentTarget]);

            audio.onended = () => {
                isPlayingRecording = false;
            };

            audio.onerror = () => {
                isPlayingRecording = false;
            };

            audio.play();
        }

        async function setupAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.stream = stream;

                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.5;

                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);

                microphone.connect(analyser);

            } catch (err) {
                alert('Microphone access denied!');
                console.error('Audio setup error:', err);
            }
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                const tabs = document.querySelectorAll('.tab');
                tabs.forEach(tab => {
                    if (tab.textContent.toLowerCase().includes(tabName)) {
                        tab.classList.add('active');
                    }
                });
            }
            document.getElementById(tabName).classList.add('active');
        }

        // ========== STATISTICS & EXPORT ==========

        function viewStats() {
            if (experimentResults.length === 0) {
                alert('No trials recorded yet. Run some tests first!');
                return;
            }

            // Calculate accuracy per strategy
            const strategyStats = {};

            experimentResults.forEach(trial => {
                trial.strategies.forEach(result => {
                    if (!strategyStats[result.strategy]) {
                        strategyStats[result.strategy] = { correct: 0, total: 0 };
                    }
                    strategyStats[result.strategy].total++;
                    if (result.predictedLetter === trial.target) {
                        strategyStats[result.strategy].correct++;
                    }
                });
            });

            // Format stats display
            let statsText = `üìä EXPERIMENT STATISTICS (${experimentResults.length} trials):\n\n`;

            // Sort strategies by accuracy
            const sortedStrategies = Object.entries(strategyStats)
                .map(([name, stats]) => ({
                    name,
                    accuracy: (stats.correct / stats.total) * 100,
                    correct: stats.correct,
                    total: stats.total
                }))
                .sort((a, b) => b.accuracy - a.accuracy);

            sortedStrategies.forEach(s => {
                const bar = '‚ñà'.repeat(Math.floor(s.accuracy / 10));
                statsText += `${s.name.padEnd(12)} ${Math.round(s.accuracy).toString().padStart(3)}% ${bar} (${s.correct}/${s.total})\n`;
            });

            statsText += `\n\nTarget letter breakdown:\n`;
            const targetCounts = {};
            experimentResults.forEach(t => {
                targetCounts[t.target] = (targetCounts[t.target] || 0) + 1;
            });
            Object.entries(targetCounts).forEach(([letter, count]) => {
                statsText += `  ${letter}: ${count} trials\n`;
            });

            document.getElementById('status').textContent = statsText;
        }

        function exportResults() {
            if (experimentResults.length === 0) {
                alert('No trials recorded yet. Run some tests first!');
                return;
            }

            const dataStr = JSON.stringify(experimentResults, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `plosive-experiment-${Date.now()}.json`;
            a.click();

            alert(`Exported ${experimentResults.length} trials`);
        }

        // ========== GAME MODE ==========

        let gameCanvas;
        let gameCtx;
        let gameSpectrumCanvas;
        let gameSpectrumCtx;
        let gameRunning = false;
        let gameScore = 0;
        let gameLives = 3;
        let gameSpeed = 1;
        let fallingLetters = [];
        let gamePatternBuffer = [];
        let lastSpawnTime = 0;
        let gameAnimationFrame = null;

        class FallingLetter {
            constructor(letter, lane, speed) {
                this.letter = letter;
                this.lane = lane;
                this.y = 0;
                this.speed = speed;
                this.width = 100;
                this.height = 120;
            }

            update(deltaSpeed) {
                this.y += this.speed * deltaSpeed;
            }

            isAtBottom(canvasHeight) {
                return this.y + this.height >= canvasHeight;
            }

            getDistance(canvasHeight) {
                return canvasHeight - (this.y + this.height);
            }
        }

        function initGame() {
            gameCanvas = document.getElementById('gameCanvas');
            gameCtx = gameCanvas.getContext('2d');
            gameCanvas.width = 400;
            gameCanvas.height = 700;

            gameSpectrumCanvas = document.getElementById('gameSpectrumCanvas');
            gameSpectrumCtx = gameSpectrumCanvas.getContext('2d');
            gameSpectrumCanvas.width = 800;
            gameSpectrumCanvas.height = 100;
        }

        async function toggleGame() {
            const btn = document.getElementById('gameBtn');

            if (gameRunning) {
                stopGame();
            } else {
                if (Object.keys(calibrationData).length === 0) {
                    alert('Please calibrate at least one phoneme first!');
                    return;
                }
                if (!audioContext) {
                    await setupAudio();
                }
                startGame();
            }
        }

        function startGame() {
            gameRunning = true;
            gameScore = 0;
            gameLives = 3;
            gameSpeed = 1;
            fallingLetters = [];
            gamePatternBuffer = [];
            lastSpawnTime = 0;

            document.getElementById('gameBtn').textContent = '‚è∏ Pause';
            updateGameUI();

            if (!gameCanvas) initGame();

            gameLoop();
            analyzeGameAudio();
        }

        function stopGame() {
            gameRunning = false;
            document.getElementById('gameBtn').textContent = '‚ñ∂ Start Game';
            if (gameAnimationFrame) {
                cancelAnimationFrame(gameAnimationFrame);
            }
        }

        function restartGame() {
            stopGame();
            setTimeout(() => {
                if (audioContext) {
                    startGame();
                }
            }, 100);
        }

        function updateGameUI() {
            document.getElementById('gameScore').textContent = gameScore;
            document.getElementById('gameLives').textContent = gameLives;
            document.getElementById('gameSpeed').textContent = gameSpeed.toFixed(1) + 'x';
        }

        function spawnLetter() {
            const calibratedLetters = Object.keys(calibrationData);
            if (calibratedLetters.length === 0) return;

            if (fallingLetters.length >= 3) return;

            const usedLanes = fallingLetters.map(l => l.lane);
            const availableLanes = [0, 1, 2].filter(lane => !usedLanes.includes(lane));
            if (availableLanes.length === 0) return;

            const lane = availableLanes[Math.floor(Math.random() * availableLanes.length)];
            const letter = calibratedLetters[Math.floor(Math.random() * calibratedLetters.length)];
            const speed = 1 * gameSpeed;

            fallingLetters.push(new FallingLetter(letter, lane, speed));
        }

        function gameLoop() {
            if (!gameRunning) return;

            const now = Date.now();
            if (now - lastSpawnTime > 2000 && fallingLetters.length < 3) {
                spawnLetter();
                lastSpawnTime = now;
            }

            gameCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

            let closestLetter = null;
            let minDistance = Infinity;

            fallingLetters.forEach(letter => {
                letter.update(1);

                const distance = letter.getDistance(gameCanvas.height);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestLetter = letter;
                }
            });

            fallingLetters.forEach(letter => {
                const x = (letter.lane * (gameCanvas.width / 3)) + (gameCanvas.width / 6) - (letter.width / 2);
                const isClosest = letter === closestLetter;

                if (isClosest) {
                    gameCtx.fillStyle = '#F44336';
                    gameCtx.shadowBlur = 20;
                    gameCtx.shadowColor = '#F44336';
                } else {
                    gameCtx.fillStyle = '#FDD835';
                    gameCtx.shadowBlur = 0;
                }

                gameCtx.font = 'bold 80px Arial';
                gameCtx.textAlign = 'center';
                gameCtx.textBaseline = 'middle';
                gameCtx.fillText(letter.letter, x + letter.width / 2, letter.y + letter.height / 2);

                gameCtx.shadowBlur = 0;
            });

            const lettersThatHitBottom = fallingLetters.filter(l => l.isAtBottom(gameCanvas.height));
            if (lettersThatHitBottom.length > 0) {
                gameLives -= lettersThatHitBottom.length;
                fallingLetters = fallingLetters.filter(l => !l.isAtBottom(gameCanvas.height));
                updateGameUI();

                if (gameLives <= 0) {
                    endGame();
                    return;
                }
            }

            if (closestLetter) {
                document.getElementById('gameStatus').textContent = `Say: ${closestLetter.letter}`;
            } else {
                document.getElementById('gameStatus').textContent = 'Get ready...';
            }

            gameAnimationFrame = requestAnimationFrame(gameLoop);
        }

        function analyzeGameAudio() {
            if (!gameRunning) return;
            requestAnimationFrame(analyzeGameAudio);

            analyser.getByteFrequencyData(dataArray);

            const pattern = downsampleFrequencies(dataArray, PATTERN_BINS);
            gamePatternBuffer.push(pattern);

            if (gamePatternBuffer.length > PATTERN_LENGTH) {
                gamePatternBuffer.shift();
            }

            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volume = (sum / dataArray.length / 128) * 100;

            document.getElementById('gameVolume').textContent = Math.round(volume) + '%';
            document.getElementById('gameVolumeFill').style.width = volume + '%';

            drawGameSpectrum();

            const peakEnergy = Math.max(...pattern);
            const avgEnergy = pattern.reduce((a, b) => a + b, 0) / pattern.length;
            const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;

            // Skip detection if playing back a recording
            if (isPlayingRecording) {
                return;
            }

            if (gamePatternBuffer.length === PATTERN_LENGTH) {
                const closestLetter = getClosestLetter();
                if (!closestLetter) return;

                const NASALS = ['M', 'N'];
                const FRICATIVES = ['F', 'S', 'V', 'Z', 'H'];
                const LIQUIDS = ['L', 'R'];
                const isNasal = NASALS.includes(closestLetter.letter);
                const isFricative = FRICATIVES.includes(closestLetter.letter);
                const isLiquid = LIQUIDS.includes(closestLetter.letter);

                let volumeThreshold = 15;
                let concentrationThreshold = 2.0;

                if (isNasal || isLiquid) {
                    volumeThreshold = 8;
                    concentrationThreshold = 1.3;
                } else if (isFricative) {
                    volumeThreshold = 10;
                    concentrationThreshold = 1.8;
                }

                if (volume > volumeThreshold && energyConcentration > concentrationThreshold) {
                    const results = testAllPlosiveStrategies(gamePatternBuffer, closestLetter.letter);
                    const result = results[0];
                    const score = Math.max(0, Math.min(100, result.score || 0));
                    const prediction = result.predictedLetter || '?';
                    const isCorrect = prediction === closestLetter.letter;

                    if (isCorrect && score > 80) {
                        handleCorrectMatch(closestLetter);
                    }
                }
            }
        }

        function drawGameSpectrum() {
            if (!gameSpectrumCanvas) return;

            const width = gameSpectrumCanvas.width;
            const height = gameSpectrumCanvas.height;

            gameSpectrumCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            gameSpectrumCtx.fillRect(0, 0, width, height);

            const barWidth = width / dataArray.length * 2.5;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * height;
                const hue = (i / dataArray.length) * 120 + 100;
                gameSpectrumCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                gameSpectrumCtx.fillRect(x, height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        function getClosestLetter() {
            if (fallingLetters.length === 0) return null;

            let closest = fallingLetters[0];
            let minDistance = closest.getDistance(gameCanvas.height);

            fallingLetters.forEach(letter => {
                const distance = letter.getDistance(gameCanvas.height);
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = letter;
                }
            });

            return closest;
        }

        function handleCorrectMatch(letter) {
            fallingLetters = fallingLetters.filter(l => l !== letter);
            gameScore++;
            gamePatternBuffer = [];

            if (gameScore % 10 === 0) {
                gameSpeed += 0.2;
            }

            updateGameUI();
            document.getElementById('gameStatus').textContent = `‚úì Got ${letter.letter}! +1`;

            setTimeout(() => {
                const closest = getClosestLetter();
                if (closest) {
                    document.getElementById('gameStatus').textContent = `Say: ${closest.letter}`;
                }
            }, 500);
        }

        function endGame() {
            gameRunning = false;
            document.getElementById('gameBtn').textContent = '‚ñ∂ Start Game';
            document.getElementById('gameStatus').textContent = `GAME OVER! Final Score: ${gameScore}`;

            gameCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

            gameCtx.fillStyle = '#F44336';
            gameCtx.font = 'bold 60px Arial';
            gameCtx.textAlign = 'center';
            gameCtx.fillText('GAME OVER', gameCanvas.width / 2, gameCanvas.height / 2 - 40);

            gameCtx.fillStyle = '#FDD835';
            gameCtx.font = 'bold 40px Arial';
            gameCtx.fillText(`Score: ${gameScore}`, gameCanvas.width / 2, gameCanvas.height / 2 + 20);
        }

        // ========== LEVEL 1 LEARNING GAME ==========

        const VOWELS_LEARNING = ['A', 'E', 'I', 'O', 'U'];
        let level1Running = false;
        let level1State = {
            phase: 'intro',
            currentVowelIndex: 0,
            repetition: 0,
            mode: 'listen',
            mixedRound: 0,
            learnedVowels: [],
            demoPattern: [],
            demoIndex: 0
        };
        let level1PatternBuffer = [];
        let level1Canvas, level1CanvasCtx;

        async function toggleLevel1() {
            if (level1Running) {
                stopLevel1();
            } else {
                if (!audioContext) {
                    await setupAudio();
                }
                startLevel1();
            }
        }

        function startLevel1() {
            level1Running = true;
            level1State = {
                phase: 'teach',
                currentVowelIndex: 0,
                repetition: 0,
                mode: 'listen',
                mixedRound: 0,
                learnedVowels: [],
                demoPattern: [],
                demoIndex: 0
            };
            level1PatternBuffer = [];

            level1Canvas = document.getElementById('level1SpectrumCanvas');
            level1CanvasCtx = level1Canvas.getContext('2d');
            level1Canvas.width = 800;
            level1Canvas.height = 120;

            document.getElementById('level1Btn').textContent = '‚è∏ Stop';

            nextLevel1Step();
            analyzeLevel1Audio();
        }

        function stopLevel1() {
            level1Running = false;
            document.getElementById('level1Btn').textContent = '‚ñ∂ Start Level 1';
            document.getElementById('level1Letter').textContent = '?';
            document.getElementById('level1Instruction').textContent = 'Stopped';
        }

        function nextLevel1Step() {
            if (!level1Running) return;

            const state = level1State;
            const currentLetter = VOWELS_LEARNING[state.currentVowelIndex];

            if (state.phase === 'teach') {
                if (state.mode === 'listen') {
                    if (state.repetition < 5) {
                        showLevel1Letter(currentLetter);
                        document.getElementById('level1Instruction').textContent = `üëÇ Listen: ${currentLetter}`;
                        document.getElementById('level1Mode').textContent = 'Listen';
                        document.getElementById('level1Progress').textContent = `${state.repetition + 1}/5`;

                        setTimeout(() => {
                            playPhonemeSound(currentLetter);
                            state.repetition++;
                            setTimeout(() => nextLevel1Step(), 1500);
                        }, 500);
                    } else {
                        state.repetition = 0;
                        state.mode = 'practice';
                        nextLevel1Step();
                    }
                } else if (state.mode === 'practice') {
                    if (state.repetition < 5) {
                        showLevel1Letter(currentLetter);
                        document.getElementById('level1Instruction').textContent = `üé§ Your turn! Say: ${currentLetter}`;
                        document.getElementById('level1Mode').textContent = 'Practice';
                        document.getElementById('level1Progress').textContent = `${state.repetition + 1}/5`;
                    } else {
                        state.learnedVowels.push(currentLetter);

                        if (state.learnedVowels.length >= 2) {
                            state.phase = 'demo';
                            state.demoPattern = generateMixedPattern(state.learnedVowels);
                            state.demoIndex = 0;
                            state.repetition = 0;
                            nextLevel1Step();
                        } else {
                            state.currentVowelIndex++;
                            if (state.currentVowelIndex >= VOWELS_LEARNING.length) {
                                completeLevel1();
                            } else {
                                state.repetition = 0;
                                state.mode = 'listen';
                                nextLevel1Step();
                            }
                        }
                    }
                }
            } else if (state.phase === 'demo') {
                if (state.demoIndex === 0) {
                    document.getElementById('level1Instruction').textContent = `üëÄ Watch! I'll show you the pattern first...`;
                }

                if (state.demoIndex < state.demoPattern.length) {
                    const letter = state.demoPattern[state.demoIndex];
                    showLevel1Letter(letter);
                    document.getElementById('level1Mode').textContent = 'Demo';

                    setTimeout(() => {
                        playPhonemeSound(letter);
                        state.demoIndex++;
                        setTimeout(() => nextLevel1Step(), 1500);
                    }, 500);
                } else {
                    state.phase = 'mixed';
                    state.mixedRound = 0;
                    state.repetition = 0;
                    nextLevel1Step();
                }
            } else if (state.phase === 'mixed') {
                if (state.mixedRound < 5) {
                    const letter = state.learnedVowels[state.repetition % state.learnedVowels.length];
                    showLevel1Letter(letter);
                    document.getElementById('level1Instruction').textContent = `üé§ Say: ${letter}`;
                    document.getElementById('level1Mode').textContent = 'Mixed';
                    document.getElementById('level1Progress').textContent = `Round ${state.mixedRound + 1}/5`;
                } else {
                    state.currentVowelIndex++;
                    if (state.currentVowelIndex >= VOWELS_LEARNING.length) {
                        completeLevel1();
                    } else {
                        state.phase = 'teach';
                        state.mode = 'listen';
                        state.repetition = 0;
                        nextLevel1Step();
                    }
                }
            }
        }

        function generateMixedPattern(vowels) {
            const pattern = [];
            for (let i = 0; i < vowels.length; i++) {
                pattern.push(vowels[i]);
                if (i < vowels.length - 1) {
                    pattern.push(vowels[i + 1]);
                }
            }
            return pattern;
        }

        function showLevel1Letter(letter) {
            const letterEl = document.getElementById('level1Letter');
            letterEl.textContent = letter;
            letterEl.classList.remove('fade-in');
            void letterEl.offsetWidth;
            letterEl.classList.add('fade-in');
        }

        function analyzeLevel1Audio() {
            if (!level1Running) return;
            requestAnimationFrame(analyzeLevel1Audio);

            analyser.getByteFrequencyData(dataArray);

            drawLevel1Spectrum();

            const pattern = downsampleFrequencies(dataArray, PATTERN_BINS);
            level1PatternBuffer.push(pattern);

            if (level1PatternBuffer.length > PATTERN_LENGTH) {
                level1PatternBuffer.shift();
            }

            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const volume = (sum / dataArray.length / 128) * 100;

            const peakEnergy = Math.max(...pattern);
            const avgEnergy = pattern.reduce((a, b) => a + b, 0) / pattern.length;
            const energyConcentration = avgEnergy > 0 ? peakEnergy / avgEnergy : 0;

            if (level1State.phase === 'teach' && level1State.mode === 'practice' && level1PatternBuffer.length === PATTERN_LENGTH) {
                const targetLetter = VOWELS_LEARNING[level1State.currentVowelIndex];

                if (volume > 15 && energyConcentration > 2.0) {
                    const results = testAllPlosiveStrategies(level1PatternBuffer, targetLetter);
                    const result = results[0];
                    const score = Math.max(0, Math.min(100, result.score || 0));
                    const prediction = result.predictedLetter || '?';
                    const isCorrect = prediction === targetLetter;

                    document.getElementById('level1Status').textContent = `Prediction: ${prediction} | Score: ${Math.round(score)}%`;
                    document.getElementById('level1ConfidenceFill').style.width = score + '%';

                    if (isCorrect && score > 80) {
                        celebrateLevel1Match();
                        level1State.repetition++;
                        level1PatternBuffer = [];
                        setTimeout(() => nextLevel1Step(), 1000);
                    }
                }
            } else if (level1State.phase === 'mixed' && level1PatternBuffer.length === PATTERN_LENGTH) {
                const targetLetter = level1State.learnedVowels[level1State.repetition % level1State.learnedVowels.length];

                if (volume > 15 && energyConcentration > 2.0) {
                    const results = testAllPlosiveStrategies(level1PatternBuffer, targetLetter);
                    const result = results[0];
                    const score = Math.max(0, Math.min(100, result.score || 0));
                    const prediction = result.predictedLetter || '?';
                    const isCorrect = prediction === targetLetter;

                    document.getElementById('level1Status').textContent = `Prediction: ${prediction} | Score: ${Math.round(score)}%`;
                    document.getElementById('level1ConfidenceFill').style.width = score + '%';

                    if (isCorrect && score > 80) {
                        celebrateLevel1Match();
                        level1State.repetition++;
                        level1PatternBuffer = [];

                        if (level1State.repetition >= level1State.learnedVowels.length * 2) {
                            level1State.mixedRound++;
                            level1State.repetition = 0;
                        }

                        setTimeout(() => nextLevel1Step(), 1000);
                    }
                }
            }
        }

        function drawLevel1Spectrum() {
            if (!level1Canvas) return;

            const width = level1Canvas.width;
            const height = level1Canvas.height;

            level1CanvasCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            level1CanvasCtx.fillRect(0, 0, width, height);

            const barWidth = width / dataArray.length * 2.5;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * height;
                const hue = (i / dataArray.length) * 120 + 100;
                level1CanvasCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                level1CanvasCtx.fillRect(x, height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        function celebrateLevel1Match() {
            const letterEl = document.getElementById('level1Letter');

            // Play success sound
            if (audioContext) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.4);
            }

            // Exciting animation sequence
            letterEl.style.transition = 'all 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55)';

            // Bounce and color sequence
            letterEl.style.transform = 'scale(1.5) rotate(5deg)';
            letterEl.style.color = '#FDD835';

            setTimeout(() => {
                letterEl.style.transform = 'scale(1.3) rotate(-5deg)';
                letterEl.style.color = '#7CB342';
            }, 150);

            setTimeout(() => {
                letterEl.style.transform = 'scale(1.6) rotate(0deg)';
                letterEl.style.color = '#00BCD4';
            }, 300);

            setTimeout(() => {
                letterEl.style.transform = 'scale(1.2)';
                letterEl.style.color = '#FF5722';
            }, 450);

            setTimeout(() => {
                letterEl.style.transform = 'scale(1.4)';
                letterEl.style.color = '#9C27B0';
            }, 600);

            setTimeout(() => {
                letterEl.style.transition = 'all 0.3s ease-out';
                letterEl.style.transform = 'scale(1)';
                letterEl.style.color = '#FDD835';
            }, 800);

            // Create confetti particles
            createLevel1Confetti(letterEl);
        }

        function createLevel1Confetti(centerEl) {
            const container = centerEl.parentElement;
            const rect = centerEl.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const colors = ['#FDD835', '#7CB342', '#00BCD4', '#FF5722', '#9C27B0'];

            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.style.position = 'fixed';
                particle.style.left = centerX + 'px';
                particle.style.top = centerY + 'px';
                particle.style.width = '10px';
                particle.style.height = '10px';
                particle.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                particle.style.pointerEvents = 'none';
                particle.style.zIndex = '9999';

                document.body.appendChild(particle);

                const angle = (Math.PI * 2 * i) / 20;
                const velocity = 100 + Math.random() * 100;
                const vx = Math.cos(angle) * velocity;
                const vy = Math.sin(angle) * velocity;

                let x = 0, y = 0, time = 0;
                const gravity = 500;

                const animate = () => {
                    time += 0.016; // ~60fps
                    x = vx * time;
                    y = vy * time + 0.5 * gravity * time * time;

                    particle.style.transform = `translate(${x}px, ${y}px) rotate(${time * 360}deg)`;
                    particle.style.opacity = Math.max(0, 1 - time * 1.5);

                    if (time < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        particle.remove();
                    }
                };

                requestAnimationFrame(animate);
            }
        }

        function completeLevel1() {
            level1Running = false;
            document.getElementById('level1Letter').textContent = 'üéâ';
            document.getElementById('level1Instruction').textContent = 'Amazing! You completed Level 1!';
            document.getElementById('level1Btn').textContent = 'üîÑ Play Again';
        }

        // Initialize
        // Load last used profile
        const savedProfile = localStorage.getItem('currentProfile');
        if (savedProfile) {
            currentProfile = savedProfile;
        }

        loadProfiles();
        loadCalibration();
        loadAudioRecordings();
        loadAttemptHistory();
        createCalibrationGrid();
        updateMasteryUI();
        updateCalibrationStats();
    </script>
</body>
</html>
